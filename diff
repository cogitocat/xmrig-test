diff --git a/.gitignore b/.gitignore
index 259148f..378eac2 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,32 +1 @@
-# Prerequisites
-*.d
-
-# Compiled Object files
-*.slo
-*.lo
-*.o
-*.obj
-
-# Precompiled Headers
-*.gch
-*.pch
-
-# Compiled Dynamic libraries
-*.so
-*.dylib
-*.dll
-
-# Fortran module files
-*.mod
-*.smod
-
-# Compiled Static libraries
-*.lai
-*.la
-*.a
-*.lib
-
-# Executables
-*.exe
-*.out
-*.app
+build
diff --git a/CMakeLists.txt b/CMakeLists.txt
index 849c125..a345e3b 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -3,16 +3,9 @@ project(xmrig)
 
 option(WITH_LIBCPUID        "Enable libcpuid support" ON)
 option(WITH_HWLOC           "Enable hwloc support" ON)
-option(WITH_CN_LITE         "Enable CryptoNight-Lite algorithms family" ON)
-option(WITH_CN_HEAVY        "Enable CryptoNight-Heavy algorithms family" ON)
-option(WITH_CN_PICO         "Enable CryptoNight-Pico algorithm" ON)
-option(WITH_CN_GPU          "Enable CryptoNight-GPU algorithm" ON)
-option(WITH_RANDOMX         "Enable RandomX algorithms family" ON)
-option(WITH_ARGON2          "Enable Argon2 algorithms family" ON)
 option(WITH_HTTP            "Enable HTTP protocol support (client/server)" ON)
 option(WITH_DEBUG_LOG       "Enable debug log output" OFF)
 option(WITH_TLS             "Enable OpenSSL support" ON)
-option(WITH_ASM             "Enable ASM PoW implementations" ON)
 option(WITH_EMBEDDED_CONFIG "Enable internal embedded JSON config" OFF)
 option(WITH_OPENCL          "Enable OpenCL backend" ON)
 option(WITH_CUDA            "Enable CUDA backend" ON)
@@ -21,7 +14,6 @@ option(WITH_STRICT_CACHE    "Enable strict checks for OpenCL cache" ON)
 option(WITH_INTERLEAVE_DEBUG_LOG "Enable debug log for threads interleave" OFF)
 
 option(BUILD_STATIC         "Build static binary" OFF)
-option(ARM_TARGET           "Force use specific ARM target 8 or 7" 0)
 option(HWLOC_DEBUG          "Enable hwloc debug helpers and log" OFF)
 
 
@@ -58,7 +50,6 @@ set(HEADERS
 
 set(HEADERS_CRYPTO
     src/backend/common/interfaces/IMemoryPool.h
-    src/crypto/cn/asm/CryptonightR_template.h
     src/crypto/cn/c_blake256.h
     src/crypto/cn/c_groestl.h
     src/crypto/cn/c_jh.h
@@ -67,27 +58,20 @@ set(HEADERS_CRYPTO
     src/crypto/cn/CnCtx.h
     src/crypto/cn/CnHash.h
     src/crypto/cn/CryptoNight_monero.h
-    src/crypto/cn/CryptoNight_test.h
     src/crypto/cn/CryptoNight.h
     src/crypto/cn/groestl_tables.h
     src/crypto/cn/hash.h
     src/crypto/cn/skein_port.h
     src/crypto/cn/soft_aes.h
     src/crypto/common/Algorithm.h
-    src/crypto/common/Coin.h
     src/crypto/common/keccak.h
     src/crypto/common/MemoryPool.h
     src/crypto/common/Nonce.h
     src/crypto/common/portable/mm_malloc.h
     src/crypto/common/VirtualMemory.h
+    src/crypto/cn/CryptoNight_x86.h
    )
 
-if (XMRIG_ARM)
-    set(HEADERS_CRYPTO "${HEADERS_CRYPTO}" src/crypto/cn/CryptoNight_arm.h)
-else()
-    set(HEADERS_CRYPTO "${HEADERS_CRYPTO}" src/crypto/cn/CryptoNight_x86.h)
-endif()
-
 set(SOURCES
     "${SOURCES_BASE}"
     "${SOURCES_BASE_HTTP}"
@@ -113,7 +97,6 @@ set(SOURCES_CRYPTO
     src/crypto/cn/CnCtx.cpp
     src/crypto/cn/CnHash.cpp
     src/crypto/common/Algorithm.cpp
-    src/crypto/common/Coin.cpp
     src/crypto/common/keccak.cpp
     src/crypto/common/MemoryPool.cpp
     src/crypto/common/Nonce.cpp
@@ -174,23 +157,7 @@ add_definitions(/DUNICODE)
 find_package(UV REQUIRED)
 
 include(cmake/flags.cmake)
-include(cmake/randomx.cmake)
-include(cmake/argon2.cmake)
 include(cmake/OpenSSL.cmake)
-include(cmake/asm.cmake)
-include(cmake/cn-gpu.cmake)
-
-if (WITH_CN_LITE)
-    add_definitions(/DXMRIG_ALGO_CN_LITE)
-endif()
-
-if (WITH_CN_HEAVY)
-    add_definitions(/DXMRIG_ALGO_CN_HEAVY)
-endif()
-
-if (WITH_CN_PICO)
-    add_definitions(/DXMRIG_ALGO_CN_PICO)
-endif()
 
 if (WITH_EMBEDDED_CONFIG)
     add_definitions(/DXMRIG_FEATURE_EMBEDDED_CONFIG)
@@ -208,5 +175,5 @@ if (WITH_DEBUG_LOG)
     add_definitions(/DAPP_DEBUG)
 endif()
 
-add_executable(${CMAKE_PROJECT_NAME} ${HEADERS} ${SOURCES} ${SOURCES_OS} ${SOURCES_CPUID} ${HEADERS_CRYPTO} ${SOURCES_CRYPTO} ${SOURCES_SYSLOG} ${TLS_SOURCES} ${XMRIG_ASM_SOURCES} ${CN_GPU_SOURCES})
-target_link_libraries(${CMAKE_PROJECT_NAME} ${XMRIG_ASM_LIBRARY} ${OPENSSL_LIBRARIES} ${UV_LIBRARIES} ${EXTRA_LIBS} ${CPUID_LIB} ${ARGON2_LIBRARY})
+add_executable(${CMAKE_PROJECT_NAME} ${HEADERS} ${SOURCES} ${SOURCES_OS} ${SOURCES_CPUID} ${HEADERS_CRYPTO} ${SOURCES_CRYPTO} ${SOURCES_SYSLOG} ${TLS_SOURCES})
+target_link_libraries(${CMAKE_PROJECT_NAME} ${OPENSSL_LIBRARIES} ${UV_LIBRARIES} ${EXTRA_LIBS} ${CPUID_LIB})
diff --git a/cmake/cpu.cmake b/cmake/cpu.cmake
index 2fdebad..cb0319a 100644
--- a/cmake/cpu.cmake
+++ b/cmake/cpu.cmake
@@ -6,38 +6,3 @@ endif()
 if (CMAKE_SYSTEM_PROCESSOR MATCHES "^(x86_64|AMD64)$")
     add_definitions(/DRAPIDJSON_SSE2)
 endif()
-
-if (NOT ARM_TARGET)
-    if (CMAKE_SYSTEM_PROCESSOR MATCHES "^(aarch64|arm64|armv8-a)$")
-        set(ARM_TARGET 8)
-    elseif (CMAKE_SYSTEM_PROCESSOR MATCHES "^(armv7|armv7f|armv7s|armv7k|armv7-a|armv7l)$")
-        set(ARM_TARGET 7)
-    endif()
-endif()
-
-if (ARM_TARGET AND ARM_TARGET GREATER 6)
-    set(XMRIG_ARM     ON)
-    set(WITH_LIBCPUID OFF)
-    add_definitions(/DXMRIG_ARM)
-
-    message(STATUS "Use ARM_TARGET=${ARM_TARGET} (${CMAKE_SYSTEM_PROCESSOR})")
-
-    include(CheckCXXCompilerFlag)
-
-    if (ARM_TARGET EQUAL 8)
-        set(XMRIG_ARMv8 ON)
-        add_definitions(/DXMRIG_ARMv8)
-
-        CHECK_CXX_COMPILER_FLAG(-march=armv8-a+crypto XMRIG_ARM_CRYPTO)
-
-        if (XMRIG_ARM_CRYPTO)
-            add_definitions(/DXMRIG_ARM_CRYPTO)
-            set(ARM8_CXX_FLAGS "-march=armv8-a+crypto")
-        else()
-            set(ARM8_CXX_FLAGS "-march=armv8-a")
-        endif()
-    elseif (ARM_TARGET EQUAL 7)
-        set(XMRIG_ARMv7 ON)
-        add_definitions(/DXMRIG_ARMv7)
-    endif()
-endif()
diff --git a/cmake/flags.cmake b/cmake/flags.cmake
index e9533ee..050fe52 100644
--- a/cmake/flags.cmake
+++ b/cmake/flags.cmake
@@ -22,18 +22,10 @@ if (CMAKE_CXX_COMPILER_ID MATCHES GNU)
     set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -fexceptions -fno-rtti -Wno-strict-aliasing -Wno-class-memaccess")
     set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -Ofast -s")
 
-    if (XMRIG_ARMv8)
-        set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${ARM8_CXX_FLAGS}")
-        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${ARM8_CXX_FLAGS} -flax-vector-conversions")
-    elseif (XMRIG_ARMv7)
-        set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -mfpu=neon")
-        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -mfpu=neon -flax-vector-conversions")
-    else()
-        set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -maes")
-        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -maes")
+    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -maes")
+    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -maes")
 
-        add_definitions(/DHAVE_ROTR)
-    endif()
+    add_definitions(/DHAVE_ROTR)
 
     if (WIN32)
         if (CMAKE_SIZEOF_VOID_P EQUAL 8)
@@ -73,20 +65,12 @@ elseif (CMAKE_CXX_COMPILER_ID MATCHES Clang)
     set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -fexceptions -fno-rtti -Wno-missing-braces")
     set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -Ofast -funroll-loops -fmerge-all-constants")
 
-    if (XMRIG_ARMv8)
-        set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${ARM8_CXX_FLAGS}")
-        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${ARM8_CXX_FLAGS}")
-    elseif (XMRIG_ARMv7)
-        set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -mfpu=neon -march=${CMAKE_SYSTEM_PROCESSOR}")
-        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -mfpu=neon -march=${CMAKE_SYSTEM_PROCESSOR}")
-    else()
-        set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -maes")
-        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -maes")
+    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -maes")
+    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -maes")
 
-        check_symbol_exists("_rotr" "x86intrin.h" HAVE_ROTR)
-        if (HAVE_ROTR)
-            add_definitions(/DHAVE_ROTR)
-        endif()
+    check_symbol_exists("_rotr" "x86intrin.h" HAVE_ROTR)
+    if (HAVE_ROTR)
+        add_definitions(/DHAVE_ROTR)
     endif()
 
 endif()
diff --git a/compile b/compile
new file mode 100755
index 0000000..3b2dc0f
--- /dev/null
+++ b/compile
@@ -0,0 +1,20 @@
+#!/bin/bash
+dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
+
+rm -rf ${dir}/build
+mkdir -p ${dir}/build
+cd ${dir}/build
+
+cmake -WITH_OPENCL=OFF ${dir}
+make -j6
+
+mkdir -p ${dir}/build/cuda
+cd ${dir}/build/cuda
+
+cmake -DCMAKE_C_COMPILER=/usr/bin/gcc-6 ${dir}/xmrig-cuda
+make -j6
+
+cp ./libxmrig-cuda.so ../libxmrig-cuda.so
+
+cd ${dir}
+cp ${dir}/src/config.json ${dir}/build/config.json
diff --git a/src/Summary.cpp b/src/Summary.cpp
index 2055e97..cbe5621 100644
--- a/src/Summary.cpp
+++ b/src/Summary.cpp
@@ -41,24 +41,6 @@
 
 namespace xmrig {
 
-
-#ifdef XMRIG_FEATURE_ASM
-static const char *coloredAsmNames[] = {
-    RED_BOLD("none"),
-    "auto",
-    GREEN_BOLD("intel"),
-    GREEN_BOLD("ryzen"),
-    GREEN_BOLD("bulldozer")
-};
-
-
-inline static const char *asmName(Assembly::Id assembly)
-{
-    return coloredAsmNames[assembly];
-}
-#endif
-
-
 static void print_memory(Config *config) {
 #   ifdef _WIN32
     Log::print(GREEN_BOLD(" * ") WHITE_BOLD("%-13s") "%s",
@@ -101,28 +83,6 @@ static void print_cpu(Config *)
 #   endif
 }
 
-
-static void print_threads(Config *config)
-{
-    Log::print(GREEN_BOLD(" * ") WHITE_BOLD("%-13s") WHITE_BOLD("%s%d%%"),
-               "DONATE",
-               config->pools().donateLevel() == 0 ? RED_BOLD_S : "",
-               config->pools().donateLevel()
-               );
-
-#   ifdef XMRIG_FEATURE_ASM
-    if (config->cpu().assembly() == Assembly::AUTO) {
-        const Assembly assembly = Cpu::info()->assembly();
-
-        Log::print(GREEN_BOLD(" * ") WHITE_BOLD("%-13sauto:%s"), "ASSEMBLY", asmName(assembly));
-    }
-    else {
-        Log::print(GREEN_BOLD(" * ") WHITE_BOLD("%-13s%s"), "ASSEMBLY", asmName(config->cpu().assembly()));
-    }
-#   endif
-}
-
-
 static void print_commands(Config *)
 {
     if (Log::colors) {
@@ -144,9 +104,7 @@ void xmrig::Summary::print(Controller *controller)
     controller->config()->printVersions();
     print_memory(controller->config());
     print_cpu(controller->config());
-    print_threads(controller->config());
     controller->config()->pools().print();
-
     print_commands(controller->config());
 }
 
diff --git a/src/backend/common/Tags.h b/src/backend/common/Tags.h
index 9141eb7..27b195f 100644
--- a/src/backend/common/Tags.h
+++ b/src/backend/common/Tags.h
@@ -47,13 +47,6 @@ const char *ocl_tag();
 const char *cuda_tag();
 #endif
 
-
-
-#ifdef XMRIG_ALGO_RANDOMX
-const char *rx_tag();
-#endif
-
-
 } // namespace xmrig
 
 
diff --git a/src/backend/common/Threads.cpp b/src/backend/common/Threads.cpp
index f85e18f..ce9b06e 100644
--- a/src/backend/common/Threads.cpp
+++ b/src/backend/common/Threads.cpp
@@ -38,29 +38,6 @@
 #   include "backend/cuda/CudaThreads.h"
 #endif
 
-
-namespace xmrig {
-
-
-static const char *kAsterisk = "*";
-static const char *kCn2      = "cn/2";
-
-
-} // namespace xmrig
-
-
-template <class T>
-const T &xmrig::Threads<T>::get(const String &profileName) const
-{
-    static T empty;
-    if (profileName.isNull() || !has(profileName)) {
-        return empty;
-    }
-
-    return m_profiles.at(profileName);
-}
-
-
 template <class T>
 size_t xmrig::Threads<T>::read(const rapidjson::Value &value)
 {
@@ -75,92 +52,26 @@ size_t xmrig::Threads<T>::read(const rapidjson::Value &value)
             }
         }
     }
-
     for (auto &member : value.GetObject()) {
         if (member.value.IsArray() || member.value.IsObject()) {
             continue;
         }
-
-        const Algorithm algo(member.name.GetString());
-        if (!algo.isValid()) {
-            continue;
-        }
-
-        if (member.value.IsBool() && member.value.IsFalse()) {
-            disable(algo);
-            continue;
-        }
-
-        if (member.value.IsString()) {
-            if (has(member.value.GetString())) {
-                m_aliases.insert({ algo, member.value.GetString() });
-            }
-            else {
-                m_disabled.insert(algo);
-            }
-        }
     }
 
     return m_profiles.size();
 }
 
-
-template <class T>
-xmrig::String xmrig::Threads<T>::profileName(const Algorithm &algorithm, bool strict) const
-{
-    if (isDisabled(algorithm)) {
-        return String();
-    }
-
-    const String name = algorithm.shortName();
-    if (has(name)) {
-        return name;
-    }
-
-    if (m_aliases.count(algorithm) > 0) {
-        return m_aliases.at(algorithm);
-    }
-
-    if (strict) {
-        return String();
-    }
-
-    if (algorithm.family() == Algorithm::CN && CnAlgo<>::base(algorithm) == Algorithm::CN_2 && has(kCn2)) {
-        return kCn2;
-    }
-
-    if (name.contains("/")) {
-        const String base = name.split('/').at(0);
-        if (has(base)) {
-            return base;
-        }
-    }
-
-    if (has(kAsterisk)) {
-        return kAsterisk;
-    }
-
-    return String();
-}
-
-
 template <class T>
 void xmrig::Threads<T>::toJSON(rapidjson::Value &out, rapidjson::Document &doc) const
 {
     using namespace rapidjson;
     auto &allocator = doc.GetAllocator();
 
-    for (const auto &kv : m_profiles) {
-        out.AddMember(kv.first.toJSON(), kv.second.toJSON(doc), allocator);
-    }
-
-    for (const Algorithm &algo : m_disabled) {
-        out.AddMember(StringRef(algo.shortName()), false, allocator);
-    }
-
-    for (const auto &kv : m_aliases) {
-        out.AddMember(StringRef(kv.first.shortName()), kv.second.toJSON(), allocator);
-    }
+    if (has())
+    {
+        auto &ct = get();
+        out.AddMember("cn/blur", ct.toJSON(doc), allocator);
+    }   
 }
 
 
diff --git a/src/backend/common/Threads.h b/src/backend/common/Threads.h
index 59b04fc..78d5855 100644
--- a/src/backend/common/Threads.h
+++ b/src/backend/common/Threads.h
@@ -42,17 +42,13 @@ template <class T>
 class Threads
 {
 public:
-    inline bool has(const char *profile) const                                         { return m_profiles.count(profile) > 0; }
-    inline bool isDisabled(const Algorithm &algo) const                                { return m_disabled.count(algo) > 0; }
-    inline bool isEmpty() const                                                        { return m_profiles.empty(); }
-    inline bool isExist(const Algorithm &algo) const                                   { return isDisabled(algo) || m_aliases.count(algo) > 0 || has(algo.shortName()); }
-    inline const T &get(const Algorithm &algo, bool strict = false) const              { return get(profileName(algo, strict)); }
-    inline void disable(const Algorithm &algo)                                         { m_disabled.insert(algo); }
-    inline void setAlias(const Algorithm &algo, const char *profile)                   { m_aliases[algo] = profile; }
+    inline bool has() const                                         { return m_profiles.count("cn/blur") > 0; }
+    inline bool isEmpty() const                                     { return m_profiles.empty(); }
+    inline const T &get() const                                     { return m_profiles.at("cn/blur"); }
 
     inline size_t move(const char *profile, T &&threads)
     {
-        if (has(profile)) {
+        if (has()) {
             return 0;
         }
 
@@ -65,15 +61,11 @@ public:
         return count;
     }
 
-    const T &get(const String &profileName) const;
     size_t read(const rapidjson::Value &value);
-    String profileName(const Algorithm &algorithm, bool strict = false) const;
     void toJSON(rapidjson::Value &out, rapidjson::Document &doc) const;
 
 private:
-    std::map<Algorithm, String> m_aliases;
     std::map<String, T> m_profiles;
-    std::set<Algorithm> m_disabled;
 };
 
 
diff --git a/src/backend/common/VarInt.h b/src/backend/common/VarInt.h
new file mode 100644
index 0000000..7e3eaa9
--- /dev/null
+++ b/src/backend/common/VarInt.h
@@ -0,0 +1,128 @@
+// Copyright (c) 2014-2018, The Monero Project
+// 
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without modification, are
+// permitted provided that the following conditions are met:
+// 
+// 1. Redistributions of source code must retain the above copyright notice, this list of
+//    conditions and the following disclaimer.
+// 
+// 2. Redistributions in binary form must reproduce the above copyright notice, this list
+//    of conditions and the following disclaimer in the documentation and/or other
+//    materials provided with the distribution.
+// 
+// 3. Neither the name of the copyright holder nor the names of its contributors may be
+//    used to endorse or promote products derived from this software without specific
+//    prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
+// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
+// THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
+// THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+// 
+// Parts of this file are originally copyright (c) 2012-2013 The Cryptonote developers
+
+#pragma once
+
+#include <limits>
+#include <type_traits>
+#include <utility>
+#include <sstream>
+#include <string>
+/*! \file varint.h
+ * \brief provides the implementation of varint's
+ * 
+ * The representation of varints is rather odd. The first bit of each
+ * octet is significant, it represents wheter there is another part
+ * waiting to be read. For example 0x8002 would return 0x200, even
+ * though 0x02 does not have its msb set. The actual way they are read
+ * is as follows: Strip the msb of each byte, then from left to right,
+ * read in what remains, placing it in reverse, into the buffer. Thus,
+ * the following bit stream: 0xff02 would return 0x027f. 0xff turns
+ * into 0x7f, is placed on the beginning of the buffer, then 0x02 is
+ * unchanged, since its msb is not set, and placed at the end of the
+ * buffer.
+ */
+
+namespace tools {
+
+  /*! \brief Error codes for varint
+   */
+  enum {
+    /* \brief Represents the overflow error */
+    EVARINT_OVERFLOW = -1,
+    /* \brief Represents a non conical represnetation */
+    EVARINT_REPRESENT = -2,
+  };
+
+  /*! \brief writes a varint to a stream.
+   */
+  template<typename OutputIt, typename T>
+  /* Requires T to be both an integral type and unsigned, should be a compile error if it is not */
+  typename std::enable_if<std::is_integral<T>::value && std::is_unsigned<T>::value, void>::type 
+  write_varint(OutputIt &&dest, T i) {
+    /* Make sure that there is one after this */
+    while (i >= 0x80) {
+      *dest = (static_cast<char>(i) & 0x7f) | 0x80; 
+      ++dest;
+      i >>= 7;			/* I should be in multiples of 7, this should just get the next part */
+    }
+    /* writes the last one to dest */
+    *dest = static_cast<char>(i);
+    dest++;			/* Seems kinda pointless... */
+  }
+
+  /*! \brief Returns the string that represents the varint
+   */
+  template<typename T>
+    std::string get_varint_data(const T& v)
+    {
+      std::stringstream ss;
+      write_varint(std::ostreambuf_iterator<char>(ss), v);
+      return ss.str();
+    }
+  /*! \brief reads in the varint that is pointed to by InputIt into write
+   */ 
+  template<int bits, typename InputIt, typename T>
+    typename std::enable_if<std::is_integral<T>::value && std::is_unsigned<T>::value && 0 <= bits && bits <= std::numeric_limits<T>::digits, int>::type
+    read_varint(InputIt &&first, InputIt &&last, T &write) {
+    int read = 0;
+    write = 0;
+    for (int shift = 0;; shift += 7) {
+      if (first == last) {
+	return read; 
+      }
+      unsigned char byte = *first;
+      ++first;
+      ++read;
+      if (shift + 7 >= bits && byte >= 1 << (bits - shift)) {
+	return EVARINT_OVERFLOW;
+      }
+      if (byte == 0 && shift != 0) {
+	return EVARINT_REPRESENT;
+      }
+
+      write |= static_cast<T>(byte & 0x7f) << shift; /* Does the actually placing into write, stripping the first bit */
+
+      /* If there is no next */
+      if ((byte & 0x80) == 0) {
+	break;
+      }
+    }
+    return read;
+  }
+
+  /*! \brief Wrapper around the other read_varint,
+   *  Sets template parameters for you.
+   */
+  template<typename InputIt, typename T>
+    int read_varint(InputIt &&first, InputIt &&last, T &i) {
+    return read_varint<std::numeric_limits<T>::digits, InputIt, T>(std::move(first), std::move(last), i);
+  }
+}
\ No newline at end of file
diff --git a/src/backend/common/WorkerJob.h b/src/backend/common/WorkerJob.h
index 2ea4147..0b39294 100644
--- a/src/backend/common/WorkerJob.h
+++ b/src/backend/common/WorkerJob.h
@@ -70,7 +70,7 @@ public:
 
         if ((m_rounds[index()] % rounds) == 0) {
             for (size_t i = 0; i < N; ++i) {
-                *nonce(i) = Nonce::next(index(), *nonce(i), rounds * roundSize, currentJob().isNicehash());
+                *nonce(i) = Nonce::next(index(), *nonce(i), rounds * roundSize);
             }
         }
         else {
@@ -93,7 +93,7 @@ private:
 
         for (size_t i = 0; i < N; ++i) {
             memcpy(m_blobs[index()] + (i * size), job.blob(), size);
-            *nonce(i) = Nonce::next(index(), *nonce(i), reserveCount, job.isNicehash());
+            *nonce(i) = Nonce::next(index(), *nonce(i), reserveCount);
         }
     }
 
@@ -119,7 +119,7 @@ inline void xmrig::WorkerJob<1>::nextRound(uint32_t rounds, uint32_t roundSize)
     m_rounds[index()]++;
 
     if ((m_rounds[index()] % rounds) == 0) {
-        *nonce() = Nonce::next(index(), *nonce(), rounds * roundSize, currentJob().isNicehash());
+        *nonce() = Nonce::next(index(), *nonce(), rounds * roundSize);
     }
     else {
         *nonce() += roundSize;
@@ -137,7 +137,7 @@ inline void xmrig::WorkerJob<1>::save(const Job &job, uint32_t reserveCount, Non
     m_jobs[index()].setBackend(backend);
 
     memcpy(blob(), job.blob(), job.size());
-    *nonce() = Nonce::next(index(), *nonce(), reserveCount, currentJob().isNicehash());
+    *nonce() = Nonce::next(index(), *nonce(), reserveCount);
 }
 
 
diff --git a/src/backend/common/common.cmake b/src/backend/common/common.cmake
index 9dd0fb3..4ff9fff 100644
--- a/src/backend/common/common.cmake
+++ b/src/backend/common/common.cmake
@@ -2,8 +2,6 @@ set(HEADERS_BACKEND_COMMON
     src/backend/common/Hashrate.h
     src/backend/common/Tags.h
     src/backend/common/interfaces/IBackend.h
-    src/backend/common/interfaces/IRxListener.h
-    src/backend/common/interfaces/IRxStorage.h
     src/backend/common/interfaces/IThread.h
     src/backend/common/interfaces/IWorker.h
     src/backend/common/misc/PciTopology.h
diff --git a/src/backend/common/interfaces/IBackend.h b/src/backend/common/interfaces/IBackend.h
index c6e05bc..8efd84c 100644
--- a/src/backend/common/interfaces/IBackend.h
+++ b/src/backend/common/interfaces/IBackend.h
@@ -34,7 +34,6 @@
 
 namespace xmrig {
 
-
 class Algorithm;
 class Hashrate;
 class IApiRequest;
@@ -51,7 +50,6 @@ public:
     virtual bool isEnabled() const                                      = 0;
     virtual bool isEnabled(const Algorithm &algorithm) const            = 0;
     virtual const Hashrate *hashrate() const                            = 0;
-    virtual const String &profileName() const                           = 0;
     virtual const String &type() const                                  = 0;
     virtual void execCommand(char command)                              = 0;
     virtual void prepare(const Job &nextJob)                            = 0;
diff --git a/src/backend/cpu/Cpu.cpp b/src/backend/cpu/Cpu.cpp
index 5d095e6..28c0022 100644
--- a/src/backend/cpu/Cpu.cpp
+++ b/src/backend/cpu/Cpu.cpp
@@ -79,11 +79,7 @@ rapidjson::Value xmrig::Cpu::toJSON(rapidjson::Document &doc)
     cpu.AddMember("nodes",      static_cast<uint64_t>(i->nodes()), allocator);
     cpu.AddMember("backend",    StringRef(i->backend()), allocator);
 
-#   ifdef XMRIG_FEATURE_ASM
-    cpu.AddMember("assembly", StringRef(assembly.toString()), allocator);
-#   else
     cpu.AddMember("assembly", "none", allocator);
-#   endif
 
     return cpu;
 }
diff --git a/src/backend/cpu/CpuBackend.cpp b/src/backend/cpu/CpuBackend.cpp
index ddee676..71cde36 100644
--- a/src/backend/cpu/CpuBackend.cpp
+++ b/src/backend/cpu/CpuBackend.cpp
@@ -39,8 +39,6 @@
 #include "core/config/Config.h"
 #include "core/Controller.h"
 #include "crypto/common/VirtualMemory.h"
-#include "crypto/rx/Rx.h"
-#include "crypto/rx/RxDataset.h"
 #include "rapidjson/document.h"
 
 
@@ -49,11 +47,6 @@
 #endif
 
 
-#ifdef XMRIG_ALGO_ARGON2
-#   include "crypto/argon2/Impl.h"
-#endif
-
-
 namespace xmrig {
 
 
@@ -146,15 +139,14 @@ public:
 
     inline void start()
     {
-        LOG_INFO("%s use profile " BLUE_BG(WHITE_BOLD_S " %s ") WHITE_BOLD_S " (" CYAN_BOLD("%zu") WHITE_BOLD(" thread%s)") " scratchpad " CYAN_BOLD("%zu KB"),
+        LOG_INFO("%s use profile " BLUE_BG(WHITE_BOLD_S " cn/blur ") WHITE_BOLD_S " (" CYAN_BOLD("%zu") WHITE_BOLD(" thread%s)") " scratchpad " CYAN_BOLD("%zu KB"),
                  tag,
-                 profileName.data(),
                  threads.size(),
                  threads.size() > 1 ? "s" : "",
-                 algo.l3() / 1024
+                 CnAlgo::CN_MEMORY / 1024
                  );
 
-        status.start(threads, algo.l3());
+        status.start(threads, CnAlgo::CN_MEMORY);
         workers.start(threads);
     }
 
@@ -171,12 +163,6 @@ public:
     {
         std::pair<unsigned, unsigned> pages(0, 0);
 
-    #   ifdef XMRIG_ALGO_RANDOMX
-        if (algo.family() == Algorithm::RANDOM_X) {
-            pages = Rx::hugePages();
-        }
-    #   endif
-
         mutex.lock();
 
         pages.first  += status.hugePages();
@@ -198,12 +184,9 @@ public:
         return hugepages;
     }
 
-
-    Algorithm algo;
     Controller *controller;
     CpuLaunchStatus status;
     std::vector<CpuLaunchData> threads;
-    String profileName;
     Workers<CpuLaunchData> workers;
 };
 
@@ -256,7 +239,7 @@ bool xmrig::CpuBackend::isEnabled() const
 
 bool xmrig::CpuBackend::isEnabled(const Algorithm &algorithm) const
 {
-    return !d_ptr->controller->config()->cpu().threads().get(algorithm).isEmpty();
+    return !d_ptr->controller->config()->cpu().threads().get().isEmpty();
 }
 
 
@@ -266,12 +249,6 @@ const xmrig::Hashrate *xmrig::CpuBackend::hashrate() const
 }
 
 
-const xmrig::String &xmrig::CpuBackend::profileName() const
-{
-    return d_ptr->profileName;
-}
-
-
 const xmrig::String &xmrig::CpuBackend::type() const
 {
     return kType;
@@ -280,15 +257,7 @@ const xmrig::String &xmrig::CpuBackend::type() const
 
 void xmrig::CpuBackend::prepare(const Job &nextJob)
 {
-#   ifdef XMRIG_ALGO_ARGON2
-    if (nextJob.algorithm().family() == Algorithm::ARGON2 && argon2::Impl::select(d_ptr->controller->config()->cpu().argon2Impl())) {
-        LOG_INFO("%s use " WHITE_BOLD("argon2") " implementation " CSI "1;%dm" "%s",
-                 tag,
-                 argon2::Impl::name() == "default" ? 33 : 32,
-                 argon2::Impl::name().data()
-                 );
-    }
-#   endif
+
 }
 
 
@@ -333,15 +302,12 @@ void xmrig::CpuBackend::setJob(const Job &job)
 
     const CpuConfig &cpu = d_ptr->controller->config()->cpu();
 
-    std::vector<CpuLaunchData> threads = cpu.get(d_ptr->controller->miner(), job.algorithm());
+    std::vector<CpuLaunchData> threads = cpu.get(d_ptr->controller->miner());
     if (!d_ptr->threads.empty() && d_ptr->threads.size() == threads.size() && std::equal(d_ptr->threads.begin(), d_ptr->threads.end(), threads.begin())) {
         return;
     }
 
-    d_ptr->algo         = job.algorithm();
-    d_ptr->profileName  = cpu.threads().profileName(job.algorithm());
-
-    if (d_ptr->profileName.isNull() || threads.empty()) {
+    if (threads.empty()) {
         LOG_WARN("%s " RED_BOLD("disabled") YELLOW(" (no suitable configuration found)"), tag);
 
         return stop();
@@ -401,24 +367,11 @@ rapidjson::Value xmrig::CpuBackend::toJSON(rapidjson::Document &doc) const
     Value out(kObjectType);
     out.AddMember("type",       type().toJSON(), allocator);
     out.AddMember("enabled",    isEnabled(), allocator);
-    out.AddMember("algo",       d_ptr->algo.toJSON(), allocator);
-    out.AddMember("profile",    profileName().toJSON(), allocator);
     out.AddMember("hw-aes",     cpu.isHwAES(), allocator);
     out.AddMember("priority",   cpu.priority(), allocator);
 
-#   ifdef XMRIG_FEATURE_ASM
-    const Assembly assembly = Cpu::assembly(cpu.assembly());
-    out.AddMember("asm", assembly.toJSON(), allocator);
-#   else
-    out.AddMember("asm", false, allocator);
-#   endif
-
-#   ifdef XMRIG_ALGO_ARGON2
-    out.AddMember("argon2-impl", argon2::Impl::name().toJSON(), allocator);
-#   endif
-
     out.AddMember("hugepages", d_ptr->hugePages(2, doc), allocator);
-    out.AddMember("memory",    static_cast<uint64_t>(d_ptr->algo.isValid() ? (d_ptr->ways() * d_ptr->algo.l3()) : 0), allocator);
+    out.AddMember("memory",    static_cast<uint64_t>(d_ptr->ways() * CnAlgo::CN_MEMORY), allocator);
 
     if (d_ptr->threads.empty() || !hashrate()) {
         return out;
diff --git a/src/backend/cpu/CpuBackend.h b/src/backend/cpu/CpuBackend.h
index d0e2267..b46c65a 100644
--- a/src/backend/cpu/CpuBackend.h
+++ b/src/backend/cpu/CpuBackend.h
@@ -55,7 +55,6 @@ protected:
     bool isEnabled() const override;
     bool isEnabled(const Algorithm &algorithm) const override;
     const Hashrate *hashrate() const override;
-    const String &profileName() const override;
     const String &type() const override;
     void prepare(const Job &nextJob) override;
     void printHashrate(bool details) override;
diff --git a/src/backend/cpu/CpuConfig.cpp b/src/backend/cpu/CpuConfig.cpp
index e9abd9e..c520e67 100644
--- a/src/backend/cpu/CpuConfig.cpp
+++ b/src/backend/cpu/CpuConfig.cpp
@@ -39,14 +39,6 @@ static const char *kMaxThreadsHint      = "max-threads-hint";
 static const char *kMemoryPool          = "memory-pool";
 static const char *kPriority            = "priority";
 
-#ifdef XMRIG_FEATURE_ASM
-static const char *kAsm = "asm";
-#endif
-
-#ifdef XMRIG_ALGO_ARGON2
-static const char *kArgon2Impl = "argon2-impl";
-#endif
-
 extern template class Threads<CpuThreads>;
 
 }
@@ -75,14 +67,6 @@ rapidjson::Value xmrig::CpuConfig::toJSON(rapidjson::Document &doc) const
         obj.AddMember(StringRef(kMaxThreadsHint), m_limit, allocator);
     }
 
-#   ifdef XMRIG_FEATURE_ASM
-    obj.AddMember(StringRef(kAsm), m_assembly.toJSON(), allocator);
-#   endif
-
-#   ifdef XMRIG_ALGO_ARGON2
-    obj.AddMember(StringRef(kArgon2Impl), m_argon2Impl.toJSON(), allocator);
-#   endif
-
     m_threads.toJSON(obj, doc);
 
     return obj;
@@ -95,10 +79,10 @@ size_t xmrig::CpuConfig::memPoolSize() const
 }
 
 
-std::vector<xmrig::CpuLaunchData> xmrig::CpuConfig::get(const Miner *miner, const Algorithm &algorithm) const
+std::vector<xmrig::CpuLaunchData> xmrig::CpuConfig::get(const Miner *miner) const
 {
     std::vector<CpuLaunchData> out;
-    const CpuThreads &threads = m_threads.get(algorithm);
+    const CpuThreads &threads = m_threads.get();
 
     if (threads.isEmpty()) {
         return out;
@@ -107,7 +91,7 @@ std::vector<xmrig::CpuLaunchData> xmrig::CpuConfig::get(const Miner *miner, cons
     out.reserve(threads.count());
 
     for (const CpuThread &thread : threads.data()) {
-        out.emplace_back(miner, algorithm, *this, thread);
+        out.emplace_back(miner, *this, thread);
     }
 
     return out;
@@ -125,14 +109,6 @@ void xmrig::CpuConfig::read(const rapidjson::Value &value)
         setPriority(Json::getInt(value,  kPriority, -1));
         setMemoryPool(Json::getValue(value, kMemoryPool));
 
-#       ifdef XMRIG_FEATURE_ASM
-        m_assembly = Json::getValue(value, kAsm);
-#       endif
-
-#       ifdef XMRIG_ALGO_ARGON2
-        m_argon2Impl = Json::getString(value, kArgon2Impl);
-#       endif
-
         m_threads.read(value);
 
         generate();
@@ -150,19 +126,13 @@ void xmrig::CpuConfig::read(const rapidjson::Value &value)
 
 void xmrig::CpuConfig::generate()
 {
-    if (!isEnabled() || m_threads.has("*")) {
+    if (!isEnabled() || m_threads.has()) {
         return;
     }
 
     size_t count = 0;
 
-    count += xmrig::generate<Algorithm::CN>(m_threads, m_limit);
-    count += xmrig::generate<Algorithm::CN_LITE>(m_threads, m_limit);
-    count += xmrig::generate<Algorithm::CN_HEAVY>(m_threads, m_limit);
-    count += xmrig::generate<Algorithm::CN_PICO>(m_threads, m_limit);
-    count += xmrig::generate<Algorithm::RANDOM_X>(m_threads, m_limit);
-    count += xmrig::generate<Algorithm::ARGON2>(m_threads, m_limit);
-
+    count += xmrig::generate(m_threads, m_limit);
     m_shouldSave = count > 0;
 }
 
diff --git a/src/backend/cpu/CpuConfig.h b/src/backend/cpu/CpuConfig.h
index fa48e07..cb7a644 100644
--- a/src/backend/cpu/CpuConfig.h
+++ b/src/backend/cpu/CpuConfig.h
@@ -49,7 +49,7 @@ public:
     bool isHwAES() const;
     rapidjson::Value toJSON(rapidjson::Document &doc) const;
     size_t memPoolSize() const;
-    std::vector<CpuLaunchData> get(const Miner *miner, const Algorithm &algorithm) const;
+    std::vector<CpuLaunchData> get(const Miner *miner) const;
     void read(const rapidjson::Value &value);
 
     inline bool isEnabled() const                       { return m_enabled; }
diff --git a/src/backend/cpu/CpuConfig_gen.h b/src/backend/cpu/CpuConfig_gen.h
index a7319ee..e3bde15 100644
--- a/src/backend/cpu/CpuConfig_gen.h
+++ b/src/backend/cpu/CpuConfig_gen.h
@@ -33,116 +33,11 @@
 
 namespace xmrig {
 
-
-static inline size_t generate(const char *key, Threads<CpuThreads> &threads, const Algorithm &algorithm, uint32_t limit)
+static inline size_t generate(Threads<CpuThreads> &threads, uint32_t limit)
 {
-    if (threads.isExist(algorithm) || threads.has(key)) {
-        return 0;
-    }
-
-    return threads.move(key, Cpu::info()->threads(algorithm, limit));
+    return threads.move("cn/blur", Cpu::info()->threads(limit));
 }
 
-
-template<Algorithm::Family FAMILY>
-static inline size_t generate(Threads<CpuThreads> &, uint32_t) { return 0; }
-
-
-template<>
-size_t inline generate<Algorithm::CN>(Threads<CpuThreads> &threads, uint32_t limit)
-{
-    size_t count = 0;
-
-    count += generate("cn", threads, Algorithm::CN_1, limit);
-
-    if (!threads.isExist(Algorithm::CN_0)) {
-        threads.disable(Algorithm::CN_0);
-        ++count;
-    }
-
-#   ifdef XMRIG_ALGO_CN_GPU
-    count += generate("cn/gpu", threads, Algorithm::CN_GPU, limit);
-#   endif
-
-    return count;
-}
-
-
-#ifdef XMRIG_ALGO_CN_LITE
-template<>
-size_t inline generate<Algorithm::CN_LITE>(Threads<CpuThreads> &threads, uint32_t limit)
-{
-    size_t count = 0;
-
-    count += generate("cn-lite", threads, Algorithm::CN_LITE_1, limit);
-
-    if (!threads.isExist(Algorithm::CN_LITE_0)) {
-        threads.disable(Algorithm::CN_LITE_0);
-        ++count;
-    }
-
-    return count;
-}
-#endif
-
-
-#ifdef XMRIG_ALGO_CN_HEAVY
-template<>
-size_t inline generate<Algorithm::CN_HEAVY>(Threads<CpuThreads> &threads, uint32_t limit)
-{
-    return generate("cn-heavy", threads, Algorithm::CN_HEAVY_0, limit);
-}
-#endif
-
-
-#ifdef XMRIG_ALGO_CN_PICO
-template<>
-size_t inline generate<Algorithm::CN_PICO>(Threads<CpuThreads> &threads, uint32_t limit)
-{
-    return generate("cn-pico", threads, Algorithm::CN_PICO_0, limit);
-}
-#endif
-
-
-#ifdef XMRIG_ALGO_RANDOMX
-template<>
-size_t inline generate<Algorithm::RANDOM_X>(Threads<CpuThreads> &threads, uint32_t limit)
-{
-    size_t count = 0;
-
-    auto wow = Cpu::info()->threads(Algorithm::RX_WOW, limit);
-
-    if (!threads.isExist(Algorithm::RX_ARQ)) {
-        auto arq = Cpu::info()->threads(Algorithm::RX_ARQ, limit);
-        if (arq == wow) {
-            threads.setAlias(Algorithm::RX_ARQ, "rx/wow");
-            ++count;
-        }
-        else {
-            count += threads.move("rx/arq", std::move(arq));
-        }
-    }
-
-    if (!threads.isExist(Algorithm::RX_WOW)) {
-        count += threads.move("rx/wow", std::move(wow));
-    }
-
-    count += generate("rx", threads, Algorithm::RX_0, limit);
-
-    return count;
-}
-#endif
-
-
-#ifdef XMRIG_ALGO_ARGON2
-template<>
-size_t inline generate<Algorithm::ARGON2>(Threads<CpuThreads> &threads, uint32_t limit)
-{
-    return generate("argon2", threads, Algorithm::AR2_CHUKWA, limit);
-}
-#endif
-
-
 } /* namespace xmrig */
 
 
diff --git a/src/backend/cpu/CpuLaunchData.cpp b/src/backend/cpu/CpuLaunchData.cpp
index bbfc6bb..52d4282 100644
--- a/src/backend/cpu/CpuLaunchData.cpp
+++ b/src/backend/cpu/CpuLaunchData.cpp
@@ -28,28 +28,26 @@
 
 #include "backend/common/Tags.h"
 #include "backend/cpu/CpuConfig.h"
-
+#include "crypto/cn/CnAlgo.h"
 
 #include <algorithm>
 
 
-xmrig::CpuLaunchData::CpuLaunchData(const Miner *miner, const Algorithm &algorithm, const CpuConfig &config, const CpuThread &thread) :
-    algorithm(algorithm),
+xmrig::CpuLaunchData::CpuLaunchData(const Miner *miner, const CpuConfig &config, const CpuThread &thread) :
     assembly(config.assembly()),
     hugePages(config.isHugePages()),
     hwAES(config.isHwAES()),
     priority(config.priority()),
     affinity(thread.affinity()),
     miner(miner),
-    intensity(std::min<uint32_t>(thread.intensity(), algorithm.maxIntensity()))
+    intensity(std::min<uint32_t>(thread.intensity(), 5))
 {
 }
 
 
 bool xmrig::CpuLaunchData::isEqual(const CpuLaunchData &other) const
 {
-    return (algorithm.l3()      == other.algorithm.l3()
-            && assembly         == other.assembly
+    return (assembly            == other.assembly
             && hugePages        == other.hugePages
             && hwAES            == other.hwAES
             && intensity        == other.intensity
diff --git a/src/backend/cpu/CpuLaunchData.h b/src/backend/cpu/CpuLaunchData.h
index 5867384..ef21c65 100644
--- a/src/backend/cpu/CpuLaunchData.h
+++ b/src/backend/cpu/CpuLaunchData.h
@@ -44,7 +44,7 @@ class Miner;
 class CpuLaunchData
 {
 public:
-    CpuLaunchData(const Miner *miner, const Algorithm &algorithm, const CpuConfig &config, const CpuThread &thread);
+    CpuLaunchData(const Miner *miner, const CpuConfig &config, const CpuThread &thread);
 
     bool isEqual(const CpuLaunchData &other) const;
     CnHash::AlgoVariant av() const;
@@ -56,7 +56,6 @@ public:
 
     static const char *tag();
 
-    const Algorithm algorithm;
     const Assembly assembly;
     const bool hugePages;
     const bool hwAES;
diff --git a/src/backend/cpu/CpuWorker.cpp b/src/backend/cpu/CpuWorker.cpp
index f64882b..f4f6c54 100644
--- a/src/backend/cpu/CpuWorker.cpp
+++ b/src/backend/cpu/CpuWorker.cpp
@@ -31,17 +31,10 @@
 #include "backend/cpu/CpuWorker.h"
 #include "core/Miner.h"
 #include "crypto/cn/CnCtx.h"
-#include "crypto/cn/CryptoNight_test.h"
 #include "crypto/common/Nonce.h"
 #include "crypto/common/VirtualMemory.h"
-#include "crypto/rx/Rx.h"
-#include "crypto/rx/RxVm.h"
 #include "net/JobResults.h"
-
-
-#ifdef XMRIG_ALGO_RANDOMX
-#   include "crypto/randomx/randomx.h"
-#endif
+#include "backend/common/VarInt.h"
 
 
 namespace xmrig {
@@ -55,116 +48,27 @@ static constexpr uint32_t kReserveCount = 32768;
 template<size_t N>
 xmrig::CpuWorker<N>::CpuWorker(size_t id, const CpuLaunchData &data) :
     Worker(id, data.affinity, data.priority),
-    m_algorithm(data.algorithm),
     m_assembly(data.assembly),
     m_hwAES(data.hwAES),
     m_av(data.av()),
     m_miner(data.miner),
     m_ctx()
 {
-    m_memory = new VirtualMemory(m_algorithm.l3() * N, data.hugePages, true, m_node);
+    m_memory = new VirtualMemory(CnAlgo::CN_MEMORY * N, data.hugePages, true, m_node);
 }
 
 
 template<size_t N>
 xmrig::CpuWorker<N>::~CpuWorker()
 {
-#   ifdef XMRIG_ALGO_RANDOMX
-    delete m_vm;
-#   endif
-
     CnCtx::release(m_ctx, N);
     delete m_memory;
 }
 
-
-#ifdef XMRIG_ALGO_RANDOMX
-template<size_t N>
-void xmrig::CpuWorker<N>::allocateRandomX_VM()
-{
-    RxDataset *dataset = Rx::dataset(m_job.currentJob(), m_node);
-
-    while (dataset == nullptr) {
-        std::this_thread::sleep_for(std::chrono::milliseconds(200));
-
-        if (Nonce::sequence(Nonce::CPU) == 0) {
-            return;
-        }
-
-        dataset = Rx::dataset(m_job.currentJob(), m_node);
-    }
-
-    if (!m_vm) {
-        m_vm = new RxVm(dataset, m_memory->scratchpad(), !m_hwAES);
-    }
-}
-#endif
-
-
 template<size_t N>
 bool xmrig::CpuWorker<N>::selfTest()
 {
-#   ifdef XMRIG_ALGO_RANDOMX
-    if (m_algorithm.family() == Algorithm::RANDOM_X) {
-        return N == 1;
-    }
-#   endif
-
-    allocateCnCtx();
-
-    if (m_algorithm.family() == Algorithm::CN) {
-        const bool rc = verify(Algorithm::CN_0,      test_output_v0)   &&
-                        verify(Algorithm::CN_1,      test_output_v1)   &&
-                        verify(Algorithm::CN_2,      test_output_v2)   &&
-                        verify(Algorithm::CN_FAST,   test_output_msr)  &&
-                        verify(Algorithm::CN_XAO,    test_output_xao)  &&
-                        verify(Algorithm::CN_RTO,    test_output_rto)  &&
-                        verify(Algorithm::CN_HALF,   test_output_half) &&
-                        verify2(Algorithm::CN_R,     test_output_r)    &&
-                        verify(Algorithm::CN_RWZ,    test_output_rwz)  &&
-                        verify(Algorithm::CN_ZLS,    test_output_zls)  &&
-                        verify(Algorithm::CN_DOUBLE, test_output_double);
-
-#       ifdef XMRIG_ALGO_CN_GPU
-        if (!rc || N > 1) {
-            return rc;
-        }
-
-        return verify(Algorithm::CN_GPU, test_output_gpu);
-#       else
-        return rc;
-#       endif
-    }
-
-#   ifdef XMRIG_ALGO_CN_LITE
-    if (m_algorithm.family() == Algorithm::CN_LITE) {
-        return verify(Algorithm::CN_LITE_0,    test_output_v0_lite) &&
-               verify(Algorithm::CN_LITE_1,    test_output_v1_lite);
-    }
-#   endif
-
-#   ifdef XMRIG_ALGO_CN_HEAVY
-    if (m_algorithm.family() == Algorithm::CN_HEAVY) {
-        return verify(Algorithm::CN_HEAVY_0,    test_output_v0_heavy)  &&
-               verify(Algorithm::CN_HEAVY_XHV,  test_output_xhv_heavy) &&
-               verify(Algorithm::CN_HEAVY_TUBE, test_output_tube_heavy);
-    }
-#   endif
-
-#   ifdef XMRIG_ALGO_CN_PICO
-    if (m_algorithm.family() == Algorithm::CN_PICO) {
-        return verify(Algorithm::CN_PICO_0, test_output_pico_trtl);
-    }
-#   endif
-
-#   ifdef XMRIG_ALGO_ARGON2
-    if (m_algorithm.family() == Algorithm::ARGON2) {
-        return verify(Algorithm::AR2_CHUKWA, argon2_chukwa_test_out) &&
-               verify(Algorithm::AR2_WRKZ, argon2_wrkz_test_out);
-    }
-#   endif
-
-    return false;
+    return true;
 }
 
 
@@ -192,19 +96,7 @@ void xmrig::CpuWorker<N>::start()
 
             const Job &job = m_job.currentJob();
 
-            if (job.algorithm().l3() != m_algorithm.l3()) {
-                break;
-            }
-
-#           ifdef XMRIG_ALGO_RANDOMX
-            if (job.algorithm().family() == Algorithm::RANDOM_X) {
-                randomx_calculate_hash(m_vm->get(), m_job.blob(), job.size(), m_hash);
-            }
-            else
-#           endif
-            {
-                fn(job.algorithm())(m_job.blob(), job.size(), m_hash, m_ctx, job.height());
-            }
+            fn()(m_job.blob(), job.size(), m_hash, m_ctx, job.height(), job.extraIters());
 
             for (size_t i = 0; i < N; ++i) {
                 if (*reinterpret_cast<uint64_t*>(m_hash + (i * 32) + 24) < job.target()) {
@@ -222,76 +114,11 @@ void xmrig::CpuWorker<N>::start()
     }
 }
 
-
-template<size_t N>
-bool xmrig::CpuWorker<N>::verify(const Algorithm &algorithm, const uint8_t *referenceValue)
-{
-    cn_hash_fun func = fn(algorithm);
-    if (!func) {
-        return false;
-    }
-
-    func(test_input, 76, m_hash, m_ctx, 0);
-    return memcmp(m_hash, referenceValue, sizeof m_hash) == 0;
-}
-
-
-template<size_t N>
-bool xmrig::CpuWorker<N>::verify2(const Algorithm &algorithm, const uint8_t *referenceValue)
-{
-    cn_hash_fun func = fn(algorithm);
-    if (!func) {
-        return false;
-    }
-
-    for (size_t i = 0; i < (sizeof(cn_r_test_input) / sizeof(cn_r_test_input[0])); ++i) {
-        const size_t size = cn_r_test_input[i].size;
-        for (size_t k = 0; k < N; ++k) {
-            memcpy(m_job.blob() + (k * size), cn_r_test_input[i].data, size);
-        }
-
-        func(m_job.blob(), size, m_hash, m_ctx, cn_r_test_input[i].height);
-
-        for (size_t k = 0; k < N; ++k) {
-            if (memcmp(m_hash + k * 32, referenceValue + i * 32, sizeof m_hash / N) != 0) {
-                return false;
-            }
-        }
-    }
-
-    return true;
-}
-
-
-namespace xmrig {
-
-template<>
-bool CpuWorker<1>::verify2(const Algorithm &algorithm, const uint8_t *referenceValue)
-{
-    cn_hash_fun func = fn(algorithm);
-    if (!func) {
-        return false;
-    }
-
-    for (size_t i = 0; i < (sizeof(cn_r_test_input) / sizeof(cn_r_test_input[0])); ++i) {
-        func(cn_r_test_input[i].data, cn_r_test_input[i].size, m_hash, m_ctx, cn_r_test_input[i].height);
-
-        if (memcmp(m_hash, referenceValue + i * 32, sizeof m_hash) != 0) {
-            return false;
-        }
-    }
-
-    return true;
-}
-
-} // namespace xmrig
-
-
 template<size_t N>
 void xmrig::CpuWorker<N>::allocateCnCtx()
 {
     if (m_ctx[0] == nullptr) {
-        CnCtx::create(m_ctx, m_memory->scratchpad(), m_algorithm.l3(), N);
+        CnCtx::create(m_ctx, m_memory->scratchpad(), CnAlgo::CN_MEMORY, N);
     }
 }
 
@@ -305,15 +132,7 @@ void xmrig::CpuWorker<N>::consumeJob()
 
     m_job.add(m_miner->job(), kReserveCount, Nonce::CPU);
 
-#   ifdef XMRIG_ALGO_RANDOMX
-    if (m_job.currentJob().algorithm().family() == Algorithm::RANDOM_X) {
-        allocateRandomX_VM();
-    }
-    else
-#   endif
-    {
-        allocateCnCtx();
-    }
+    allocateCnCtx();
 }
 
 
@@ -324,6 +143,7 @@ template class CpuWorker<2>;
 template class CpuWorker<3>;
 template class CpuWorker<4>;
 template class CpuWorker<5>;
+template class CpuWorker<6>;
 
 } // namespace xmrig
 
diff --git a/src/backend/cpu/CpuWorker.h b/src/backend/cpu/CpuWorker.h
index 31819de..8ccb268 100644
--- a/src/backend/cpu/CpuWorker.h
+++ b/src/backend/cpu/CpuWorker.h
@@ -57,18 +57,11 @@ protected:
     inline size_t intensity() const override            { return N; }
 
 private:
-    inline cn_hash_fun fn(const Algorithm &algorithm) const { return CnHash::fn(algorithm, m_av, m_assembly); }
+    inline cn_hash_fun fn() const { return CnHash::fn(m_av, m_assembly); }
 
-#   ifdef XMRIG_ALGO_RANDOMX
-    void allocateRandomX_VM();
-#   endif
-
-    bool verify(const Algorithm &algorithm, const uint8_t *referenceValue);
-    bool verify2(const Algorithm &algorithm, const uint8_t *referenceValue);
     void allocateCnCtx();
     void consumeJob();
 
-    const Algorithm m_algorithm;
     const Assembly m_assembly;
     const bool m_hwAES;
     const CnHash::AlgoVariant m_av;
@@ -77,22 +70,14 @@ private:
     uint8_t m_hash[N * 32]{ 0 };
     VirtualMemory *m_memory = nullptr;
     WorkerJob<N> m_job;
-
-#   ifdef XMRIG_ALGO_RANDOMX
-    RxVm *m_vm = nullptr;
-#   endif
 };
 
-
-template<>
-bool CpuWorker<1>::verify2(const Algorithm &algorithm, const uint8_t *referenceValue);
-
-
 extern template class CpuWorker<1>;
 extern template class CpuWorker<2>;
 extern template class CpuWorker<3>;
 extern template class CpuWorker<4>;
 extern template class CpuWorker<5>;
+extern template class CpuWorker<6>;
 
 
 } // namespace xmrig
diff --git a/src/backend/cpu/cpu.cmake b/src/backend/cpu/cpu.cmake
index cb54317..88670a8 100644
--- a/src/backend/cpu/cpu.cmake
+++ b/src/backend/cpu/cpu.cmake
@@ -72,9 +72,5 @@ endif()
 
 
 if (NOT WITH_LIBCPUID)
-    if (XMRIG_ARM)
-        set(SOURCES_CPUID ${SOURCES_CPUID} src/backend/cpu/platform/BasicCpuInfo_arm.cpp)
-    else()
-        set(SOURCES_CPUID ${SOURCES_CPUID} src/backend/cpu/platform/BasicCpuInfo.cpp)
-    endif()
+    set(SOURCES_CPUID ${SOURCES_CPUID} src/backend/cpu/platform/BasicCpuInfo.cpp)
 endif()
diff --git a/src/backend/cpu/interfaces/ICpuInfo.h b/src/backend/cpu/interfaces/ICpuInfo.h
index 20e7239..2f069e2 100644
--- a/src/backend/cpu/interfaces/ICpuInfo.h
+++ b/src/backend/cpu/interfaces/ICpuInfo.h
@@ -50,7 +50,7 @@ public:
     virtual bool hasAVX2() const                                                    = 0;
     virtual const char *backend() const                                             = 0;
     virtual const char *brand() const                                               = 0;
-    virtual CpuThreads threads(const Algorithm &algorithm, uint32_t limit) const    = 0;
+    virtual CpuThreads threads(uint32_t limit) const    = 0;
     virtual size_t cores() const                                                    = 0;
     virtual size_t L2() const                                                       = 0;
     virtual size_t L3() const                                                       = 0;
diff --git a/src/backend/cpu/platform/AdvancedCpuInfo.cpp b/src/backend/cpu/platform/AdvancedCpuInfo.cpp
index 5cae55e..199428f 100644
--- a/src/backend/cpu/platform/AdvancedCpuInfo.cpp
+++ b/src/backend/cpu/platform/AdvancedCpuInfo.cpp
@@ -115,12 +115,6 @@ xmrig::CpuThreads xmrig::AdvancedCpuInfo::threads(const Algorithm &algorithm, ui
         return 1;
     }
 
-#   ifdef XMRIG_ALGO_CN_GPU
-    if (algorithm == Algorithm::CN_GPU) {
-        return CpuThreads(threads());
-    }
-#   endif
-
     size_t cache = 0;
     size_t count = 0;
 
@@ -147,12 +141,6 @@ xmrig::CpuThreads xmrig::AdvancedCpuInfo::threads(const Algorithm &algorithm, ui
 
     uint32_t intensity = algorithm.maxIntensity() == 1 ? 0 : 1;
 
-#   ifdef XMRIG_ALGO_CN_PICO
-    if (algorithm == Algorithm::CN_PICO_0 && (count / cores()) >= 2) {
-        intensity = 2;
-    }
-#   endif
-
     if (limit > 0 && limit < 100) {
         count = std::min(count, static_cast<size_t>(round(threads() * (limit / 100.0))));
     }
diff --git a/src/backend/cpu/platform/BasicCpuInfo.cpp b/src/backend/cpu/platform/BasicCpuInfo.cpp
index db3741e..daa982b 100644
--- a/src/backend/cpu/platform/BasicCpuInfo.cpp
+++ b/src/backend/cpu/platform/BasicCpuInfo.cpp
@@ -22,7 +22,6 @@
  *   along with this program. If not, see <http://www.gnu.org/licenses/>.
  */
 
-#include <algorithm>
 #include <string.h>
 #include <thread>
 
@@ -147,29 +146,6 @@ xmrig::BasicCpuInfo::BasicCpuInfo() :
     m_avx2(has_avx2())
 {
     cpu_brand_string(m_brand);
-
-#   ifdef XMRIG_FEATURE_ASM
-    if (hasAES()) {
-        char vendor[13] = { 0 };
-        int32_t data[4] = { 0 };
-
-        cpuid(VENDOR_ID, data);
-
-        memcpy(vendor + 0, &data[1], 4);
-        memcpy(vendor + 4, &data[3], 4);
-        memcpy(vendor + 8, &data[2], 4);
-
-        if (memcmp(vendor, "AuthenticAMD", 12) == 0) {
-            cpuid(PROCESSOR_INFO, data);
-            const int32_t family = get_masked(data[EAX_Reg], 12, 8) + get_masked(data[EAX_Reg], 28, 20);
-
-            m_assembly = family >= 23 ? Assembly::RYZEN : Assembly::BULLDOZER;
-        }
-        else {
-            m_assembly = Assembly::INTEL;
-        }
-    }
-#   endif
 }
 
 
@@ -179,7 +155,7 @@ const char *xmrig::BasicCpuInfo::backend() const
 }
 
 
-xmrig::CpuThreads xmrig::BasicCpuInfo::threads(const Algorithm &algorithm, uint32_t limit) const
+xmrig::CpuThreads xmrig::BasicCpuInfo::threads(uint32_t limit) const
 {
     const size_t count = std::thread::hardware_concurrency();
 
@@ -187,45 +163,5 @@ xmrig::CpuThreads xmrig::BasicCpuInfo::threads(const Algorithm &algorithm, uint3
         return 1;
     }
 
-#   ifdef XMRIG_ALGO_CN_GPU
-    if (algorithm == Algorithm::CN_GPU) {
-        return count;
-    }
-#   endif
-
-#   ifdef XMRIG_ALGO_CN_LITE
-    if (algorithm.family() == Algorithm::CN_LITE) {
-        return CpuThreads(count, 1);
-    }
-#   endif
-
-#   ifdef XMRIG_ALGO_CN_PICO
-    if (algorithm.family() == Algorithm::CN_PICO) {
-        return CpuThreads(count, 2);
-    }
-#   endif
-
-#   ifdef XMRIG_ALGO_CN_HEAVY
-    if (algorithm.family() == Algorithm::CN_HEAVY) {
-        return CpuThreads(std::max<size_t>(count / 4, 1), 1);
-    }
-#   endif
-
-#   ifdef XMRIG_ALGO_RANDOMX
-    if (algorithm.family() == Algorithm::RANDOM_X) {
-        if (algorithm == Algorithm::RX_WOW) {
-            return count;
-        }
-
-        return std::max<size_t>(count / 2, 1);
-    }
-#   endif
-
-#   ifdef XMRIG_ALGO_ARGON2
-    if (algorithm.family() == Algorithm::ARGON2) {
-        return count;
-    }
-#   endif
-
     return CpuThreads(std::max<size_t>(count / 2, 1), 1);
 }
diff --git a/src/backend/cpu/platform/BasicCpuInfo.h b/src/backend/cpu/platform/BasicCpuInfo.h
index 4c68c5f..b8c5775 100644
--- a/src/backend/cpu/platform/BasicCpuInfo.h
+++ b/src/backend/cpu/platform/BasicCpuInfo.h
@@ -39,7 +39,7 @@ public:
 
 protected:
     const char *backend() const override;
-    CpuThreads threads(const Algorithm &algorithm, uint32_t limit) const override;
+    CpuThreads threads(uint32_t limit) const override;
 
     inline Assembly::Id assembly() const override   { return m_assembly; }
     inline bool hasAES() const override             { return m_aes; }
diff --git a/src/backend/cpu/platform/HwlocCpuInfo.cpp b/src/backend/cpu/platform/HwlocCpuInfo.cpp
index 3983e8b..d12fb4e 100644
--- a/src/backend/cpu/platform/HwlocCpuInfo.cpp
+++ b/src/backend/cpu/platform/HwlocCpuInfo.cpp
@@ -41,6 +41,7 @@
 
 #include "backend/cpu/platform/HwlocCpuInfo.h"
 #include "base/io/log/Log.h"
+#include "crypto/cn/CnAlgo.h"
 
 
 namespace xmrig {
@@ -214,10 +215,10 @@ bool xmrig::HwlocCpuInfo::membind(hwloc_const_bitmap_t nodeset)
 }
 
 
-xmrig::CpuThreads xmrig::HwlocCpuInfo::threads(const Algorithm &algorithm, uint32_t limit) const
+xmrig::CpuThreads xmrig::HwlocCpuInfo::threads(uint32_t limit) const
 {
     if (L2() == 0 && L3() == 0) {
-        return BasicCpuInfo::threads(algorithm, limit);
+        return BasicCpuInfo::threads(limit);
     }
 
     const unsigned depth = L3() > 0 ? 3 : 2;
@@ -236,7 +237,7 @@ xmrig::CpuThreads xmrig::HwlocCpuInfo::threads(const Algorithm &algorithm, uint3
         int remaining                = std::max(static_cast<int>(maxTotalThreads), 1);
 
         for (hwloc_obj_t cache : caches) {
-            processTopLevelCache(cache, algorithm, threads, std::min(maxPerCache, remaining));
+            processTopLevelCache(cache, threads, std::min(maxPerCache, remaining));
 
             remaining -= maxPerCache;
             if (remaining <= 0) {
@@ -246,21 +247,21 @@ xmrig::CpuThreads xmrig::HwlocCpuInfo::threads(const Algorithm &algorithm, uint3
     }
     else {
         for (hwloc_obj_t cache : caches) {
-            processTopLevelCache(cache, algorithm, threads, 0);
+            processTopLevelCache(cache, threads, 0);
         }
     }
 
     if (threads.isEmpty()) {
-        LOG_WARN("hwloc auto configuration for algorithm \"%s\" failed.", algorithm.shortName());
+        LOG_WARN("hwloc auto configuration failed.");
 
-        return BasicCpuInfo::threads(algorithm, limit);
+        return BasicCpuInfo::threads(limit);
     }
 
     return threads;
 }
 
 
-void xmrig::HwlocCpuInfo::processTopLevelCache(hwloc_obj_t cache, const Algorithm &algorithm, CpuThreads &threads, size_t limit) const
+void xmrig::HwlocCpuInfo::processTopLevelCache(hwloc_obj_t cache, CpuThreads &threads, size_t limit) const
 {
     constexpr size_t oneMiB = 1024u * 1024u;
 
@@ -278,8 +279,8 @@ void xmrig::HwlocCpuInfo::processTopLevelCache(hwloc_obj_t cache, const Algorith
     size_t L2               = 0;
     int L2_associativity    = 0;
     size_t extra            = 0;
-    const size_t scratchpad = algorithm.l3();
-    uint32_t intensity      = algorithm.maxIntensity() == 1 ? 0 : 1;
+    const size_t scratchpad = xmrig::CnAlgo::CN_MEMORY;
+    uint32_t intensity      = xmrig::CnAlgo::CN_MAX_INTENSITY == 1 ? 0 : 1;
 
     if (cache->attr->cache.depth == 3) {
         for (size_t i = 0; i < cache->arity; ++i) {
@@ -306,24 +307,6 @@ void xmrig::HwlocCpuInfo::processTopLevelCache(hwloc_obj_t cache, const Algorith
 
     size_t cacheHashes = ((L3 + extra) + (scratchpad / 2)) / scratchpad;
 
-#   ifdef XMRIG_ALGO_CN_PICO
-    if (algorithm == Algorithm::CN_PICO_0 && (cacheHashes / PUs) >= 2) {
-        intensity = 2;
-    }
-#   endif
-
-#   ifdef XMRIG_ALGO_CN_GPU
-    if (algorithm == Algorithm::CN_GPU) {
-        cacheHashes = PUs;
-    }
-#   endif
-
-#   ifdef XMRIG_ALGO_RANDOMX
-    if (extra == 0 && algorithm.l2() > 0) {
-        cacheHashes = std::min<size_t>(std::max<size_t>(L2 / algorithm.l2(), cores.size()), cacheHashes);
-    }
-#   endif
-
     if (limit > 0) {
         cacheHashes = std::min(cacheHashes, limit);
     }
diff --git a/src/backend/cpu/platform/HwlocCpuInfo.h b/src/backend/cpu/platform/HwlocCpuInfo.h
index c22291e..8cfb76d 100644
--- a/src/backend/cpu/platform/HwlocCpuInfo.h
+++ b/src/backend/cpu/platform/HwlocCpuInfo.h
@@ -60,7 +60,7 @@ public:
     bool membind(hwloc_const_bitmap_t nodeset);
 
 protected:
-    CpuThreads threads(const Algorithm &algorithm, uint32_t limit) const override;
+    CpuThreads threads(uint32_t limit) const override;
 
     inline const char *backend() const override     { return m_backend; }
     inline size_t cores() const override            { return m_cores; }
@@ -70,7 +70,7 @@ protected:
     inline size_t packages() const override         { return m_packages; }
 
 private:
-    void processTopLevelCache(hwloc_obj_t obj, const Algorithm &algorithm, CpuThreads &threads, size_t limit) const;
+    void processTopLevelCache(hwloc_obj_t obj, CpuThreads &threads, size_t limit) const;
 
 
     static uint32_t m_features;
diff --git a/src/backend/cuda/CudaBackend.cpp b/src/backend/cuda/CudaBackend.cpp
index b351df7..d7d51e3 100644
--- a/src/backend/cuda/CudaBackend.cpp
+++ b/src/backend/cuda/CudaBackend.cpp
@@ -202,14 +202,6 @@ public:
 
     inline void start(const Job &)
     {
-        LOG_INFO("%s use profile " BLUE_BG(WHITE_BOLD_S " %s ") WHITE_BOLD_S " (" CYAN_BOLD("%zu") WHITE_BOLD(" thread%s)") " scratchpad " CYAN_BOLD("%zu KB"),
-                 tag,
-                 profileName.data(),
-                 threads.size(),
-                 threads.size() > 1 ? "s" : "",
-                 algo.l3() / 1024
-                 );
-
         Log::print(WHITE_BOLD("|  # | GPU |  BUS ID |    I |   T |   B | BF |  BS |  MEM | NAME"));
 
         size_t i = 0;
@@ -224,7 +216,7 @@ public:
                        data.thread.blocks(),
                        data.thread.bfactor(),
                        data.thread.bsleep(),
-                       (data.thread.threads() * data.thread.blocks()) * algo.l3() / oneMiB,
+                       (data.thread.threads() * data.thread.blocks()) * CnAlgo::CN_MEMORY / oneMiB,
                        data.device.name().data()
                        );
 
@@ -267,13 +259,10 @@ public:
     }
 #   endif
 
-
-    Algorithm algo;
     Controller *controller;
     CudaLaunchStatus status;
     std::vector<CudaDevice> devices;
     std::vector<CudaLaunchData> threads;
-    String profileName;
     uint32_t driverVersion      = 0;
     uint32_t runtimeVersion     = 0;
     Workers<CudaLaunchData> workers;
@@ -316,7 +305,7 @@ bool xmrig::CudaBackend::isEnabled() const
 
 bool xmrig::CudaBackend::isEnabled(const Algorithm &algorithm) const
 {
-    return !d_ptr->controller->config()->cuda().threads().get(algorithm).isEmpty();
+    return !d_ptr->controller->config()->cuda().threads().get().isEmpty();
 }
 
 
@@ -325,13 +314,6 @@ const xmrig::Hashrate *xmrig::CudaBackend::hashrate() const
     return d_ptr->workers.hashrate();
 }
 
-
-const xmrig::String &xmrig::CudaBackend::profileName() const
-{
-    return d_ptr->profileName;
-}
-
-
 const xmrig::String &xmrig::CudaBackend::type() const
 {
     return kType;
@@ -398,15 +380,12 @@ void xmrig::CudaBackend::setJob(const Job &job)
         return stop();
     }
 
-    auto threads = cuda.get(d_ptr->controller->miner(), job.algorithm(), d_ptr->devices);
+    auto threads = cuda.get(d_ptr->controller->miner(), d_ptr->devices);
     if (!d_ptr->threads.empty() && d_ptr->threads.size() == threads.size() && std::equal(d_ptr->threads.begin(), d_ptr->threads.end(), threads.begin())) {
         return;
     }
 
-    d_ptr->algo         = job.algorithm();
-    d_ptr->profileName  = cuda.threads().profileName(job.algorithm());
-
-    if (d_ptr->profileName.isNull() || threads.empty()) {
+    if (threads.empty()) {
         LOG_WARN("%s " RED_BOLD("disabled") YELLOW(" (no suitable configuration found)"), tag);
 
         return stop();
@@ -474,8 +453,6 @@ rapidjson::Value xmrig::CudaBackend::toJSON(rapidjson::Document &doc) const
     Value out(kObjectType);
     out.AddMember("type",       type().toJSON(), allocator);
     out.AddMember("enabled",    isEnabled(), allocator);
-    out.AddMember("algo",       d_ptr->algo.toJSON(), allocator);
-    out.AddMember("profile",    profileName().toJSON(), allocator);
 
     if (CudaLib::isReady()) {
         Value versions(kObjectType);
diff --git a/src/backend/cuda/CudaBackend.h b/src/backend/cuda/CudaBackend.h
index cf0bb62..c9df66a 100644
--- a/src/backend/cuda/CudaBackend.h
+++ b/src/backend/cuda/CudaBackend.h
@@ -54,7 +54,6 @@ protected:
     bool isEnabled() const override;
     bool isEnabled(const Algorithm &algorithm) const override;
     const Hashrate *hashrate() const override;
-    const String &profileName() const override;
     const String &type() const override;
     void execCommand(char command) override;
     void prepare(const Job &nextJob) override;
diff --git a/src/backend/cuda/CudaConfig.cpp b/src/backend/cuda/CudaConfig.cpp
index 8f26c14..f308ece 100644
--- a/src/backend/cuda/CudaConfig.cpp
+++ b/src/backend/cuda/CudaConfig.cpp
@@ -76,7 +76,7 @@ rapidjson::Value xmrig::CudaConfig::toJSON(rapidjson::Document &doc) const
 }
 
 
-std::vector<xmrig::CudaLaunchData> xmrig::CudaConfig::get(const Miner *miner, const Algorithm &algorithm, const std::vector<CudaDevice> &devices) const
+std::vector<xmrig::CudaLaunchData> xmrig::CudaConfig::get(const Miner *miner, const std::vector<CudaDevice> &devices) const
 {
     auto deviceIndex = [&devices](uint32_t index) -> int {
         for (uint32_t i = 0; i < devices.size(); ++i) {
@@ -89,7 +89,7 @@ std::vector<xmrig::CudaLaunchData> xmrig::CudaConfig::get(const Miner *miner, co
     };
 
     std::vector<CudaLaunchData> out;
-    const auto &threads = m_threads.get(algorithm);
+    const auto &threads = m_threads.get();
 
     if (threads.isEmpty()) {
         return out;
@@ -104,7 +104,7 @@ std::vector<xmrig::CudaLaunchData> xmrig::CudaConfig::get(const Miner *miner, co
             continue;
         }
 
-        out.emplace_back(miner, algorithm, thread, devices[static_cast<size_t>(index)]);
+        out.emplace_back(miner, thread, devices[static_cast<size_t>(index)]);
     }
 
     return out;
@@ -152,7 +152,7 @@ void xmrig::CudaConfig::generate()
         return;
     }
 
-    if (!isEnabled() || m_threads.has("*")) {
+    if (!isEnabled() || m_threads.has()) {
         return;
     }
 
@@ -170,12 +170,7 @@ void xmrig::CudaConfig::generate()
     }
 
     size_t count = 0;
-
-    count += xmrig::generate<Algorithm::CN>(m_threads, devices);
-    count += xmrig::generate<Algorithm::CN_LITE>(m_threads, devices);
-    count += xmrig::generate<Algorithm::CN_HEAVY>(m_threads, devices);
-    count += xmrig::generate<Algorithm::CN_PICO>(m_threads, devices);
-    count += xmrig::generate<Algorithm::RANDOM_X>(m_threads, devices);
+    count += xmrig::generate(m_threads, devices);
 
     generated    = true;
     m_shouldSave = count > 0;
diff --git a/src/backend/cuda/CudaConfig.h b/src/backend/cuda/CudaConfig.h
index 3f3957e..ae3ca5f 100644
--- a/src/backend/cuda/CudaConfig.h
+++ b/src/backend/cuda/CudaConfig.h
@@ -40,7 +40,7 @@ public:
     CudaConfig() = default;
 
     rapidjson::Value toJSON(rapidjson::Document &doc) const;
-    std::vector<CudaLaunchData> get(const Miner *miner, const Algorithm &algorithm, const std::vector<CudaDevice> &devices) const;
+    std::vector<CudaLaunchData> get(const Miner *miner, const std::vector<CudaDevice> &devices) const;
     void read(const rapidjson::Value &value);
 
     inline bool isEnabled() const                               { return m_enabled; }
diff --git a/src/backend/cuda/CudaConfig_gen.h b/src/backend/cuda/CudaConfig_gen.h
index 87e35dc..db254c6 100644
--- a/src/backend/cuda/CudaConfig_gen.h
+++ b/src/backend/cuda/CudaConfig_gen.h
@@ -25,111 +25,16 @@
 #ifndef XMRIG_CUDACONFIG_GEN_H
 #define XMRIG_CUDACONFIG_GEN_H
 
-
 #include "backend/common/Threads.h"
 #include "backend/cuda/CudaThreads.h"
 #include "backend/cuda/wrappers/CudaDevice.h"
 
-
-#include <algorithm>
-
-
 namespace xmrig {
 
-
-static inline size_t generate(const char *key, Threads<CudaThreads> &threads, const Algorithm &algorithm, const std::vector<CudaDevice> &devices)
-{
-    if (threads.isExist(algorithm) || threads.has(key)) {
-        return 0;
-    }
-
-    return threads.move(key, CudaThreads(devices, algorithm));
-}
-
-
-template<Algorithm::Family FAMILY>
-static inline size_t generate(Threads<CudaThreads> &, const std::vector<CudaDevice> &) { return 0; }
-
-
-template<>
-size_t inline generate<Algorithm::CN>(Threads<CudaThreads> &threads, const std::vector<CudaDevice> &devices)
-{
-    size_t count = 0;
-
-    count += generate("cn", threads, Algorithm::CN_1, devices);
-    count += generate("cn/2", threads, Algorithm::CN_2, devices);
-
-    if (!threads.isExist(Algorithm::CN_0)) {
-        threads.disable(Algorithm::CN_0);
-        count++;
-    }
-
-#   ifdef XMRIG_ALGO_CN_GPU
-    count += generate("cn/gpu", threads, Algorithm::CN_GPU, devices);
-#   endif
-
-    return count;
-}
-
-
-#ifdef XMRIG_ALGO_CN_LITE
-template<>
-size_t inline generate<Algorithm::CN_LITE>(Threads<CudaThreads> &threads, const std::vector<CudaDevice> &devices)
+static inline size_t generate(Threads<CudaThreads> &threads, const std::vector<CudaDevice> &devices)
 {
-    size_t count = generate("cn-lite", threads, Algorithm::CN_LITE_1, devices);
-
-    if (!threads.isExist(Algorithm::CN_LITE_0)) {
-        threads.disable(Algorithm::CN_LITE_0);
-        ++count;
-    }
-
-    return count;
-}
-#endif
-
-
-#ifdef XMRIG_ALGO_CN_HEAVY
-template<>
-size_t inline generate<Algorithm::CN_HEAVY>(Threads<CudaThreads> &threads, const std::vector<CudaDevice> &devices)
-{
-    return generate("cn-heavy", threads, Algorithm::CN_HEAVY_0, devices);
-}
-#endif
-
-
-#ifdef XMRIG_ALGO_CN_PICO
-template<>
-size_t inline generate<Algorithm::CN_PICO>(Threads<CudaThreads> &threads, const std::vector<CudaDevice> &devices)
-{
-    return generate("cn-pico", threads, Algorithm::CN_PICO_0, devices);
+    return threads.move("cn/blur", CudaThreads(devices));
 }
-#endif
-
-
-#ifdef XMRIG_ALGO_RANDOMX
-template<>
-size_t inline generate<Algorithm::RANDOM_X>(Threads<CudaThreads> &threads, const std::vector<CudaDevice> &devices)
-{
-    size_t count = 0;
-
-    auto rx  = CudaThreads(devices, Algorithm::RX_0);
-    auto wow = CudaThreads(devices, Algorithm::RX_WOW);
-    auto arq = CudaThreads(devices, Algorithm::RX_ARQ);
-
-    if (!threads.isExist(Algorithm::RX_WOW) && wow != rx) {
-        count += threads.move("rx/wow", std::move(wow));
-    }
-
-    if (!threads.isExist(Algorithm::RX_ARQ) && arq != rx) {
-        count += threads.move("rx/arq", std::move(arq));
-    }
-
-    count += threads.move("rx", std::move(rx));
-
-    return count;
-}
-#endif
-
 
 } /* namespace xmrig */
 
diff --git a/src/backend/cuda/CudaLaunchData.cpp b/src/backend/cuda/CudaLaunchData.cpp
index 11cf70c..726a908 100644
--- a/src/backend/cuda/CudaLaunchData.cpp
+++ b/src/backend/cuda/CudaLaunchData.cpp
@@ -28,8 +28,7 @@
 #include "backend/common/Tags.h"
 
 
-xmrig::CudaLaunchData::CudaLaunchData(const Miner *miner, const Algorithm &algorithm, const CudaThread &thread, const CudaDevice &device) :
-    algorithm(algorithm),
+xmrig::CudaLaunchData::CudaLaunchData(const Miner *miner, const CudaThread &thread, const CudaDevice &device) :
     miner(miner),
     device(device),
     thread(thread)
@@ -39,9 +38,7 @@ xmrig::CudaLaunchData::CudaLaunchData(const Miner *miner, const Algorithm &algor
 
 bool xmrig::CudaLaunchData::isEqual(const CudaLaunchData &other) const
 {
-    return (other.algorithm.family() == algorithm.family() &&
-            other.algorithm.l3()     == algorithm.l3() &&
-            other.thread             == thread);
+    return (other.thread == thread);
 }
 
 
diff --git a/src/backend/cuda/CudaLaunchData.h b/src/backend/cuda/CudaLaunchData.h
index 33173ff..4708569 100644
--- a/src/backend/cuda/CudaLaunchData.h
+++ b/src/backend/cuda/CudaLaunchData.h
@@ -42,7 +42,7 @@ class Miner;
 class CudaLaunchData
 {
 public:
-    CudaLaunchData(const Miner *miner, const Algorithm &algorithm, const CudaThread &thread, const CudaDevice &device);
+    CudaLaunchData(const Miner *miner, const CudaThread &thread, const CudaDevice &device);
 
     bool isEqual(const CudaLaunchData &other) const;
 
@@ -53,7 +53,6 @@ public:
 
     static const char *tag();
 
-    const Algorithm algorithm;
     const Miner *miner;
     const CudaDevice &device;
     const CudaThread thread;
diff --git a/src/backend/cuda/CudaThread.cpp b/src/backend/cuda/CudaThread.cpp
index d98989a..88321d8 100644
--- a/src/backend/cuda/CudaThread.cpp
+++ b/src/backend/cuda/CudaThread.cpp
@@ -40,7 +40,6 @@ static const char *kBlocks      = "blocks";
 static const char *kBSleep      = "bsleep";
 static const char *kIndex       = "index";
 static const char *kThreads     = "threads";
-static const char *kDatasetHost = "dataset_host";
 
 } // namespace xmrig
 
@@ -57,19 +56,11 @@ xmrig::CudaThread::CudaThread(const rapidjson::Value &value)
     m_bfactor   = std::min(Json::getUint(value, kBFactor, m_bfactor), 12u);
     m_bsleep    = Json::getUint(value, kBSleep, m_bsleep);
     m_affinity  = Json::getUint64(value, kAffinity, m_affinity);
-
-    if (Json::getValue(value, kDatasetHost).IsInt()) {
-        m_datasetHost = Json::getInt(value, kDatasetHost, m_datasetHost) != 0;
-    }
-    else {
-        m_datasetHost = Json::getBool(value, kDatasetHost);
-    }
 }
 
 
 xmrig::CudaThread::CudaThread(uint32_t index, nvid_ctx *ctx) :
     m_blocks(CudaLib::deviceInt(ctx, CudaLib::DeviceBlocks)),
-    m_datasetHost(CudaLib::deviceInt(ctx, CudaLib::DeviceDatasetHost)),
     m_threads(CudaLib::deviceInt(ctx, CudaLib::DeviceThreads)),
     m_index(index),
     m_bfactor(CudaLib::deviceUint(ctx, CudaLib::DeviceBFactor)),
@@ -86,8 +77,7 @@ bool xmrig::CudaThread::isEqual(const CudaThread &other) const
            m_affinity    == other.m_affinity &&
            m_index       == other.m_index &&
            m_bfactor     == other.m_bfactor &&
-           m_bsleep      == other.m_bsleep &&
-           m_datasetHost == other.m_datasetHost;
+           m_bsleep      == other.m_bsleep;
 }
 
 
@@ -105,9 +95,5 @@ rapidjson::Value xmrig::CudaThread::toJSON(rapidjson::Document &doc) const
     out.AddMember(StringRef(kBSleep),       bsleep(), allocator);
     out.AddMember(StringRef(kAffinity),     affinity(), allocator);
 
-    if (m_datasetHost >= 0) {
-        out.AddMember(StringRef(kDatasetHost), m_datasetHost > 0, allocator);
-    }
-
     return out;
 }
diff --git a/src/backend/cuda/CudaThread.h b/src/backend/cuda/CudaThread.h
index 8943ac2..78ae524 100644
--- a/src/backend/cuda/CudaThread.h
+++ b/src/backend/cuda/CudaThread.h
@@ -47,7 +47,6 @@ public:
     inline int32_t bfactor() const                           { return static_cast<int32_t>(m_bfactor); }
     inline int32_t blocks() const                            { return m_blocks; }
     inline int32_t bsleep() const                            { return static_cast<int32_t>(m_bsleep); }
-    inline int32_t datasetHost() const                       { return m_datasetHost; }
     inline int32_t threads() const                           { return m_threads; }
     inline int64_t affinity() const                          { return m_affinity; }
     inline uint32_t index() const                            { return m_index; }
@@ -60,7 +59,6 @@ public:
 
 private:
     int32_t m_blocks        = 0;
-    int32_t m_datasetHost   = -1;
     int32_t m_threads       = 0;
     int64_t m_affinity      = -1;
     uint32_t m_index        = 0;
diff --git a/src/backend/cuda/CudaThreads.cpp b/src/backend/cuda/CudaThreads.cpp
index 5ff4cb2..4f471c5 100644
--- a/src/backend/cuda/CudaThreads.cpp
+++ b/src/backend/cuda/CudaThreads.cpp
@@ -44,10 +44,10 @@ xmrig::CudaThreads::CudaThreads(const rapidjson::Value &value)
 }
 
 
-xmrig::CudaThreads::CudaThreads(const std::vector<CudaDevice> &devices, const Algorithm &algorithm)
+xmrig::CudaThreads::CudaThreads(const std::vector<CudaDevice> &devices)
 {
     for (const auto &device : devices) {
-        device.generate(algorithm, *this);
+        device.generate(*this);
     }
 }
 
diff --git a/src/backend/cuda/CudaThreads.h b/src/backend/cuda/CudaThreads.h
index 5f174d8..00925e3 100644
--- a/src/backend/cuda/CudaThreads.h
+++ b/src/backend/cuda/CudaThreads.h
@@ -32,16 +32,14 @@
 #include "backend/cuda/CudaThread.h"
 #include "backend/cuda/wrappers/CudaDevice.h"
 
-
 namespace xmrig {
 
-
 class CudaThreads
 {
 public:
     CudaThreads() = default;
     CudaThreads(const rapidjson::Value &value);
-    CudaThreads(const std::vector<CudaDevice> &devices, const Algorithm &algorithm);
+    CudaThreads(const std::vector<CudaDevice> &devices);
 
     inline bool isEmpty() const                              { return m_data.empty(); }
     inline const std::vector<CudaThread> &data() const       { return m_data; }
diff --git a/src/backend/cuda/CudaWorker.cpp b/src/backend/cuda/CudaWorker.cpp
index b280e29..f072f20 100644
--- a/src/backend/cuda/CudaWorker.cpp
+++ b/src/backend/cuda/CudaWorker.cpp
@@ -33,12 +33,6 @@
 #include "crypto/common/Nonce.h"
 #include "net/JobResults.h"
 
-
-#ifdef XMRIG_ALGO_RANDOMX
-#   include "backend/cuda/runners/CudaRxRunner.h"
-#endif
-
-
 #include <cassert>
 #include <thread>
 
@@ -60,23 +54,9 @@ static inline uint32_t roundSize(uint32_t intensity) { return kReserveCount / in
 
 xmrig::CudaWorker::CudaWorker(size_t id, const CudaLaunchData &data) :
     Worker(id, data.thread.affinity(), -1),
-    m_algorithm(data.algorithm),
     m_miner(data.miner)
 {
-    switch (m_algorithm.family()) {
-    case Algorithm::RANDOM_X:
-#       ifdef XMRIG_ALGO_RANDOMX
-        m_runner = new CudaRxRunner(id, data);
-#       endif
-        break;
-
-    case Algorithm::ARGON2:
-        break;
-
-    default:
-        m_runner = new CudaCnRunner(id, data);
-        break;
-    }
+    m_runner = new CudaCnRunner(id, data);
 
     if (!m_runner || !m_runner->init()) {
         return;
diff --git a/src/backend/cuda/CudaWorker.h b/src/backend/cuda/CudaWorker.h
index f717ca5..cf9eccf 100644
--- a/src/backend/cuda/CudaWorker.h
+++ b/src/backend/cuda/CudaWorker.h
@@ -60,7 +60,6 @@ private:
     bool consumeJob();
     void storeStats();
 
-    const Algorithm m_algorithm;
     const Miner *m_miner;
     ICudaRunner *m_runner = nullptr;
     WorkerJob<1> m_job;
diff --git a/src/backend/cuda/cuda.cmake b/src/backend/cuda/cuda.cmake
index 58ba3f5..be3df5b 100644
--- a/src/backend/cuda/cuda.cmake
+++ b/src/backend/cuda/cuda.cmake
@@ -12,7 +12,6 @@ if (WITH_CUDA)
         src/backend/cuda/interfaces/ICudaRunner.h
         src/backend/cuda/runners/CudaBaseRunner.h
         src/backend/cuda/runners/CudaCnRunner.h
-        src/backend/cuda/runners/CudaRxRunner.h
         src/backend/cuda/wrappers/CudaDevice.h
         src/backend/cuda/wrappers/CudaLib.h
        )
@@ -26,7 +25,6 @@ if (WITH_CUDA)
         src/backend/cuda/CudaWorker.cpp
         src/backend/cuda/runners/CudaBaseRunner.cpp
         src/backend/cuda/runners/CudaCnRunner.cpp
-        src/backend/cuda/runners/CudaRxRunner.cpp
         src/backend/cuda/wrappers/CudaDevice.cpp
         src/backend/cuda/wrappers/CudaLib.cpp
        )
diff --git a/src/backend/cuda/runners/CudaBaseRunner.cpp b/src/backend/cuda/runners/CudaBaseRunner.cpp
index 757f91d..b75d5c6 100644
--- a/src/backend/cuda/runners/CudaBaseRunner.cpp
+++ b/src/backend/cuda/runners/CudaBaseRunner.cpp
@@ -29,6 +29,7 @@
 #include "backend/common/Tags.h"
 #include "base/io/log/Log.h"
 #include "base/net/stratum/Job.h"
+#include "backend/common/VarInt.h"
 
 
 xmrig::CudaBaseRunner::CudaBaseRunner(size_t id, const CudaLaunchData &data) :
@@ -47,7 +48,7 @@ xmrig::CudaBaseRunner::~CudaBaseRunner()
 bool xmrig::CudaBaseRunner::init()
 {
     m_ctx = CudaLib::alloc(m_data.thread.index(), m_data.thread.bfactor(), m_data.thread.bsleep());
-    if (CudaLib::deviceInfo(m_ctx, m_data.thread.blocks(), m_data.thread.threads(), m_data.algorithm, m_data.thread.datasetHost()) != 0) {
+    if (CudaLib::deviceInfo(m_ctx, m_data.thread.blocks(), m_data.thread.threads())) {
         return false;
     }
 
@@ -60,7 +61,7 @@ bool xmrig::CudaBaseRunner::set(const Job &job, uint8_t *blob)
     m_height = job.height();
     m_target = job.target();
 
-    return callWrapper(CudaLib::setJob(m_ctx, blob, job.size(), job.algorithm()));
+    return callWrapper(CudaLib::setJob(m_ctx, blob, job.size(), job.extraIters()));
 }
 
 
diff --git a/src/backend/cuda/wrappers/CudaDevice.cpp b/src/backend/cuda/wrappers/CudaDevice.cpp
index efacc80..9e7adc7 100644
--- a/src/backend/cuda/wrappers/CudaDevice.cpp
+++ b/src/backend/cuda/wrappers/CudaDevice.cpp
@@ -27,7 +27,6 @@
 #include "backend/cuda/CudaThreads.h"
 #include "backend/cuda/wrappers/CudaLib.h"
 #include "base/io/log/Log.h"
-#include "crypto/common/Algorithm.h"
 #include "rapidjson/document.h"
 
 #ifdef XMRIG_FEATURE_NVML
@@ -41,7 +40,7 @@ xmrig::CudaDevice::CudaDevice(uint32_t index, int32_t bfactor, int32_t bsleep) :
     m_index(index)
 {
     auto ctx = CudaLib::alloc(index, bfactor, bsleep);
-    if (CudaLib::deviceInfo(ctx, 0, 0, Algorithm::INVALID) != 0) {
+    if (CudaLib::deviceInfo(ctx, 0, 0) != 0) {
         CudaLib::release(ctx);
 
         return;
@@ -105,9 +104,9 @@ uint32_t xmrig::CudaDevice::smx() const
 }
 
 
-void xmrig::CudaDevice::generate(const Algorithm &algorithm, CudaThreads &threads) const
+void xmrig::CudaDevice::generate(CudaThreads &threads) const
 {
-    if (CudaLib::deviceInfo(m_ctx, -1, -1, algorithm) != 0) {
+    if (CudaLib::deviceInfo(m_ctx, -1, -1) != 0) {
         return;
     }
 
diff --git a/src/backend/cuda/wrappers/CudaDevice.h b/src/backend/cuda/wrappers/CudaDevice.h
index 8c624c8..a6ede19 100644
--- a/src/backend/cuda/wrappers/CudaDevice.h
+++ b/src/backend/cuda/wrappers/CudaDevice.h
@@ -36,8 +36,6 @@ using nvmlDevice_t  = struct nvmlDevice_st *;
 
 namespace xmrig {
 
-
-class Algorithm;
 class CudaThreads;
 
 
@@ -56,7 +54,7 @@ public:
     uint32_t computeCapability(bool major = true) const;
     uint32_t memoryClock() const;
     uint32_t smx() const;
-    void generate(const Algorithm &algorithm, CudaThreads &threads) const;
+    void generate(CudaThreads &threads) const;
 
     inline bool isValid() const                     { return m_ctx != nullptr; }
     inline const PciTopology &topology() const      { return m_topology; }
diff --git a/src/backend/cuda/wrappers/CudaLib.cpp b/src/backend/cuda/wrappers/CudaLib.cpp
index 3792445..c10e6f7 100644
--- a/src/backend/cuda/wrappers/CudaLib.cpp
+++ b/src/backend/cuda/wrappers/CudaLib.cpp
@@ -57,8 +57,6 @@ static const char *kInit                                = "init";
 static const char *kLastError                           = "lastError";
 static const char *kPluginVersion                       = "pluginVersion";
 static const char *kRelease                             = "release";
-static const char *kRxHash                              = "rxHash";
-static const char *kRxPrepare                           = "rxPrepare";
 static const char *kSetJob                              = "setJob";
 static const char *kSymbolNotFound                      = "symbol not found";
 static const char *kVersion                             = "version";
@@ -67,7 +65,7 @@ static const char *kVersion                             = "version";
 using alloc_t                                           = nvid_ctx * (*)(uint32_t, int32_t, int32_t);
 using cnHash_t                                          = bool (*)(nvid_ctx *, uint32_t, uint64_t, uint64_t, uint32_t *, uint32_t *);
 using deviceCount_t                                     = uint32_t (*)();
-using deviceInfo_t                                      = int32_t (*)(nvid_ctx *, int32_t, int32_t, int32_t, int32_t);
+using deviceInfo_t                                      = int32_t (*)(nvid_ctx *, int32_t, int32_t);
 using deviceInit_t                                      = bool (*)(nvid_ctx *);
 using deviceInt_t                                       = int32_t (*)(nvid_ctx *, CudaLib::DeviceProperty);
 using deviceName_t                                      = const char * (*)(nvid_ctx *);
@@ -77,9 +75,7 @@ using init_t                                            = void (*)();
 using lastError_t                                       = const char * (*)(nvid_ctx *);
 using pluginVersion_t                                   = const char * (*)();
 using release_t                                         = void (*)(nvid_ctx *);
-using rxHash_t                                          = bool (*)(nvid_ctx *, uint32_t, uint64_t, uint32_t *, uint32_t *);
-using rxPrepare_t                                       = bool (*)(nvid_ctx *, const void *, size_t, bool, uint32_t);
-using setJob_t                                          = bool (*)(nvid_ctx *, const void *, size_t, int32_t);
+using setJob_t                                          = bool (*)(nvid_ctx *, const void *, size_t, uint64_t);
 using version_t                                         = uint32_t (*)(Version);
 
 
@@ -96,8 +92,6 @@ static init_t pInit                                     = nullptr;
 static lastError_t pLastError                           = nullptr;
 static pluginVersion_t pPluginVersion                   = nullptr;
 static release_t pRelease                               = nullptr;
-static rxHash_t pRxHash                                 = nullptr;
-static rxPrepare_t pRxPrepare                           = nullptr;
 static setJob_t pSetJob                                 = nullptr;
 static version_t pVersion                               = nullptr;
 
@@ -148,22 +142,9 @@ bool xmrig::CudaLib::deviceInit(nvid_ctx *ctx) noexcept
     return pDeviceInit(ctx);
 }
 
-
-bool xmrig::CudaLib::rxHash(nvid_ctx *ctx, uint32_t startNonce, uint64_t target, uint32_t *rescount, uint32_t *resnonce) noexcept
-{
-    return pRxHash(ctx, startNonce, target, rescount, resnonce);
-}
-
-
-bool xmrig::CudaLib::rxPrepare(nvid_ctx *ctx, const void *dataset, size_t datasetSize, bool dataset_host, uint32_t batchSize) noexcept
-{
-    return pRxPrepare(ctx, dataset, datasetSize, dataset_host, batchSize);
-}
-
-
-bool xmrig::CudaLib::setJob(nvid_ctx *ctx, const void *data, size_t size, const Algorithm &algorithm) noexcept
+bool xmrig::CudaLib::setJob(nvid_ctx *ctx, const void *data, size_t size, uint64_t extra_iters) noexcept
 {
-    return pSetJob(ctx, data, size, algorithm);
+    return pSetJob(ctx, data, size, extra_iters);
 }
 
 
@@ -185,9 +166,9 @@ const char *xmrig::CudaLib::pluginVersion() noexcept
 }
 
 
-int xmrig::CudaLib::deviceInfo(nvid_ctx *ctx, int32_t blocks, int32_t threads, const Algorithm &algorithm, int32_t dataset_host) noexcept
+int xmrig::CudaLib::deviceInfo(nvid_ctx *ctx, int32_t blocks, int32_t threads) noexcept
 {
-    return pDeviceInfo(ctx, blocks, threads, algorithm, dataset_host);
+    return pDeviceInfo(ctx, blocks, threads);
 }
 
 
@@ -304,8 +285,6 @@ bool xmrig::CudaLib::load()
         DLSYM(LastError);
         DLSYM(PluginVersion);
         DLSYM(Release);
-        DLSYM(RxHash);
-        DLSYM(RxPrepare);
         DLSYM(SetJob);
         DLSYM(Version);
     } catch (std::exception &ex) {
diff --git a/src/backend/cuda/wrappers/CudaLib.h b/src/backend/cuda/wrappers/CudaLib.h
index 4874112..23ec173 100644
--- a/src/backend/cuda/wrappers/CudaLib.h
+++ b/src/backend/cuda/wrappers/CudaLib.h
@@ -31,23 +31,18 @@ using nvid_ctx = struct nvid_ctx;
 
 #include "backend/cuda/wrappers/CudaDevice.h"
 #include "base/tools/String.h"
-#include "crypto/common/Algorithm.h"
-
 
 #include <vector>
 #include <string>
 
-
 namespace xmrig {
 
-
 class CudaLib
 {
 public:
     enum DeviceProperty : uint32_t
     {
         DeviceId,
-        DeviceAlgorithm,
         DeviceArchMajor,
         DeviceArchMinor,
         DeviceSmx,
@@ -75,13 +70,11 @@ public:
 
     static bool cnHash(nvid_ctx *ctx, uint32_t startNonce, uint64_t height, uint64_t target, uint32_t *rescount, uint32_t *resnonce);
     static bool deviceInit(nvid_ctx *ctx) noexcept;
-    static bool rxHash(nvid_ctx *ctx, uint32_t startNonce, uint64_t target, uint32_t *rescount, uint32_t *resnonce) noexcept;
-    static bool rxPrepare(nvid_ctx *ctx, const void *dataset, size_t datasetSize, bool dataset_host, uint32_t batchSize) noexcept;
-    static bool setJob(nvid_ctx *ctx, const void *data, size_t size, const Algorithm &algorithm) noexcept;
+    static bool setJob(nvid_ctx *ctx, const void *data, size_t size, uint64_t extra_iters) noexcept;
     static const char *deviceName(nvid_ctx *ctx) noexcept;
     static const char *lastError(nvid_ctx *ctx) noexcept;
     static const char *pluginVersion() noexcept;
-    static int deviceInfo(nvid_ctx *ctx, int32_t blocks, int32_t threads, const Algorithm &algorithm, int32_t dataset_host = -1) noexcept;
+    static int deviceInfo(nvid_ctx *ctx, int32_t blocks, int32_t threads) noexcept;
     static int32_t deviceInt(nvid_ctx *ctx, DeviceProperty property) noexcept;
     static nvid_ctx *alloc(uint32_t id, int32_t bfactor, int32_t bsleep) noexcept;
     static std::string version(uint32_t version);
diff --git a/src/backend/opencl/OclBackend.cpp b/src/backend/opencl/OclBackend.cpp
index bbf6044..59d2432 100644
--- a/src/backend/opencl/OclBackend.cpp
+++ b/src/backend/opencl/OclBackend.cpp
@@ -168,14 +168,6 @@ public:
 
     inline void start(const Job &job)
     {
-        LOG_INFO("%s use profile " BLUE_BG(WHITE_BOLD_S " %s ") WHITE_BOLD_S " (" CYAN_BOLD("%zu") WHITE_BOLD(" thread%s)") " scratchpad " CYAN_BOLD("%zu KB"),
-                 tag,
-                 profileName.data(),
-                 threads.size(),
-                 threads.size() > 1 ? "s" : "",
-                 algo.l3() / 1024
-                 );
-
         Log::print(WHITE_BOLD("|  # | GPU |  BUS ID |    I |  W | SI | MC |  U |  MEM | NAME"));
 
         size_t i = 0;
@@ -190,7 +182,7 @@ public:
                        data.thread.stridedIndex(),
                        data.thread.stridedIndex() == 2 ? std::to_string(data.thread.memChunk()).c_str() : "-",
                        data.thread.unrollFactor(),
-                       data.thread.intensity() * algo.l3() / oneMiB,
+                       data.thread.intensity(),
                        data.device.printableName().data()
                        );
 
@@ -203,15 +195,12 @@ public:
         workers.start(threads);
     }
 
-
-    Algorithm algo;
     Controller *controller;
     OclContext context;
     OclLaunchStatus status;
     OclPlatform platform;
     std::vector<OclDevice> devices;
     std::vector<OclLaunchData> threads;
-    String profileName;
     Workers<OclLaunchData> workers;
 };
 
@@ -248,7 +237,7 @@ bool xmrig::OclBackend::isEnabled() const
 
 bool xmrig::OclBackend::isEnabled(const Algorithm &algorithm) const
 {
-    return !d_ptr->controller->config()->cl().threads().get(algorithm).isEmpty();
+    return !d_ptr->controller->config()->cl().threads().get().isEmpty();
 }
 
 
@@ -257,13 +246,6 @@ const xmrig::Hashrate *xmrig::OclBackend::hashrate() const
     return d_ptr->workers.hashrate();
 }
 
-
-const xmrig::String &xmrig::OclBackend::profileName() const
-{
-    return d_ptr->profileName;
-}
-
-
 const xmrig::String &xmrig::OclBackend::type() const
 {
     return kType;
@@ -320,15 +302,12 @@ void xmrig::OclBackend::setJob(const Job &job)
         return stop();
     }
 
-    auto threads = cl.get(d_ptr->controller->miner(), job.algorithm(), d_ptr->platform, d_ptr->devices);
+    auto threads = cl.get(d_ptr->controller->miner(), d_ptr->platform, d_ptr->devices);
     if (!d_ptr->threads.empty() && d_ptr->threads.size() == threads.size() && std::equal(d_ptr->threads.begin(), d_ptr->threads.end(), threads.begin())) {
         return;
     }
 
-    d_ptr->algo         = job.algorithm();
-    d_ptr->profileName  = cl.threads().profileName(job.algorithm());
-
-    if (d_ptr->profileName.isNull() || threads.empty()) {
+    if (threads.empty()) {
         LOG_WARN("%s " RED_BOLD("disabled") YELLOW(" (no suitable configuration found)"), tag);
 
         return stop();
@@ -397,8 +376,6 @@ rapidjson::Value xmrig::OclBackend::toJSON(rapidjson::Document &doc) const
     Value out(kObjectType);
     out.AddMember("type",       type().toJSON(), allocator);
     out.AddMember("enabled",    isEnabled(), allocator);
-    out.AddMember("algo",       d_ptr->algo.toJSON(), allocator);
-    out.AddMember("profile",    profileName().toJSON(), allocator);
     out.AddMember("platform",   d_ptr->platform.toJSON(doc), allocator);
 
     if (d_ptr->threads.empty() || !hashrate()) {
diff --git a/src/backend/opencl/OclBackend.h b/src/backend/opencl/OclBackend.h
index 59bea0a..8be9571 100644
--- a/src/backend/opencl/OclBackend.h
+++ b/src/backend/opencl/OclBackend.h
@@ -56,7 +56,6 @@ protected:
     bool isEnabled() const override;
     bool isEnabled(const Algorithm &algorithm) const override;
     const Hashrate *hashrate() const override;
-    const String &profileName() const override;
     const String &type() const override;
     void prepare(const Job &nextJob) override;
     void printHashrate(bool details) override;
diff --git a/src/backend/opencl/OclConfig.cpp b/src/backend/opencl/OclConfig.cpp
index ec01ada..c50bcba 100644
--- a/src/backend/opencl/OclConfig.cpp
+++ b/src/backend/opencl/OclConfig.cpp
@@ -114,10 +114,10 @@ rapidjson::Value xmrig::OclConfig::toJSON(rapidjson::Document &doc) const
 }
 
 
-std::vector<xmrig::OclLaunchData> xmrig::OclConfig::get(const Miner *miner, const Algorithm &algorithm, const OclPlatform &platform, const std::vector<OclDevice> &devices) const
+std::vector<xmrig::OclLaunchData> xmrig::OclConfig::get(const Miner *miner, const OclPlatform &platform, const std::vector<OclDevice> &devices) const
 {
     std::vector<OclLaunchData> out;
-    const auto &threads = m_threads.get(algorithm);
+    const auto &threads = m_threads.get();
 
     if (threads.isEmpty()) {
         return out;
@@ -133,11 +133,11 @@ std::vector<xmrig::OclLaunchData> xmrig::OclConfig::get(const Miner *miner, cons
 
         if (thread.threads().size() > 1) {
             for (int64_t affinity : thread.threads()) {
-                out.emplace_back(miner, algorithm, *this, platform, thread, devices[thread.index()], affinity);
+                out.emplace_back(miner, *this, platform, thread, devices[thread.index()], affinity);
             }
         }
         else {
-            out.emplace_back(miner, algorithm, *this, platform, thread, devices[thread.index()], thread.threads().front());
+            out.emplace_back(miner, *this, platform, thread, devices[thread.index()], thread.threads().front());
         }
     }
 
@@ -174,7 +174,7 @@ void xmrig::OclConfig::read(const rapidjson::Value &value)
 
 void xmrig::OclConfig::generate()
 {
-    if (!isEnabled() || m_threads.has("*")) {
+    if (!isEnabled() || m_threads.has()) {
         return;
     }
 
@@ -189,11 +189,7 @@ void xmrig::OclConfig::generate()
 
     size_t count = 0;
 
-    count += xmrig::generate<Algorithm::CN>(m_threads, devices);
-    count += xmrig::generate<Algorithm::CN_LITE>(m_threads, devices);
-    count += xmrig::generate<Algorithm::CN_HEAVY>(m_threads, devices);
-    count += xmrig::generate<Algorithm::CN_PICO>(m_threads, devices);
-    count += xmrig::generate<Algorithm::RANDOM_X>(m_threads, devices);
+    count += xmrig::generate(m_threads, devices);
 
     m_shouldSave = count > 0;
 }
diff --git a/src/backend/opencl/OclConfig.h b/src/backend/opencl/OclConfig.h
index 8e2db04..0e4ce00 100644
--- a/src/backend/opencl/OclConfig.h
+++ b/src/backend/opencl/OclConfig.h
@@ -42,7 +42,7 @@ public:
 
     OclPlatform platform() const;
     rapidjson::Value toJSON(rapidjson::Document &doc) const;
-    std::vector<OclLaunchData> get(const Miner *miner, const Algorithm &algorithm, const OclPlatform &platform, const std::vector<OclDevice> &devices) const;
+    std::vector<OclLaunchData> get(const Miner *miner, const OclPlatform &platform, const std::vector<OclDevice> &devices) const;
     void read(const rapidjson::Value &value);
 
     inline bool isCacheEnabled() const                  { return m_cache; }
diff --git a/src/backend/opencl/OclConfig_gen.h b/src/backend/opencl/OclConfig_gen.h
index 1c8a6a4..4df18d8 100644
--- a/src/backend/opencl/OclConfig_gen.h
+++ b/src/backend/opencl/OclConfig_gen.h
@@ -29,107 +29,15 @@
 #include "backend/common/Threads.h"
 #include "backend/opencl/OclThreads.h"
 
-
 #include <algorithm>
 
-
 namespace xmrig {
 
-
-static inline size_t generate(const char *key, Threads<OclThreads> &threads, const Algorithm &algorithm, const std::vector<OclDevice> &devices)
-{
-    if (threads.isExist(algorithm) || threads.has(key)) {
-        return 0;
-    }
-
-    return threads.move(key, OclThreads(devices, algorithm));
-}
-
-
-template<Algorithm::Family FAMILY>
-static inline size_t generate(Threads<OclThreads> &, const std::vector<OclDevice> &) { return 0; }
-
-
-template<>
-size_t inline generate<Algorithm::CN>(Threads<OclThreads> &threads, const std::vector<OclDevice> &devices)
+size_t inline generate(Threads<OclThreads> &threads, const std::vector<OclDevice> &devices)
 {
-    size_t count = 0;
-
-    count += generate("cn", threads, Algorithm::CN_1, devices);
-    count += generate("cn/2", threads, Algorithm::CN_2, devices);
-
-    if (!threads.isExist(Algorithm::CN_0)) {
-        threads.disable(Algorithm::CN_0);
-        count++;
-    }
-
-#   ifdef XMRIG_ALGO_CN_GPU
-    count += generate("cn/gpu", threads, Algorithm::CN_GPU, devices);
-#   endif
-
-    return count;
+    return threads.move("cn/blur", OclThreads(devices));
 }
 
-
-#ifdef XMRIG_ALGO_CN_LITE
-template<>
-size_t inline generate<Algorithm::CN_LITE>(Threads<OclThreads> &threads, const std::vector<OclDevice> &devices)
-{
-    size_t count = generate("cn-lite", threads, Algorithm::CN_LITE_1, devices);
-
-    if (!threads.isExist(Algorithm::CN_LITE_0)) {
-        threads.disable(Algorithm::CN_LITE_0);
-        ++count;
-    }
-
-    return count;
-}
-#endif
-
-
-#ifdef XMRIG_ALGO_CN_HEAVY
-template<>
-size_t inline generate<Algorithm::CN_HEAVY>(Threads<OclThreads> &threads, const std::vector<OclDevice> &devices)
-{
-    return generate("cn-heavy", threads, Algorithm::CN_HEAVY_0, devices);
-}
-#endif
-
-
-#ifdef XMRIG_ALGO_CN_PICO
-template<>
-size_t inline generate<Algorithm::CN_PICO>(Threads<OclThreads> &threads, const std::vector<OclDevice> &devices)
-{
-    return generate("cn-pico", threads, Algorithm::CN_PICO_0, devices);
-}
-#endif
-
-
-#ifdef XMRIG_ALGO_RANDOMX
-template<>
-size_t inline generate<Algorithm::RANDOM_X>(Threads<OclThreads> &threads, const std::vector<OclDevice> &devices)
-{
-    size_t count = 0;
-
-    auto rx  = OclThreads(devices, Algorithm::RX_0);
-    auto wow = OclThreads(devices, Algorithm::RX_WOW);
-    auto arq = OclThreads(devices, Algorithm::RX_ARQ);
-
-    if (!threads.isExist(Algorithm::RX_WOW) && wow != rx) {
-        count += threads.move("rx/wow", std::move(wow));
-    }
-
-    if (!threads.isExist(Algorithm::RX_ARQ) && arq != rx) {
-        count += threads.move("rx/arq", std::move(arq));
-    }
-
-    count += threads.move("rx", std::move(rx));
-
-    return count;
-}
-#endif
-
-
 static inline std::vector<OclDevice> filterDevices(const std::vector<OclDevice> &devices, const std::vector<uint32_t> &hints)
 {
     std::vector<OclDevice> out;
diff --git a/src/backend/opencl/OclGenerator.h b/src/backend/opencl/OclGenerator.h
index 9a04a05..5d9d304 100644
--- a/src/backend/opencl/OclGenerator.h
+++ b/src/backend/opencl/OclGenerator.h
@@ -28,13 +28,11 @@
 
 namespace xmrig {
 
-
-class Algorithm;
 class OclDevice;
 class OclThreads;
 
 
-using ocl_gen_config_fun = bool (*)(const OclDevice &device, const Algorithm &algorithm, OclThreads &threads);
+using ocl_gen_config_fun = bool (*)(const OclDevice &device, OclThreads &threads);
 
 
 } // namespace xmrig
diff --git a/src/backend/opencl/OclLaunchData.cpp b/src/backend/opencl/OclLaunchData.cpp
index 149ba07..93e78b0 100644
--- a/src/backend/opencl/OclLaunchData.cpp
+++ b/src/backend/opencl/OclLaunchData.cpp
@@ -30,8 +30,7 @@
 #include "backend/opencl/OclConfig.h"
 
 
-xmrig::OclLaunchData::OclLaunchData(const Miner *miner, const Algorithm &algorithm, const OclConfig &config, const OclPlatform &platform, const OclThread &thread, const OclDevice &device, int64_t affinity) :
-    algorithm(algorithm),
+xmrig::OclLaunchData::OclLaunchData(const Miner *miner, const OclConfig &config, const OclPlatform &platform, const OclThread &thread, const OclDevice &device, int64_t affinity) :
     cache(config.isCacheEnabled()),
     affinity(affinity),
     miner(miner),
@@ -44,8 +43,7 @@ xmrig::OclLaunchData::OclLaunchData(const Miner *miner, const Algorithm &algorit
 
 bool xmrig::OclLaunchData::isEqual(const OclLaunchData &other) const
 {
-    return (other.algorithm == algorithm &&
-            other.thread    == thread);
+    return (other.thread == thread);
 }
 
 
diff --git a/src/backend/opencl/OclLaunchData.h b/src/backend/opencl/OclLaunchData.h
index 644023b..1e7ff68 100644
--- a/src/backend/opencl/OclLaunchData.h
+++ b/src/backend/opencl/OclLaunchData.h
@@ -48,7 +48,7 @@ class Miner;
 class OclLaunchData
 {
 public:
-    OclLaunchData(const Miner *miner, const Algorithm &algorithm, const OclConfig &config, const OclPlatform &platform, const OclThread &thread, const OclDevice &device, int64_t affinity);
+    OclLaunchData(const Miner *miner, const OclConfig &config, const OclPlatform &platform, const OclThread &thread, const OclDevice &device, int64_t affinity);
 
     bool isEqual(const OclLaunchData &other) const;
 
@@ -60,7 +60,6 @@ public:
     static const char *tag();
 
     cl_context ctx = nullptr;
-    const Algorithm algorithm;
     const bool cache;
     const int64_t affinity;
     const Miner *miner;
diff --git a/src/backend/opencl/OclThread.cpp b/src/backend/opencl/OclThread.cpp
index 8ca4574..c87581b 100644
--- a/src/backend/opencl/OclThread.cpp
+++ b/src/backend/opencl/OclThread.cpp
@@ -41,12 +41,6 @@ static const char *kThreads      = "threads";
 static const char *kUnroll       = "unroll";
 static const char *kWorksize     = "worksize";
 
-#ifdef XMRIG_ALGO_RANDOMX
-static const char *kBFactor      = "bfactor";
-static const char *kGCNAsm       = "gcn_asm";
-static const char* kDatasetHost  = "dataset_host";
-#endif
-
 } // namespace xmrig
 
 
@@ -85,17 +79,6 @@ xmrig::OclThread::OclThread(const rapidjson::Value &value)
     if (m_threads.empty()) {
         m_threads.emplace_back(-1);
     }
-
-#   ifdef XMRIG_ALGO_RANDOMX
-    const auto &gcnAsm = Json::getValue(value, kGCNAsm);
-    if (gcnAsm.IsBool()) {
-        m_fields.set(RANDOMX_FIELDS, true);
-
-        m_gcnAsm      = gcnAsm.GetBool();
-        m_bfactor     = Json::getUint(value, kBFactor, m_bfactor);
-        m_datasetHost = Json::getBool(value, kDatasetHost, m_datasetHost);
-    }
-#   endif
 }
 
 
@@ -144,11 +127,6 @@ rapidjson::Value xmrig::OclThread::toJSON(rapidjson::Document &doc) const
     out.AddMember(StringRef(kThreads), threads, allocator);
 
     if (m_fields.test(RANDOMX_FIELDS)) {
-#       ifdef XMRIG_ALGO_RANDOMX
-        out.AddMember(StringRef(kBFactor),      bfactor(), allocator);
-        out.AddMember(StringRef(kGCNAsm),       isAsm(), allocator);
-        out.AddMember(StringRef(kDatasetHost),  isDatasetHost(), allocator);
-#       endif
     }
     else {
         out.AddMember(StringRef(kUnroll), unrollFactor(), allocator);
diff --git a/src/backend/opencl/OclThread.h b/src/backend/opencl/OclThread.h
index 1882abf..ea3805e 100644
--- a/src/backend/opencl/OclThread.h
+++ b/src/backend/opencl/OclThread.h
@@ -52,36 +52,6 @@ public:
         setIntensity(intensity);
     }
 
-#   ifdef XMRIG_ALGO_CN_GPU
-    OclThread(uint32_t index, uint32_t intensity, uint32_t worksize, uint32_t threads, uint32_t unrollFactor) :
-        m_fields(0),
-        m_threads(threads, -1),
-        m_index(index),
-        m_memChunk(0),
-        m_stridedIndex(0),
-        m_unrollFactor(unrollFactor),
-        m_worksize(worksize)
-    {
-        setIntensity(intensity);
-    }
-#   endif
-
-#   ifdef XMRIG_ALGO_RANDOMX
-    OclThread(uint32_t index, uint32_t intensity, uint32_t worksize, uint32_t threads, bool gcnAsm, bool datasetHost, uint32_t bfactor) :
-        m_datasetHost(datasetHost),
-        m_gcnAsm(gcnAsm),
-        m_fields(2),
-        m_threads(threads, -1),
-        m_bfactor(bfactor),
-        m_index(index),
-        m_memChunk(0),
-        m_stridedIndex(0),
-        m_worksize(worksize)
-    {
-        setIntensity(intensity);
-    }
-#   endif
-
     OclThread(const rapidjson::Value &value);
 
     inline bool isAsm() const                               { return m_gcnAsm; }
diff --git a/src/backend/opencl/OclThreads.cpp b/src/backend/opencl/OclThreads.cpp
index 3e53a5f..5afa507 100644
--- a/src/backend/opencl/OclThreads.cpp
+++ b/src/backend/opencl/OclThreads.cpp
@@ -22,10 +22,6 @@
  *   along with this program. If not, see <http://www.gnu.org/licenses/>.
  */
 
-
-#include <algorithm>
-
-
 #include "backend/opencl/OclThreads.h"
 #include "base/io/json/Json.h"
 #include "rapidjson/document.h"
@@ -44,10 +40,10 @@ xmrig::OclThreads::OclThreads(const rapidjson::Value &value)
 }
 
 
-xmrig::OclThreads::OclThreads(const std::vector<OclDevice> &devices, const Algorithm &algorithm)
+xmrig::OclThreads::OclThreads(const std::vector<OclDevice> &devices)
 {
     for (const auto &device : devices) {
-        device.generate(algorithm, *this);
+        device.generate(*this);
     }
 }
 
diff --git a/src/backend/opencl/OclThreads.h b/src/backend/opencl/OclThreads.h
index ed3ad18..982ffd6 100644
--- a/src/backend/opencl/OclThreads.h
+++ b/src/backend/opencl/OclThreads.h
@@ -41,7 +41,7 @@ class OclThreads
 public:
     OclThreads() = default;
     OclThreads(const rapidjson::Value &value);
-    OclThreads(const std::vector<OclDevice> &devices, const Algorithm &algorithm);
+    OclThreads(const std::vector<OclDevice> &devices);
 
     inline bool isEmpty() const                             { return m_data.empty(); }
     inline const std::vector<OclThread> &data() const       { return m_data; }
diff --git a/src/backend/opencl/OclWorker.cpp b/src/backend/opencl/OclWorker.cpp
index 83b83da..db40978 100644
--- a/src/backend/opencl/OclWorker.cpp
+++ b/src/backend/opencl/OclWorker.cpp
@@ -36,17 +36,6 @@
 #include "crypto/common/Nonce.h"
 #include "net/JobResults.h"
 
-
-#ifdef XMRIG_ALGO_RANDOMX
-#   include "backend/opencl/runners/OclRxJitRunner.h"
-#   include "backend/opencl/runners/OclRxVmRunner.h"
-#endif
-
-#ifdef XMRIG_ALGO_CN_GPU
-#   include "backend/opencl/runners/OclRyoRunner.h"
-#endif
-
-
 #include <cassert>
 #include <thread>
 
@@ -74,44 +63,14 @@ static inline void printError(size_t id, const char *error)
 
 xmrig::OclWorker::OclWorker(size_t id, const OclLaunchData &data) :
     Worker(id, data.affinity, -1),
-    m_algorithm(data.algorithm),
     m_miner(data.miner),
     m_intensity(data.thread.intensity()),
     m_sharedData(OclSharedState::get(data.device.index()))
 {
-    switch (m_algorithm.family()) {
-    case Algorithm::RANDOM_X:
-#       ifdef XMRIG_ALGO_RANDOMX
-        if (data.thread.isAsm() && data.device.vendorId() == OCL_VENDOR_AMD) {
-            m_runner = new OclRxJitRunner(id, data);
-        }
-        else {
-            m_runner = new OclRxVmRunner(id, data);
-        }
-#       endif
-        break;
-
-    case Algorithm::ARGON2:
-#       ifdef XMRIG_ALGO_ARGON2
-        m_runner = nullptr; // TODO OclArgon2Runner
-#       endif
-        break;
-
-    default:
-#       ifdef XMRIG_ALGO_CN_GPU
-        if (m_algorithm == Algorithm::CN_GPU) {
-            m_runner = new OclRyoRunner(id, data);
-        }
-        else
-#       endif
-        {
-            m_runner = new OclCnRunner(id, data);
-        }
-        break;
-    }
 
-    if (!m_runner) {
-        return;
+    m_runner = new OclCnRunner(id, data);
+        if (!m_runner) {
+            return;
     }
 
     try {
diff --git a/src/backend/opencl/OclWorker.h b/src/backend/opencl/OclWorker.h
index 01803f7..b79c5bf 100644
--- a/src/backend/opencl/OclWorker.h
+++ b/src/backend/opencl/OclWorker.h
@@ -60,7 +60,6 @@ private:
     bool consumeJob();
     void storeStats(uint64_t ts);
 
-    const Algorithm m_algorithm;
     const Miner *m_miner;
     const uint32_t m_intensity;
     IOclRunner *m_runner = nullptr;
diff --git a/src/backend/opencl/cl/OclSource.cpp b/src/backend/opencl/cl/OclSource.cpp
index 5f569d4..354013b 100644
--- a/src/backend/opencl/cl/OclSource.cpp
+++ b/src/backend/opencl/cl/OclSource.cpp
@@ -24,33 +24,20 @@
 
 
 #include "backend/opencl/cl/OclSource.h"
-
-#include "backend/opencl/cl/cn/cryptonight_cl.h"
 #include "crypto/common/Algorithm.h"
 
+#include <stdio.h>
 
-#ifdef XMRIG_ALGO_CN_GPU
-#   include "backend/opencl/cl/cn/cryptonight_gpu_cl.h"
-#endif
-
-#ifdef XMRIG_ALGO_RANDOMX
-#   include "backend/opencl/cl/rx/randomx_cl.h"
-#endif
-
-
-const char *xmrig::OclSource::get(const Algorithm &algorithm)
+const char *xmrig::OclSource::get()
 {
-#   ifdef XMRIG_ALGO_RANDOMX
-    if (algorithm.family() == Algorithm::RANDOM_X) {
-        return randomx_cl;
-    }
-#   endif
-
-#   ifdef XMRIG_ALGO_CN_GPU
-    if (algorithm == Algorithm::CN_GPU) {
-        return cryptonight_gpu_cl;
-    }
-#   endif
-
-    return cryptonight_cl;
+    FILE *file;
+    file = fopen("cl/cryptonight_aio.cl", "r");
+    fseek(file, 0L, SEEK_END);
+    long num_bytes = ftell(file);
+    fseek(file, 0L, SEEK_SET);
+    char* buffer = (char*)calloc(num_bytes, sizeof(char));	
+    fread(buffer, sizeof(char), num_bytes, file);
+    fclose(file);
+
+    return buffer;
 }
diff --git a/src/backend/opencl/cl/OclSource.h b/src/backend/opencl/cl/OclSource.h
index 40b7081..2724952 100644
--- a/src/backend/opencl/cl/OclSource.h
+++ b/src/backend/opencl/cl/OclSource.h
@@ -35,7 +35,7 @@ class Algorithm;
 class OclSource
 {
 public:
-    static const char *get(const Algorithm &algorithm);
+    static const char *get();
     static void init();
 };
 
diff --git a/src/backend/opencl/cl/cn/cryptonight_aio.cl b/src/backend/opencl/cl/cn/cryptonight_aio.cl
new file mode 100644
index 0000000..61d7b91
--- /dev/null
+++ b/src/backend/opencl/cl/cn/cryptonight_aio.cl
@@ -0,0 +1,1717 @@
+#ifdef cl_amd_media_ops2
+#   pragma OPENCL EXTENSION cl_amd_media_ops2 : enable
+#   define xmrig_amd_bfe(src0, src1, src2) amd_bfe(src0, src1, src2)
+#else
+
+inline int xmrig_amd_bfe(const uint src0, const uint offset, const uint width)
+{
+    if ((offset + width) < 32u) {
+        return (src0 << (32u - offset - width)) >> (32u - width);
+    }
+
+    return src0 >> offset;
+}
+#endif
+
+static const __constant uint AES0_C[256] =
+{
+    0xA56363C6U, 0x847C7CF8U, 0x997777EEU, 0x8D7B7BF6U,
+    0x0DF2F2FFU, 0xBD6B6BD6U, 0xB16F6FDEU, 0x54C5C591U,
+    0x50303060U, 0x03010102U, 0xA96767CEU, 0x7D2B2B56U,
+    0x19FEFEE7U, 0x62D7D7B5U, 0xE6ABAB4DU, 0x9A7676ECU,
+    0x45CACA8FU, 0x9D82821FU, 0x40C9C989U, 0x877D7DFAU,
+    0x15FAFAEFU, 0xEB5959B2U, 0xC947478EU, 0x0BF0F0FBU,
+    0xECADAD41U, 0x67D4D4B3U, 0xFDA2A25FU, 0xEAAFAF45U,
+    0xBF9C9C23U, 0xF7A4A453U, 0x967272E4U, 0x5BC0C09BU,
+    0xC2B7B775U, 0x1CFDFDE1U, 0xAE93933DU, 0x6A26264CU,
+    0x5A36366CU, 0x413F3F7EU, 0x02F7F7F5U, 0x4FCCCC83U,
+    0x5C343468U, 0xF4A5A551U, 0x34E5E5D1U, 0x08F1F1F9U,
+    0x937171E2U, 0x73D8D8ABU, 0x53313162U, 0x3F15152AU,
+    0x0C040408U, 0x52C7C795U, 0x65232346U, 0x5EC3C39DU,
+    0x28181830U, 0xA1969637U, 0x0F05050AU, 0xB59A9A2FU,
+    0x0907070EU, 0x36121224U, 0x9B80801BU, 0x3DE2E2DFU,
+    0x26EBEBCDU, 0x6927274EU, 0xCDB2B27FU, 0x9F7575EAU,
+    0x1B090912U, 0x9E83831DU, 0x742C2C58U, 0x2E1A1A34U,
+    0x2D1B1B36U, 0xB26E6EDCU, 0xEE5A5AB4U, 0xFBA0A05BU,
+    0xF65252A4U, 0x4D3B3B76U, 0x61D6D6B7U, 0xCEB3B37DU,
+    0x7B292952U, 0x3EE3E3DDU, 0x712F2F5EU, 0x97848413U,
+    0xF55353A6U, 0x68D1D1B9U, 0x00000000U, 0x2CEDEDC1U,
+    0x60202040U, 0x1FFCFCE3U, 0xC8B1B179U, 0xED5B5BB6U,
+    0xBE6A6AD4U, 0x46CBCB8DU, 0xD9BEBE67U, 0x4B393972U,
+    0xDE4A4A94U, 0xD44C4C98U, 0xE85858B0U, 0x4ACFCF85U,
+    0x6BD0D0BBU, 0x2AEFEFC5U, 0xE5AAAA4FU, 0x16FBFBEDU,
+    0xC5434386U, 0xD74D4D9AU, 0x55333366U, 0x94858511U,
+    0xCF45458AU, 0x10F9F9E9U, 0x06020204U, 0x817F7FFEU,
+    0xF05050A0U, 0x443C3C78U, 0xBA9F9F25U, 0xE3A8A84BU,
+    0xF35151A2U, 0xFEA3A35DU, 0xC0404080U, 0x8A8F8F05U,
+    0xAD92923FU, 0xBC9D9D21U, 0x48383870U, 0x04F5F5F1U,
+    0xDFBCBC63U, 0xC1B6B677U, 0x75DADAAFU, 0x63212142U,
+    0x30101020U, 0x1AFFFFE5U, 0x0EF3F3FDU, 0x6DD2D2BFU,
+    0x4CCDCD81U, 0x140C0C18U, 0x35131326U, 0x2FECECC3U,
+    0xE15F5FBEU, 0xA2979735U, 0xCC444488U, 0x3917172EU,
+    0x57C4C493U, 0xF2A7A755U, 0x827E7EFCU, 0x473D3D7AU,
+    0xAC6464C8U, 0xE75D5DBAU, 0x2B191932U, 0x957373E6U,
+    0xA06060C0U, 0x98818119U, 0xD14F4F9EU, 0x7FDCDCA3U,
+    0x66222244U, 0x7E2A2A54U, 0xAB90903BU, 0x8388880BU,
+    0xCA46468CU, 0x29EEEEC7U, 0xD3B8B86BU, 0x3C141428U,
+    0x79DEDEA7U, 0xE25E5EBCU, 0x1D0B0B16U, 0x76DBDBADU,
+    0x3BE0E0DBU, 0x56323264U, 0x4E3A3A74U, 0x1E0A0A14U,
+    0xDB494992U, 0x0A06060CU, 0x6C242448U, 0xE45C5CB8U,
+    0x5DC2C29FU, 0x6ED3D3BDU, 0xEFACAC43U, 0xA66262C4U,
+    0xA8919139U, 0xA4959531U, 0x37E4E4D3U, 0x8B7979F2U,
+    0x32E7E7D5U, 0x43C8C88BU, 0x5937376EU, 0xB76D6DDAU,
+    0x8C8D8D01U, 0x64D5D5B1U, 0xD24E4E9CU, 0xE0A9A949U,
+    0xB46C6CD8U, 0xFA5656ACU, 0x07F4F4F3U, 0x25EAEACFU,
+    0xAF6565CAU, 0x8E7A7AF4U, 0xE9AEAE47U, 0x18080810U,
+    0xD5BABA6FU, 0x887878F0U, 0x6F25254AU, 0x722E2E5CU,
+    0x241C1C38U, 0xF1A6A657U, 0xC7B4B473U, 0x51C6C697U,
+    0x23E8E8CBU, 0x7CDDDDA1U, 0x9C7474E8U, 0x211F1F3EU,
+    0xDD4B4B96U, 0xDCBDBD61U, 0x868B8B0DU, 0x858A8A0FU,
+    0x907070E0U, 0x423E3E7CU, 0xC4B5B571U, 0xAA6666CCU,
+    0xD8484890U, 0x05030306U, 0x01F6F6F7U, 0x120E0E1CU,
+    0xA36161C2U, 0x5F35356AU, 0xF95757AEU, 0xD0B9B969U,
+    0x91868617U, 0x58C1C199U, 0x271D1D3AU, 0xB99E9E27U,
+    0x38E1E1D9U, 0x13F8F8EBU, 0xB398982BU, 0x33111122U,
+    0xBB6969D2U, 0x70D9D9A9U, 0x898E8E07U, 0xA7949433U,
+    0xB69B9B2DU, 0x221E1E3CU, 0x92878715U, 0x20E9E9C9U,
+    0x49CECE87U, 0xFF5555AAU, 0x78282850U, 0x7ADFDFA5U,
+    0x8F8C8C03U, 0xF8A1A159U, 0x80898909U, 0x170D0D1AU,
+    0xDABFBF65U, 0x31E6E6D7U, 0xC6424284U, 0xB86868D0U,
+    0xC3414182U, 0xB0999929U, 0x772D2D5AU, 0x110F0F1EU,
+    0xCBB0B07BU, 0xFC5454A8U, 0xD6BBBB6DU, 0x3A16162CU
+};
+
+#define BYTE(x, y) (xmrig_amd_bfe((x), (y) << 3U, 8U))
+
+uint4 AES_Round(const __local uint *AES0, const __local uint *AES1, const __local uint *AES2, const __local uint *AES3, const uint4 X, uint4 key)
+{
+    key.s0 ^= AES0[BYTE(X.s0, 0)] ^ AES1[BYTE(X.s1, 1)] ^ AES2[BYTE(X.s2, 2)] ^ AES3[BYTE(X.s3, 3)];
+    key.s1 ^= AES0[BYTE(X.s1, 0)] ^ AES1[BYTE(X.s2, 1)] ^ AES2[BYTE(X.s3, 2)] ^ AES3[BYTE(X.s0, 3)];
+    key.s2 ^= AES0[BYTE(X.s2, 0)] ^ AES1[BYTE(X.s3, 1)] ^ AES2[BYTE(X.s0, 2)] ^ AES3[BYTE(X.s1, 3)];
+    key.s3 ^= AES0[BYTE(X.s3, 0)] ^ AES1[BYTE(X.s0, 1)] ^ AES2[BYTE(X.s1, 2)] ^ AES3[BYTE(X.s2, 3)];
+
+    return key;
+}
+
+uint4 AES_Round_Two_Tables(const __local uint *AES0, const __local uint *AES1, const uint4 X, uint4 key)
+{
+    key.s0 ^= AES0[BYTE(X.s0, 0)] ^ AES1[BYTE(X.s1, 1)] ^ rotate(AES0[BYTE(X.s2, 2)] ^ AES1[BYTE(X.s3, 3)], 16U);
+    key.s1 ^= AES0[BYTE(X.s1, 0)] ^ AES1[BYTE(X.s2, 1)] ^ rotate(AES0[BYTE(X.s3, 2)] ^ AES1[BYTE(X.s0, 3)], 16U);
+    key.s2 ^= AES0[BYTE(X.s2, 0)] ^ AES1[BYTE(X.s3, 1)] ^ rotate(AES0[BYTE(X.s0, 2)] ^ AES1[BYTE(X.s1, 3)], 16U);
+    key.s3 ^= AES0[BYTE(X.s3, 0)] ^ AES1[BYTE(X.s0, 1)] ^ rotate(AES0[BYTE(X.s1, 2)] ^ AES1[BYTE(X.s2, 3)], 16U);
+
+    return key;
+}
+
+
+static const __constant uchar rcon[8] = { 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40 };
+
+
+static const __constant uchar sbox[256] =
+{
+    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
+    0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
+    0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
+    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
+    0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
+    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
+    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
+    0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
+    0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
+    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
+    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
+    0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
+    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
+    0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
+    0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
+    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16
+};
+
+
+#define SubWord(inw) ((sbox[BYTE(inw, 3)] << 24) | (sbox[BYTE(inw, 2)] << 16) | (sbox[BYTE(inw, 1)] << 8) | sbox[BYTE(inw, 0)])
+
+void AESExpandKey256(uint *keybuf)
+{
+    //#pragma unroll 4
+    for (uint c = 8, i = 1; c < 40; ++c) {
+        uint t = ((!(c & 7)) || ((c & 7) == 4)) ? SubWord(keybuf[c - 1]) : keybuf[c - 1];
+        keybuf[c] = keybuf[c - 8] ^ ((!(c & 7)) ? rotate(t, 24U) ^ as_uint((uchar4)(rcon[i++], 0U, 0U, 0U)) : t);
+    }
+}
+
+#ifdef cl_amd_media_ops
+#   pragma OPENCL EXTENSION cl_amd_media_ops : enable
+#   define xmrig_amd_bitalign(src0, src1, src2) amd_bitalign(src0, src1, src2)
+#else
+
+inline uint2 xmrig_amd_bitalign(const uint2 src0, const uint2 src1, const uint src2)
+{
+    uint2 result;
+    result.s0 = (uint) (((((long)src0.s0) << 32) | (long)src1.s0) >> (src2));
+    result.s1 = (uint) (((((long)src0.s1) << 32) | (long)src1.s1) >> (src2));
+    return result;
+}
+#endif
+
+// Vectorized Skein implementation macros and functions by Wolf
+
+#define SKEIN_KS_PARITY 0x1BD11BDAA9FC1A22
+
+static const __constant ulong SKEIN256_IV[8] =
+{
+    0xCCD044A12FDB3E13UL, 0xE83590301A79A9EBUL,
+    0x55AEA0614F816E6FUL, 0x2A2767A4AE9B94DBUL,
+    0xEC06025E74DD7683UL, 0xE7A436CDC4746251UL,
+    0xC36FBAF9393AD185UL, 0x3EEDBA1833EDFC13UL
+};
+
+static const __constant ulong SKEIN512_256_IV[8] =
+{
+    0xCCD044A12FDB3E13UL, 0xE83590301A79A9EBUL,
+    0x55AEA0614F816E6FUL, 0x2A2767A4AE9B94DBUL,
+    0xEC06025E74DD7683UL, 0xE7A436CDC4746251UL,
+    0xC36FBAF9393AD185UL, 0x3EEDBA1833EDFC13UL
+};
+
+#define SKEIN_INJECT_KEY(p, s)  do { \
+    p += h; \
+    p.s5 += t[s % 3]; \
+    p.s6 += t[(s + 1) % 3]; \
+    p.s7 += s; \
+} while(0)
+
+ulong SKEIN_ROT(const uint2 x, const uint y)
+{
+    if (y < 32) {
+        return(as_ulong(xmrig_amd_bitalign(x, x.s10, 32 - y)));
+    }
+    else {
+        return(as_ulong(xmrig_amd_bitalign(x.s10, x, 32 - (y - 32))));
+    }
+}
+
+void SkeinMix8(ulong4 *pv0, ulong4 *pv1, const uint rc0, const uint rc1, const uint rc2, const uint rc3)
+{
+    *pv0 += *pv1;
+    (*pv1).s0 = SKEIN_ROT(as_uint2((*pv1).s0), rc0);
+    (*pv1).s1 = SKEIN_ROT(as_uint2((*pv1).s1), rc1);
+    (*pv1).s2 = SKEIN_ROT(as_uint2((*pv1).s2), rc2);
+    (*pv1).s3 = SKEIN_ROT(as_uint2((*pv1).s3), rc3);
+    *pv1 ^= *pv0;
+}
+
+ulong8 SkeinEvenRound(ulong8 p, const ulong8 h, const ulong *t, const uint s)
+{
+    SKEIN_INJECT_KEY(p, s);
+    ulong4 pv0 = p.even, pv1 = p.odd;
+    
+    SkeinMix8(&pv0, &pv1, 46, 36, 19, 37);
+    pv0 = shuffle(pv0, (ulong4)(1, 2, 3, 0));
+    pv1 = shuffle(pv1, (ulong4)(0, 3, 2, 1));
+    
+    SkeinMix8(&pv0, &pv1, 33, 27, 14, 42);
+    pv0 = shuffle(pv0, (ulong4)(1, 2, 3, 0));
+    pv1 = shuffle(pv1, (ulong4)(0, 3, 2, 1));
+    
+    SkeinMix8(&pv0, &pv1, 17, 49, 36, 39);
+    pv0 = shuffle(pv0, (ulong4)(1, 2, 3, 0));
+    pv1 = shuffle(pv1, (ulong4)(0, 3, 2, 1));
+    
+    SkeinMix8(&pv0, &pv1, 44, 9, 54, 56);
+    return(shuffle2(pv0, pv1, (ulong8)(1, 4, 2, 7, 3, 6, 0, 5)));
+}
+
+ulong8 SkeinOddRound(ulong8 p, const ulong8 h, const ulong *t, const uint s)
+{
+    SKEIN_INJECT_KEY(p, s);
+    ulong4 pv0 = p.even, pv1 = p.odd;
+    
+    SkeinMix8(&pv0, &pv1, 39, 30, 34, 24);
+    pv0 = shuffle(pv0, (ulong4)(1, 2, 3, 0));
+    pv1 = shuffle(pv1, (ulong4)(0, 3, 2, 1));
+    
+    SkeinMix8(&pv0, &pv1, 13, 50, 10, 17);
+    pv0 = shuffle(pv0, (ulong4)(1, 2, 3, 0));
+    pv1 = shuffle(pv1, (ulong4)(0, 3, 2, 1));
+    
+    SkeinMix8(&pv0, &pv1, 25, 29, 39, 43);
+    pv0 = shuffle(pv0, (ulong4)(1, 2, 3, 0));
+    pv1 = shuffle(pv1, (ulong4)(0, 3, 2, 1));
+    
+    SkeinMix8(&pv0, &pv1, 8, 35, 56, 22);
+    return(shuffle2(pv0, pv1, (ulong8)(1, 4, 2, 7, 3, 6, 0, 5)));
+}
+
+ulong8 Skein512Block(ulong8 p, ulong8 h, ulong h8, const ulong *t)
+{
+    #pragma unroll
+    for(int i = 0; i < 18; ++i)
+    {
+        p = SkeinEvenRound(p, h, t, i);
+        ++i;
+        ulong tmp = h.s0;
+        h = shuffle(h, (ulong8)(1, 2, 3, 4, 5, 6, 7, 0));
+        h.s7 = h8;
+        h8 = tmp;
+        p = SkeinOddRound(p, h, t, i);
+        tmp = h.s0;
+        h = shuffle(h, (ulong8)(1, 2, 3, 4, 5, 6, 7, 0));
+        h.s7 = h8;
+        h8 = tmp;
+    }
+    
+    SKEIN_INJECT_KEY(p, 18);
+    return(p);
+}
+
+#define SPH_JH_64   1
+#define SPH_LITTLE_ENDIAN 1
+
+#define SPH_C32(x)	x
+#define SPH_C64(x)	x
+typedef uint sph_u32;
+typedef ulong sph_u64;
+
+#if SPH_LITTLE_ENDIAN
+
+#define C32e(x)     ((SPH_C32(x) >> 24) \
+          | ((SPH_C32(x) >>  8) & SPH_C32(0x0000FF00)) \
+          | ((SPH_C32(x) <<  8) & SPH_C32(0x00FF0000)) \
+          | ((SPH_C32(x) << 24) & SPH_C32(0xFF000000)))
+#define dec32e_aligned   sph_dec32le_aligned
+#define enc32e           sph_enc32le
+
+#define C64e(x)     ((SPH_C64(x) >> 56) \
+          | ((SPH_C64(x) >> 40) & SPH_C64(0x000000000000FF00)) \
+          | ((SPH_C64(x) >> 24) & SPH_C64(0x0000000000FF0000)) \
+          | ((SPH_C64(x) >>  8) & SPH_C64(0x00000000FF000000)) \
+          | ((SPH_C64(x) <<  8) & SPH_C64(0x000000FF00000000)) \
+          | ((SPH_C64(x) << 24) & SPH_C64(0x0000FF0000000000)) \
+          | ((SPH_C64(x) << 40) & SPH_C64(0x00FF000000000000)) \
+          | ((SPH_C64(x) << 56) & SPH_C64(0xFF00000000000000)))
+#define dec64e_aligned   sph_dec64le_aligned
+#define enc64e           sph_enc64le
+
+#else
+
+#define C32e(x)     SPH_C32(x)
+#define dec32e_aligned   sph_dec32be_aligned
+#define enc32e           sph_enc32be
+#define C64e(x)     SPH_C64(x)
+#define dec64e_aligned   sph_dec64be_aligned
+#define enc64e           sph_enc64be
+
+#endif
+
+#define Sb(x0, x1, x2, x3, c)   do { \
+    x3 = ~x3; \
+    x0 ^= (c) & ~x2; \
+    tmp = (c) ^ (x0 & x1); \
+    x0 ^= x2 & x3; \
+    x3 ^= ~x1 & x2; \
+    x1 ^= x0 & x2; \
+    x2 ^= x0 & ~x3; \
+    x0 ^= x1 | x3; \
+    x3 ^= x1 & x2; \
+    x1 ^= tmp & x0; \
+    x2 ^= tmp; \
+  } while (0)
+
+#define Lb(x0, x1, x2, x3, x4, x5, x6, x7)   do { \
+    x4 ^= x1; \
+    x5 ^= x2; \
+    x6 ^= x3 ^ x0; \
+    x7 ^= x0; \
+    x0 ^= x5; \
+    x1 ^= x6; \
+    x2 ^= x7 ^ x4; \
+    x3 ^= x4; \
+  } while (0)
+
+static const __constant ulong C[] =
+{
+	0x67F815DFA2DED572UL, 0x571523B70A15847BUL, 0xF6875A4D90D6AB81UL, 0x402BD1C3C54F9F4EUL, 
+	0x9CFA455CE03A98EAUL, 0x9A99B26699D2C503UL, 0x8A53BBF2B4960266UL, 0x31A2DB881A1456B5UL, 
+	0xDB0E199A5C5AA303UL, 0x1044C1870AB23F40UL, 0x1D959E848019051CUL, 0xDCCDE75EADEB336FUL, 
+	0x416BBF029213BA10UL, 0xD027BBF7156578DCUL, 0x5078AA3739812C0AUL, 0xD3910041D2BF1A3FUL, 
+	0x907ECCF60D5A2D42UL, 0xCE97C0929C9F62DDUL, 0xAC442BC70BA75C18UL, 0x23FCC663D665DFD1UL, 
+	0x1AB8E09E036C6E97UL, 0xA8EC6C447E450521UL, 0xFA618E5DBB03F1EEUL, 0x97818394B29796FDUL, 
+	0x2F3003DB37858E4AUL, 0x956A9FFB2D8D672AUL, 0x6C69B8F88173FE8AUL, 0x14427FC04672C78AUL, 
+	0xC45EC7BD8F15F4C5UL, 0x80BB118FA76F4475UL, 0xBC88E4AEB775DE52UL, 0xF4A3A6981E00B882UL, 
+	0x1563A3A9338FF48EUL, 0x89F9B7D524565FAAUL, 0xFDE05A7C20EDF1B6UL, 0x362C42065AE9CA36UL, 
+	0x3D98FE4E433529CEUL, 0xA74B9A7374F93A53UL, 0x86814E6F591FF5D0UL, 0x9F5AD8AF81AD9D0EUL, 
+	0x6A6234EE670605A7UL, 0x2717B96EBE280B8BUL, 0x3F1080C626077447UL, 0x7B487EC66F7EA0E0UL, 
+	0xC0A4F84AA50A550DUL, 0x9EF18E979FE7E391UL, 0xD48D605081727686UL, 0x62B0E5F3415A9E7EUL, 
+	0x7A205440EC1F9FFCUL, 0x84C9F4CE001AE4E3UL, 0xD895FA9DF594D74FUL, 0xA554C324117E2E55UL, 
+	0x286EFEBD2872DF5BUL, 0xB2C4A50FE27FF578UL, 0x2ED349EEEF7C8905UL, 0x7F5928EB85937E44UL, 
+	0x4A3124B337695F70UL, 0x65E4D61DF128865EUL, 0xE720B95104771BC7UL, 0x8A87D423E843FE74UL, 
+	0xF2947692A3E8297DUL, 0xC1D9309B097ACBDDUL, 0xE01BDC5BFB301B1DUL, 0xBF829CF24F4924DAUL, 
+	0xFFBF70B431BAE7A4UL, 0x48BCF8DE0544320DUL, 0x39D3BB5332FCAE3BUL, 0xA08B29E0C1C39F45UL, 
+	0x0F09AEF7FD05C9E5UL, 0x34F1904212347094UL, 0x95ED44E301B771A2UL, 0x4A982F4F368E3BE9UL, 
+	0x15F66CA0631D4088UL, 0xFFAF52874B44C147UL, 0x30C60AE2F14ABB7EUL, 0xE68C6ECCC5B67046UL, 
+	0x00CA4FBD56A4D5A4UL, 0xAE183EC84B849DDAUL, 0xADD1643045CE5773UL, 0x67255C1468CEA6E8UL, 
+	0x16E10ECBF28CDAA3UL, 0x9A99949A5806E933UL, 0x7B846FC220B2601FUL, 0x1885D1A07FACCED1UL, 
+	0xD319DD8DA15B5932UL, 0x46B4A5AAC01C9A50UL, 0xBA6B04E467633D9FUL, 0x7EEE560BAB19CAF6UL, 
+	0x742128A9EA79B11FUL, 0xEE51363B35F7BDE9UL, 0x76D350755AAC571DUL, 0x01707DA3FEC2463AUL, 
+	0x42D8A498AFC135F7UL, 0x79676B9E20ECED78UL, 0xA8DB3AEA15638341UL, 0x832C83324D3BC3FAUL, 
+	0xF347271C1F3B40A7UL, 0x9A762DB734F04059UL, 0xFD4F21D26C4E3EE7UL, 0xEF5957DC398DFDB8UL, 
+	0xDAEB492B490C9B8DUL, 0x0D70F36849D7A25BUL, 0x84558D7AD0AE3B7DUL, 0x658EF8E4F0E9A5F5UL, 
+	0x533B1036F4A2B8A0UL, 0x5AEC3E759E07A80CUL, 0x4F88E85692946891UL, 0x4CBCBAF8555CB05BUL, 
+	0x7B9487F3993BBBE3UL, 0x5D1C6B72D6F4DA75UL, 0x6DB334DC28ACAE64UL, 0x71DB28B850A5346CUL, 
+	0x2A518D10F2E261F8UL, 0xFC75DD593364DBE3UL, 0xA23FCE43F1BCAC1CUL, 0xB043E8023CD1BB67UL, 
+	0x75A12988CA5B0A33UL, 0x5C5316B44D19347FUL, 0x1E4D790EC3943B92UL, 0x3FAFEEB6D7757479UL, 
+	0x21391ABEF7D4A8EAUL, 0x5127234C097EF45CUL, 0xD23C32BA5324A326UL, 0xADD5A66D4A17A344UL, 
+	0x08C9F2AFA63E1DB5UL, 0x563C6B91983D5983UL, 0x4D608672A17CF84CUL, 0xF6C76E08CC3EE246UL, 
+	0x5E76BCB1B333982FUL, 0x2AE6C4EFA566D62BUL, 0x36D4C1BEE8B6F406UL, 0x6321EFBC1582EE74UL, 
+	0x69C953F40D4EC1FDUL, 0x26585806C45A7DA7UL, 0x16FAE0061614C17EUL, 0x3F9D63283DAF907EUL, 
+	0x0CD29B00E3F2C9D2UL, 0x300CD4B730CEAA5FUL, 0x9832E0F216512A74UL, 0x9AF8CEE3D830EB0DUL, 
+	0x9279F1B57B9EC54BUL, 0xD36886046EE651FFUL, 0x316796E6574D239BUL, 0x05750A17F3A6E6CCUL, 
+	0xCE6C3213D98176B1UL, 0x62A205F88452173CUL, 0x47154778B3CB2BF4UL, 0x486A9323825446FFUL, 
+	0x65655E4E0758DF38UL, 0x8E5086FC897CFCF2UL, 0x86CA0BD0442E7031UL, 0x4E477830A20940F0UL, 
+	0x8338F7D139EEA065UL, 0xBD3A2CE437E95EF7UL, 0x6FF8130126B29721UL, 0xE7DE9FEFD1ED44A3UL, 
+	0xD992257615DFA08BUL, 0xBE42DC12F6F7853CUL, 0x7EB027AB7CECA7D8UL, 0xDEA83EAADA7D8D53UL, 
+	0xD86902BD93CE25AAUL, 0xF908731AFD43F65AUL, 0xA5194A17DAEF5FC0UL, 0x6A21FD4C33664D97UL, 
+	0x701541DB3198B435UL, 0x9B54CDEDBB0F1EEAUL, 0x72409751A163D09AUL, 0xE26F4791BF9D75F6UL
+};
+
+#define Ceven_hi(r)   (C[((r) << 2) + 0])
+#define Ceven_lo(r)   (C[((r) << 2) + 1])
+#define Codd_hi(r)    (C[((r) << 2) + 2])
+#define Codd_lo(r)    (C[((r) << 2) + 3])
+
+#define S(x0, x1, x2, x3, cb, r)   do { \
+    Sb(x0 ## h, x1 ## h, x2 ## h, x3 ## h, cb ## hi(r)); \
+    Sb(x0 ## l, x1 ## l, x2 ## l, x3 ## l, cb ## lo(r)); \
+  } while (0)
+
+#define L(x0, x1, x2, x3, x4, x5, x6, x7)   do { \
+    Lb(x0 ## h, x1 ## h, x2 ## h, x3 ## h, \
+      x4 ## h, x5 ## h, x6 ## h, x7 ## h); \
+    Lb(x0 ## l, x1 ## l, x2 ## l, x3 ## l, \
+      x4 ## l, x5 ## l, x6 ## l, x7 ## l); \
+  } while (0)
+
+#define Wz(x, c, n)   do { \
+    sph_u64 t = (x ## h & (c)) << (n); \
+    x ## h = ((x ## h >> (n)) & (c)) | t; \
+    t = (x ## l & (c)) << (n); \
+    x ## l = ((x ## l >> (n)) & (c)) | t; \
+  } while (0)
+
+#define W0(x)   Wz(x, SPH_C64(0x5555555555555555),  1)
+#define W1(x)   Wz(x, SPH_C64(0x3333333333333333),  2)
+#define W2(x)   Wz(x, SPH_C64(0x0F0F0F0F0F0F0F0F),  4)
+#define W3(x)   Wz(x, SPH_C64(0x00FF00FF00FF00FF),  8)
+#define W4(x)   Wz(x, SPH_C64(0x0000FFFF0000FFFF), 16)
+#define W5(x)   Wz(x, SPH_C64(0x00000000FFFFFFFF), 32)
+#define W6(x)   do { \
+    sph_u64 t = x ## h; \
+    x ## h = x ## l; \
+    x ## l = t; \
+  } while (0)
+
+#define SL(ro)   SLu(r + ro, ro)
+
+#define SLu(r, ro)   do { \
+    S(h0, h2, h4, h6, Ceven_, r); \
+    S(h1, h3, h5, h7, Codd_, r); \
+    L(h0, h2, h4, h6, h1, h3, h5, h7); \
+    W ## ro(h1); \
+    W ## ro(h3); \
+    W ## ro(h5); \
+    W ## ro(h7); \
+  } while (0)
+
+#if SPH_SMALL_FOOTPRINT_JH
+
+/*
+ * The "small footprint" 64-bit version just uses a partially unrolled
+ * loop.
+ */
+
+#define E8   do { \
+    unsigned r; \
+    for (r = 0; r < 42; r += 7) { \
+      SL(0); \
+      SL(1); \
+      SL(2); \
+      SL(3); \
+      SL(4); \
+      SL(5); \
+      SL(6); \
+    } \
+  } while (0)
+
+#else
+
+/*
+ * On a "true 64-bit" architecture, we can unroll at will.
+ */
+
+#define E8   do { \
+    SLu( 0, 0); \
+    SLu( 1, 1); \
+    SLu( 2, 2); \
+    SLu( 3, 3); \
+    SLu( 4, 4); \
+    SLu( 5, 5); \
+    SLu( 6, 6); \
+    SLu( 7, 0); \
+    SLu( 8, 1); \
+    SLu( 9, 2); \
+    SLu(10, 3); \
+    SLu(11, 4); \
+    SLu(12, 5); \
+    SLu(13, 6); \
+    SLu(14, 0); \
+    SLu(15, 1); \
+    SLu(16, 2); \
+    SLu(17, 3); \
+    SLu(18, 4); \
+    SLu(19, 5); \
+    SLu(20, 6); \
+    SLu(21, 0); \
+    SLu(22, 1); \
+    SLu(23, 2); \
+    SLu(24, 3); \
+    SLu(25, 4); \
+    SLu(26, 5); \
+    SLu(27, 6); \
+    SLu(28, 0); \
+    SLu(29, 1); \
+    SLu(30, 2); \
+    SLu(31, 3); \
+    SLu(32, 4); \
+    SLu(33, 5); \
+    SLu(34, 6); \
+    SLu(35, 0); \
+    SLu(36, 1); \
+    SLu(37, 2); \
+    SLu(38, 3); \
+    SLu(39, 4); \
+    SLu(40, 5); \
+    SLu(41, 6); \
+  } while (0)
+
+#endif
+
+__constant static const int sigma[16][16] = {
+		{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 },
+		{ 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3 },
+		{ 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4 },
+		{ 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8 },
+		{ 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13 },
+		{ 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9 },
+		{ 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11 },
+		{ 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10 },
+		{ 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5 },
+		{ 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0 },
+		{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 },
+		{ 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3 },
+		{ 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4 },
+		{ 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8 },
+		{ 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13 },
+		{ 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9 }
+};
+
+
+__constant static const sph_u32  c_IV256[8] = {
+	0x6A09E667, 0xBB67AE85,
+	0x3C6EF372, 0xA54FF53A,
+	0x510E527F, 0x9B05688C,
+	0x1F83D9AB, 0x5BE0CD19
+};
+
+/* Second part (64-80) msg never change, store it */
+__constant static const sph_u32  c_Padding[16] = {
+	0, 0, 0, 0,
+	0x80000000, 0, 0, 0,
+	0, 0, 0, 0,
+	0, 1, 0, 640,
+};
+__constant static const sph_u32  c_u256[16] = {
+	0x243F6A88, 0x85A308D3,
+	0x13198A2E, 0x03707344,
+	0xA4093822, 0x299F31D0,
+	0x082EFA98, 0xEC4E6C89,
+	0x452821E6, 0x38D01377,
+	0xBE5466CF, 0x34E90C6C,
+	0xC0AC29B7, 0xC97C50DD,
+	0x3F84D5B5, 0xB5470917
+};
+
+#define GS(a,b,c,d,x) { \
+	const sph_u32 idx1 = sigma[r][x]; \
+	const sph_u32 idx2 = sigma[r][x+1]; \
+	v[a] += (m[idx1] ^ c_u256[idx2]) + v[b]; \
+	v[d] ^= v[a]; \
+    v[d] = rotate(v[d], 16U); \
+	v[c] += v[d]; \
+    v[b] ^= v[c]; \
+	v[b] = rotate(v[b], 20U); \
+\
+	v[a] += (m[idx2] ^ c_u256[idx1]) + v[b]; \
+    v[d] ^= v[a]; \
+	v[d] = rotate(v[d], 24U); \
+	v[c] += v[d]; \
+    v[b] ^= v[c]; \
+	v[b] = rotate(v[b], 25U); \
+}
+
+#define SPH_C64(x)	x
+#define SPH_ROTL64(x, y)	rotate((x), (ulong)(y))
+
+
+#define C64e(x)     ((SPH_C64(x) >> 56) \
+                    | ((SPH_C64(x) >> 40) & SPH_C64(0x000000000000FF00)) \
+                    | ((SPH_C64(x) >> 24) & SPH_C64(0x0000000000FF0000)) \
+                    | ((SPH_C64(x) >>  8) & SPH_C64(0x00000000FF000000)) \
+                    | ((SPH_C64(x) <<  8) & SPH_C64(0x000000FF00000000)) \
+                    | ((SPH_C64(x) << 24) & SPH_C64(0x0000FF0000000000)) \
+                    | ((SPH_C64(x) << 40) & SPH_C64(0x00FF000000000000)) \
+                    | ((SPH_C64(x) << 56) & SPH_C64(0xFF00000000000000)))
+
+#define B64_0(x)    ((x) & 0xFF)
+#define B64_1(x)    (((x) >> 8) & 0xFF)
+#define B64_2(x)    (((x) >> 16) & 0xFF)
+#define B64_3(x)    (((x) >> 24) & 0xFF)
+#define B64_4(x)    (((x) >> 32) & 0xFF)
+#define B64_5(x)    (((x) >> 40) & 0xFF)
+#define B64_6(x)    (((x) >> 48) & 0xFF)
+#define B64_7(x)    ((x) >> 56)
+#define R64         SPH_ROTL64
+#define PC64(j, r)  ((sph_u64)((j) + (r)))
+#define QC64(j, r)  (((sph_u64)(r) << 56) ^ (~((sph_u64)(j) << 56)))
+
+static const __constant ulong T0_G[] =
+{
+	0xc6a597f4a5f432c6UL, 0xf884eb9784976ff8UL, 0xee99c7b099b05eeeUL, 0xf68df78c8d8c7af6UL, 
+	0xff0de5170d17e8ffUL, 0xd6bdb7dcbddc0ad6UL, 0xdeb1a7c8b1c816deUL, 0x915439fc54fc6d91UL, 
+	0x6050c0f050f09060UL, 0x0203040503050702UL, 0xcea987e0a9e02eceUL, 0x567dac877d87d156UL, 
+	0xe719d52b192bcce7UL, 0xb56271a662a613b5UL, 0x4de69a31e6317c4dUL, 0xec9ac3b59ab559ecUL, 
+	0x8f4505cf45cf408fUL, 0x1f9d3ebc9dbca31fUL, 0x894009c040c04989UL, 0xfa87ef92879268faUL, 
+	0xef15c53f153fd0efUL, 0xb2eb7f26eb2694b2UL, 0x8ec90740c940ce8eUL, 0xfb0bed1d0b1de6fbUL, 
+	0x41ec822fec2f6e41UL, 0xb3677da967a91ab3UL, 0x5ffdbe1cfd1c435fUL, 0x45ea8a25ea256045UL, 
+	0x23bf46dabfdaf923UL, 0x53f7a602f7025153UL, 0xe496d3a196a145e4UL, 0x9b5b2ded5bed769bUL, 
+	0x75c2ea5dc25d2875UL, 0xe11cd9241c24c5e1UL, 0x3dae7ae9aee9d43dUL, 0x4c6a98be6abef24cUL, 
+	0x6c5ad8ee5aee826cUL, 0x7e41fcc341c3bd7eUL, 0xf502f1060206f3f5UL, 0x834f1dd14fd15283UL, 
+	0x685cd0e45ce48c68UL, 0x51f4a207f4075651UL, 0xd134b95c345c8dd1UL, 0xf908e9180818e1f9UL, 
+	0xe293dfae93ae4ce2UL, 0xab734d9573953eabUL, 0x6253c4f553f59762UL, 0x2a3f54413f416b2aUL, 
+	0x080c10140c141c08UL, 0x955231f652f66395UL, 0x46658caf65afe946UL, 0x9d5e21e25ee27f9dUL, 
+	0x3028607828784830UL, 0x37a16ef8a1f8cf37UL, 0x0a0f14110f111b0aUL, 0x2fb55ec4b5c4eb2fUL, 
+	0x0e091c1b091b150eUL, 0x2436485a365a7e24UL, 0x1b9b36b69bb6ad1bUL, 0xdf3da5473d4798dfUL, 
+	0xcd26816a266aa7cdUL, 0x4e699cbb69bbf54eUL, 0x7fcdfe4ccd4c337fUL, 0xea9fcfba9fba50eaUL, 
+	0x121b242d1b2d3f12UL, 0x1d9e3ab99eb9a41dUL, 0x5874b09c749cc458UL, 0x342e68722e724634UL, 
+	0x362d6c772d774136UL, 0xdcb2a3cdb2cd11dcUL, 0xb4ee7329ee299db4UL, 0x5bfbb616fb164d5bUL, 
+	0xa4f65301f601a5a4UL, 0x764decd74dd7a176UL, 0xb76175a361a314b7UL, 0x7dcefa49ce49347dUL, 
+	0x527ba48d7b8ddf52UL, 0xdd3ea1423e429fddUL, 0x5e71bc937193cd5eUL, 0x139726a297a2b113UL, 
+	0xa6f55704f504a2a6UL, 0xb96869b868b801b9UL, 0x0000000000000000UL, 0xc12c99742c74b5c1UL, 
+	0x406080a060a0e040UL, 0xe31fdd211f21c2e3UL, 0x79c8f243c8433a79UL, 0xb6ed772ced2c9ab6UL, 
+	0xd4beb3d9bed90dd4UL, 0x8d4601ca46ca478dUL, 0x67d9ce70d9701767UL, 0x724be4dd4bddaf72UL, 
+	0x94de3379de79ed94UL, 0x98d42b67d467ff98UL, 0xb0e87b23e82393b0UL, 0x854a11de4ade5b85UL, 
+	0xbb6b6dbd6bbd06bbUL, 0xc52a917e2a7ebbc5UL, 0x4fe59e34e5347b4fUL, 0xed16c13a163ad7edUL, 
+	0x86c51754c554d286UL, 0x9ad72f62d762f89aUL, 0x6655ccff55ff9966UL, 0x119422a794a7b611UL, 
+	0x8acf0f4acf4ac08aUL, 0xe910c9301030d9e9UL, 0x0406080a060a0e04UL, 0xfe81e798819866feUL, 
+	0xa0f05b0bf00baba0UL, 0x7844f0cc44ccb478UL, 0x25ba4ad5bad5f025UL, 0x4be3963ee33e754bUL, 
+	0xa2f35f0ef30eaca2UL, 0x5dfeba19fe19445dUL, 0x80c01b5bc05bdb80UL, 0x058a0a858a858005UL, 
+	0x3fad7eecadecd33fUL, 0x21bc42dfbcdffe21UL, 0x7048e0d848d8a870UL, 0xf104f90c040cfdf1UL, 
+	0x63dfc67adf7a1963UL, 0x77c1ee58c1582f77UL, 0xaf75459f759f30afUL, 0x426384a563a5e742UL, 
+	0x2030405030507020UL, 0xe51ad12e1a2ecbe5UL, 0xfd0ee1120e12effdUL, 0xbf6d65b76db708bfUL, 
+	0x814c19d44cd45581UL, 0x1814303c143c2418UL, 0x26354c5f355f7926UL, 0xc32f9d712f71b2c3UL, 
+	0xbee16738e13886beUL, 0x35a26afda2fdc835UL, 0x88cc0b4fcc4fc788UL, 0x2e395c4b394b652eUL, 
+	0x93573df957f96a93UL, 0x55f2aa0df20d5855UL, 0xfc82e39d829d61fcUL, 0x7a47f4c947c9b37aUL, 
+	0xc8ac8befacef27c8UL, 0xbae76f32e73288baUL, 0x322b647d2b7d4f32UL, 0xe695d7a495a442e6UL, 
+	0xc0a09bfba0fb3bc0UL, 0x199832b398b3aa19UL, 0x9ed12768d168f69eUL, 0xa37f5d817f8122a3UL, 
+	0x446688aa66aaee44UL, 0x547ea8827e82d654UL, 0x3bab76e6abe6dd3bUL, 0x0b83169e839e950bUL, 
+	0x8cca0345ca45c98cUL, 0xc729957b297bbcc7UL, 0x6bd3d66ed36e056bUL, 0x283c50443c446c28UL, 
+	0xa779558b798b2ca7UL, 0xbce2633de23d81bcUL, 0x161d2c271d273116UL, 0xad76419a769a37adUL, 
+	0xdb3bad4d3b4d96dbUL, 0x6456c8fa56fa9e64UL, 0x744ee8d24ed2a674UL, 0x141e28221e223614UL, 
+	0x92db3f76db76e492UL, 0x0c0a181e0a1e120cUL, 0x486c90b46cb4fc48UL, 0xb8e46b37e4378fb8UL, 
+	0x9f5d25e75de7789fUL, 0xbd6e61b26eb20fbdUL, 0x43ef862aef2a6943UL, 0xc4a693f1a6f135c4UL, 
+	0x39a872e3a8e3da39UL, 0x31a462f7a4f7c631UL, 0xd337bd5937598ad3UL, 0xf28bff868b8674f2UL, 
+	0xd532b156325683d5UL, 0x8b430dc543c54e8bUL, 0x6e59dceb59eb856eUL, 0xdab7afc2b7c218daUL, 
+	0x018c028f8c8f8e01UL, 0xb16479ac64ac1db1UL, 0x9cd2236dd26df19cUL, 0x49e0923be03b7249UL, 
+	0xd8b4abc7b4c71fd8UL, 0xacfa4315fa15b9acUL, 0xf307fd090709faf3UL, 0xcf25856f256fa0cfUL, 
+	0xcaaf8feaafea20caUL, 0xf48ef3898e897df4UL, 0x47e98e20e9206747UL, 0x1018202818283810UL, 
+	0x6fd5de64d5640b6fUL, 0xf088fb83888373f0UL, 0x4a6f94b16fb1fb4aUL, 0x5c72b8967296ca5cUL, 
+	0x3824706c246c5438UL, 0x57f1ae08f1085f57UL, 0x73c7e652c7522173UL, 0x975135f351f36497UL, 
+	0xcb238d652365aecbUL, 0xa17c59847c8425a1UL, 0xe89ccbbf9cbf57e8UL, 0x3e217c6321635d3eUL, 
+	0x96dd377cdd7cea96UL, 0x61dcc27fdc7f1e61UL, 0x0d861a9186919c0dUL, 0x0f851e9485949b0fUL, 
+	0xe090dbab90ab4be0UL, 0x7c42f8c642c6ba7cUL, 0x71c4e257c4572671UL, 0xccaa83e5aae529ccUL, 
+	0x90d83b73d873e390UL, 0x06050c0f050f0906UL, 0xf701f5030103f4f7UL, 0x1c12383612362a1cUL, 
+	0xc2a39ffea3fe3cc2UL, 0x6a5fd4e15fe18b6aUL, 0xaef94710f910beaeUL, 0x69d0d26bd06b0269UL, 
+	0x17912ea891a8bf17UL, 0x995829e858e87199UL, 0x3a2774692769533aUL, 0x27b94ed0b9d0f727UL, 
+	0xd938a948384891d9UL, 0xeb13cd351335deebUL, 0x2bb356ceb3cee52bUL, 0x2233445533557722UL, 
+	0xd2bbbfd6bbd604d2UL, 0xa9704990709039a9UL, 0x07890e8089808707UL, 0x33a766f2a7f2c133UL, 
+	0x2db65ac1b6c1ec2dUL, 0x3c22786622665a3cUL, 0x15922aad92adb815UL, 0xc92089602060a9c9UL, 
+	0x874915db49db5c87UL, 0xaaff4f1aff1ab0aaUL, 0x5078a0887888d850UL, 0xa57a518e7a8e2ba5UL, 
+	0x038f068a8f8a8903UL, 0x59f8b213f8134a59UL, 0x0980129b809b9209UL, 0x1a1734391739231aUL, 
+	0x65daca75da751065UL, 0xd731b553315384d7UL, 0x84c61351c651d584UL, 0xd0b8bbd3b8d303d0UL, 
+	0x82c31f5ec35edc82UL, 0x29b052cbb0cbe229UL, 0x5a77b4997799c35aUL, 0x1e113c3311332d1eUL, 
+	0x7bcbf646cb463d7bUL, 0xa8fc4b1ffc1fb7a8UL, 0x6dd6da61d6610c6dUL, 0x2c3a584e3a4e622cUL
+};
+
+static const __constant ulong T4_G[] =
+{
+	0xA5F432C6C6A597F4UL, 0x84976FF8F884EB97UL, 0x99B05EEEEE99C7B0UL, 0x8D8C7AF6F68DF78CUL, 
+	0x0D17E8FFFF0DE517UL, 0xBDDC0AD6D6BDB7DCUL, 0xB1C816DEDEB1A7C8UL, 0x54FC6D91915439FCUL, 
+	0x50F090606050C0F0UL, 0x0305070202030405UL, 0xA9E02ECECEA987E0UL, 0x7D87D156567DAC87UL, 
+	0x192BCCE7E719D52BUL, 0x62A613B5B56271A6UL, 0xE6317C4D4DE69A31UL, 0x9AB559ECEC9AC3B5UL, 
+	0x45CF408F8F4505CFUL, 0x9DBCA31F1F9D3EBCUL, 0x40C04989894009C0UL, 0x879268FAFA87EF92UL, 
+	0x153FD0EFEF15C53FUL, 0xEB2694B2B2EB7F26UL, 0xC940CE8E8EC90740UL, 0x0B1DE6FBFB0BED1DUL, 
+	0xEC2F6E4141EC822FUL, 0x67A91AB3B3677DA9UL, 0xFD1C435F5FFDBE1CUL, 0xEA25604545EA8A25UL, 
+	0xBFDAF92323BF46DAUL, 0xF702515353F7A602UL, 0x96A145E4E496D3A1UL, 0x5BED769B9B5B2DEDUL, 
+	0xC25D287575C2EA5DUL, 0x1C24C5E1E11CD924UL, 0xAEE9D43D3DAE7AE9UL, 0x6ABEF24C4C6A98BEUL, 
+	0x5AEE826C6C5AD8EEUL, 0x41C3BD7E7E41FCC3UL, 0x0206F3F5F502F106UL, 0x4FD15283834F1DD1UL, 
+	0x5CE48C68685CD0E4UL, 0xF407565151F4A207UL, 0x345C8DD1D134B95CUL, 0x0818E1F9F908E918UL, 
+	0x93AE4CE2E293DFAEUL, 0x73953EABAB734D95UL, 0x53F597626253C4F5UL, 0x3F416B2A2A3F5441UL, 
+	0x0C141C08080C1014UL, 0x52F66395955231F6UL, 0x65AFE94646658CAFUL, 0x5EE27F9D9D5E21E2UL, 
+	0x2878483030286078UL, 0xA1F8CF3737A16EF8UL, 0x0F111B0A0A0F1411UL, 0xB5C4EB2F2FB55EC4UL, 
+	0x091B150E0E091C1BUL, 0x365A7E242436485AUL, 0x9BB6AD1B1B9B36B6UL, 0x3D4798DFDF3DA547UL, 
+	0x266AA7CDCD26816AUL, 0x69BBF54E4E699CBBUL, 0xCD4C337F7FCDFE4CUL, 0x9FBA50EAEA9FCFBAUL, 
+	0x1B2D3F12121B242DUL, 0x9EB9A41D1D9E3AB9UL, 0x749CC4585874B09CUL, 0x2E724634342E6872UL, 
+	0x2D774136362D6C77UL, 0xB2CD11DCDCB2A3CDUL, 0xEE299DB4B4EE7329UL, 0xFB164D5B5BFBB616UL, 
+	0xF601A5A4A4F65301UL, 0x4DD7A176764DECD7UL, 0x61A314B7B76175A3UL, 0xCE49347D7DCEFA49UL, 
+	0x7B8DDF52527BA48DUL, 0x3E429FDDDD3EA142UL, 0x7193CD5E5E71BC93UL, 0x97A2B113139726A2UL, 
+	0xF504A2A6A6F55704UL, 0x68B801B9B96869B8UL, 0x0000000000000000UL, 0x2C74B5C1C12C9974UL, 
+	0x60A0E040406080A0UL, 0x1F21C2E3E31FDD21UL, 0xC8433A7979C8F243UL, 0xED2C9AB6B6ED772CUL, 
+	0xBED90DD4D4BEB3D9UL, 0x46CA478D8D4601CAUL, 0xD970176767D9CE70UL, 0x4BDDAF72724BE4DDUL, 
+	0xDE79ED9494DE3379UL, 0xD467FF9898D42B67UL, 0xE82393B0B0E87B23UL, 0x4ADE5B85854A11DEUL, 
+	0x6BBD06BBBB6B6DBDUL, 0x2A7EBBC5C52A917EUL, 0xE5347B4F4FE59E34UL, 0x163AD7EDED16C13AUL, 
+	0xC554D28686C51754UL, 0xD762F89A9AD72F62UL, 0x55FF99666655CCFFUL, 0x94A7B611119422A7UL, 
+	0xCF4AC08A8ACF0F4AUL, 0x1030D9E9E910C930UL, 0x060A0E040406080AUL, 0x819866FEFE81E798UL, 
+	0xF00BABA0A0F05B0BUL, 0x44CCB4787844F0CCUL, 0xBAD5F02525BA4AD5UL, 0xE33E754B4BE3963EUL, 
+	0xF30EACA2A2F35F0EUL, 0xFE19445D5DFEBA19UL, 0xC05BDB8080C01B5BUL, 0x8A858005058A0A85UL, 
+	0xADECD33F3FAD7EECUL, 0xBCDFFE2121BC42DFUL, 0x48D8A8707048E0D8UL, 0x040CFDF1F104F90CUL, 
+	0xDF7A196363DFC67AUL, 0xC1582F7777C1EE58UL, 0x759F30AFAF75459FUL, 0x63A5E742426384A5UL, 
+	0x3050702020304050UL, 0x1A2ECBE5E51AD12EUL, 0x0E12EFFDFD0EE112UL, 0x6DB708BFBF6D65B7UL, 
+	0x4CD45581814C19D4UL, 0x143C24181814303CUL, 0x355F792626354C5FUL, 0x2F71B2C3C32F9D71UL, 
+	0xE13886BEBEE16738UL, 0xA2FDC83535A26AFDUL, 0xCC4FC78888CC0B4FUL, 0x394B652E2E395C4BUL, 
+	0x57F96A9393573DF9UL, 0xF20D585555F2AA0DUL, 0x829D61FCFC82E39DUL, 0x47C9B37A7A47F4C9UL, 
+	0xACEF27C8C8AC8BEFUL, 0xE73288BABAE76F32UL, 0x2B7D4F32322B647DUL, 0x95A442E6E695D7A4UL, 
+	0xA0FB3BC0C0A09BFBUL, 0x98B3AA19199832B3UL, 0xD168F69E9ED12768UL, 0x7F8122A3A37F5D81UL, 
+	0x66AAEE44446688AAUL, 0x7E82D654547EA882UL, 0xABE6DD3B3BAB76E6UL, 0x839E950B0B83169EUL, 
+	0xCA45C98C8CCA0345UL, 0x297BBCC7C729957BUL, 0xD36E056B6BD3D66EUL, 0x3C446C28283C5044UL, 
+	0x798B2CA7A779558BUL, 0xE23D81BCBCE2633DUL, 0x1D273116161D2C27UL, 0x769A37ADAD76419AUL, 
+	0x3B4D96DBDB3BAD4DUL, 0x56FA9E646456C8FAUL, 0x4ED2A674744EE8D2UL, 0x1E223614141E2822UL, 
+	0xDB76E49292DB3F76UL, 0x0A1E120C0C0A181EUL, 0x6CB4FC48486C90B4UL, 0xE4378FB8B8E46B37UL, 
+	0x5DE7789F9F5D25E7UL, 0x6EB20FBDBD6E61B2UL, 0xEF2A694343EF862AUL, 0xA6F135C4C4A693F1UL, 
+	0xA8E3DA3939A872E3UL, 0xA4F7C63131A462F7UL, 0x37598AD3D337BD59UL, 0x8B8674F2F28BFF86UL, 
+	0x325683D5D532B156UL, 0x43C54E8B8B430DC5UL, 0x59EB856E6E59DCEBUL, 0xB7C218DADAB7AFC2UL, 
+	0x8C8F8E01018C028FUL, 0x64AC1DB1B16479ACUL, 0xD26DF19C9CD2236DUL, 0xE03B724949E0923BUL, 
+	0xB4C71FD8D8B4ABC7UL, 0xFA15B9ACACFA4315UL, 0x0709FAF3F307FD09UL, 0x256FA0CFCF25856FUL, 
+	0xAFEA20CACAAF8FEAUL, 0x8E897DF4F48EF389UL, 0xE920674747E98E20UL, 0x1828381010182028UL, 
+	0xD5640B6F6FD5DE64UL, 0x888373F0F088FB83UL, 0x6FB1FB4A4A6F94B1UL, 0x7296CA5C5C72B896UL, 
+	0x246C54383824706CUL, 0xF1085F5757F1AE08UL, 0xC752217373C7E652UL, 0x51F36497975135F3UL, 
+	0x2365AECBCB238D65UL, 0x7C8425A1A17C5984UL, 0x9CBF57E8E89CCBBFUL, 0x21635D3E3E217C63UL, 
+	0xDD7CEA9696DD377CUL, 0xDC7F1E6161DCC27FUL, 0x86919C0D0D861A91UL, 0x85949B0F0F851E94UL, 
+	0x90AB4BE0E090DBABUL, 0x42C6BA7C7C42F8C6UL, 0xC457267171C4E257UL, 0xAAE529CCCCAA83E5UL, 
+	0xD873E39090D83B73UL, 0x050F090606050C0FUL, 0x0103F4F7F701F503UL, 0x12362A1C1C123836UL, 
+	0xA3FE3CC2C2A39FFEUL, 0x5FE18B6A6A5FD4E1UL, 0xF910BEAEAEF94710UL, 0xD06B026969D0D26BUL, 
+	0x91A8BF1717912EA8UL, 0x58E87199995829E8UL, 0x2769533A3A277469UL, 0xB9D0F72727B94ED0UL, 
+	0x384891D9D938A948UL, 0x1335DEEBEB13CD35UL, 0xB3CEE52B2BB356CEUL, 0x3355772222334455UL, 
+	0xBBD604D2D2BBBFD6UL, 0x709039A9A9704990UL, 0x8980870707890E80UL, 0xA7F2C13333A766F2UL, 
+	0xB6C1EC2D2DB65AC1UL, 0x22665A3C3C227866UL, 0x92ADB81515922AADUL, 0x2060A9C9C9208960UL, 
+	0x49DB5C87874915DBUL, 0xFF1AB0AAAAFF4F1AUL, 0x7888D8505078A088UL, 0x7A8E2BA5A57A518EUL, 
+	0x8F8A8903038F068AUL, 0xF8134A5959F8B213UL, 0x809B92090980129BUL, 0x1739231A1A173439UL, 
+	0xDA75106565DACA75UL, 0x315384D7D731B553UL, 0xC651D58484C61351UL, 0xB8D303D0D0B8BBD3UL, 
+	0xC35EDC8282C31F5EUL, 0xB0CBE22929B052CBUL, 0x7799C35A5A77B499UL, 0x11332D1E1E113C33UL, 
+	0xCB463D7B7BCBF646UL, 0xFC1FB7A8A8FC4B1FUL, 0xD6610C6D6DD6DA61UL, 0x3A4E622C2C3A584EUL
+};
+
+#define RSTT(d, a, b0, b1, b2, b3, b4, b5, b6, b7)   do { \
+		t[d] = T0_G[B64_0(a[b0])] \
+			^ R64(T0_G[B64_1(a[b1])],  8) \
+			^ R64(T0_G[B64_2(a[b2])], 16) \
+			^ R64(T0_G[B64_3(a[b3])], 24) \
+			^ T4_G[B64_4(a[b4])] \
+			^ R64(T4_G[B64_5(a[b5])],  8) \
+			^ R64(T4_G[B64_6(a[b6])], 16) \
+			^ R64(T4_G[B64_7(a[b7])], 24); \
+		} while (0)
+
+#define ROUND_SMALL_P(a, r)   do { \
+		ulong t[8]; \
+		a[0] ^= PC64(0x00, r); \
+		a[1] ^= PC64(0x10, r); \
+		a[2] ^= PC64(0x20, r); \
+		a[3] ^= PC64(0x30, r); \
+		a[4] ^= PC64(0x40, r); \
+		a[5] ^= PC64(0x50, r); \
+		a[6] ^= PC64(0x60, r); \
+		a[7] ^= PC64(0x70, r); \
+		RSTT(0, a, 0, 1, 2, 3, 4, 5, 6, 7); \
+		RSTT(1, a, 1, 2, 3, 4, 5, 6, 7, 0); \
+		RSTT(2, a, 2, 3, 4, 5, 6, 7, 0, 1); \
+		RSTT(3, a, 3, 4, 5, 6, 7, 0, 1, 2); \
+		RSTT(4, a, 4, 5, 6, 7, 0, 1, 2, 3); \
+		RSTT(5, a, 5, 6, 7, 0, 1, 2, 3, 4); \
+		RSTT(6, a, 6, 7, 0, 1, 2, 3, 4, 5); \
+		RSTT(7, a, 7, 0, 1, 2, 3, 4, 5, 6); \
+		a[0] = t[0]; \
+		a[1] = t[1]; \
+		a[2] = t[2]; \
+		a[3] = t[3]; \
+		a[4] = t[4]; \
+		a[5] = t[5]; \
+		a[6] = t[6]; \
+		a[7] = t[7]; \
+		} while (0)
+
+#define ROUND_SMALL_Pf(a,r)   do { \
+		a[0] ^= PC64(0x00, r); \
+		a[1] ^= PC64(0x10, r); \
+		a[2] ^= PC64(0x20, r); \
+		a[3] ^= PC64(0x30, r); \
+		a[4] ^= PC64(0x40, r); \
+		a[5] ^= PC64(0x50, r); \
+		a[6] ^= PC64(0x60, r); \
+		a[7] ^= PC64(0x70, r); \
+		RSTT(7, a, 7, 0, 1, 2, 3, 4, 5, 6); \
+		a[7] = t[7]; \
+			} while (0)
+
+#define ROUND_SMALL_Q(a, r)   do { \
+		ulong t[8]; \
+		a[0] ^= QC64(0x00, r); \
+		a[1] ^= QC64(0x10, r); \
+		a[2] ^= QC64(0x20, r); \
+		a[3] ^= QC64(0x30, r); \
+		a[4] ^= QC64(0x40, r); \
+		a[5] ^= QC64(0x50, r); \
+		a[6] ^= QC64(0x60, r); \
+		a[7] ^= QC64(0x70, r); \
+		RSTT(0, a, 1, 3, 5, 7, 0, 2, 4, 6); \
+		RSTT(1, a, 2, 4, 6, 0, 1, 3, 5, 7); \
+		RSTT(2, a, 3, 5, 7, 1, 2, 4, 6, 0); \
+		RSTT(3, a, 4, 6, 0, 2, 3, 5, 7, 1); \
+		RSTT(4, a, 5, 7, 1, 3, 4, 6, 0, 2); \
+		RSTT(5, a, 6, 0, 2, 4, 5, 7, 1, 3); \
+		RSTT(6, a, 7, 1, 3, 5, 6, 0, 2, 4); \
+		RSTT(7, a, 0, 2, 4, 6, 7, 1, 3, 5); \
+		a[0] = t[0]; \
+		a[1] = t[1]; \
+		a[2] = t[2]; \
+		a[3] = t[3]; \
+		a[4] = t[4]; \
+		a[5] = t[5]; \
+		a[6] = t[6]; \
+		a[7] = t[7]; \
+		} while (0)
+
+#define PERM_SMALL_P(a)   do { \
+		for (int r = 0; r < 10; r ++) \
+			ROUND_SMALL_P(a, r); \
+		} while (0)
+
+#define PERM_SMALL_Pf(a)   do { \
+		for (int r = 0; r < 9; r ++) { \
+			ROUND_SMALL_P(a, r);} \
+            ROUND_SMALL_Pf(a,9); \
+			} while (0)
+
+#define PERM_SMALL_Q(a)   do { \
+		for (int r = 0; r < 10; r ++) \
+			ROUND_SMALL_Q(a, r); \
+		} while (0)
+
+
+inline uint get_reciprocal(uint a)
+{
+    const float a_hi = as_float((a >> 8) + ((126U + 31U) << 23));
+    const float a_lo = convert_float_rte(a & 0xFF);
+
+    const float r = native_recip(a_hi);
+    const float r_scaled = as_float(as_uint(r) + (64U << 23));
+
+    const float h = fma(a_lo, r, fma(a_hi, r, -1.0f));
+    return (as_uint(r) << 9) - convert_int_rte(h * r_scaled);
+}
+
+inline uint2 fast_div_v2(ulong a, uint b)
+{
+    const uint r = get_reciprocal(b);
+    const ulong k = mul_hi(as_uint2(a).s0, r) + ((ulong)(r) * as_uint2(a).s1) + a;
+
+    const uint q = as_uint2(k).s1;
+    long tmp = a - ((ulong)(q) * b);
+    ((int*)&tmp)[1] -= (as_uint2(k).s1 < as_uint2(a).s1) ? b : 0;
+
+    const int overshoot = ((int*)&tmp)[1] >> 31;
+    const int undershoot = as_int2(as_uint(b - 1) - tmp).s1 >> 31;
+    return (uint2)(q + overshoot - undershoot, as_uint2(tmp).s0 + (as_uint(overshoot) & b) - (as_uint(undershoot) & b));
+}
+
+inline uint fast_sqrt_v2(const ulong n1)
+{
+    float x = as_float((as_uint2(n1).s1 >> 9) + ((64U + 127U) << 23));
+
+    float x1 = native_rsqrt(x);
+    x = native_sqrt(x);
+
+    // The following line does x1 *= 4294967296.0f;
+    x1 = as_float(as_uint(x1) + (32U << 23));
+
+    const uint x0 = as_uint(x) - (158U << 23);
+    const long delta0 = n1 - (as_ulong((uint2)(mul24(x0, x0), mul_hi(x0, x0))) << 18);
+    const float delta = convert_float_rte(as_int2(delta0).s1) * x1;
+
+    uint result = (x0 << 10) + convert_int_rte(delta);
+    const uint s = result >> 1;
+    const uint b = result & 1;
+
+    const ulong x2 = (ulong)(s) * (s + b) + ((ulong)(result) << 32) - n1;
+    if ((long)(x2 + as_int(b - 1)) >= 0) --result;
+    if ((long)(x2 + 0x100000000UL + s) < 0) ++result;
+
+    return result;
+}
+
+static const __constant ulong keccakf_rndc[24] =
+{
+    0x0000000000000001, 0x0000000000008082, 0x800000000000808a,
+    0x8000000080008000, 0x000000000000808b, 0x0000000080000001,
+    0x8000000080008081, 0x8000000000008009, 0x000000000000008a,
+    0x0000000000000088, 0x0000000080008009, 0x000000008000000a,
+    0x000000008000808b, 0x800000000000008b, 0x8000000000008089,
+    0x8000000000008003, 0x8000000000008002, 0x8000000000000080,
+    0x000000000000800a, 0x800000008000000a, 0x8000000080008081,
+    0x8000000000008080, 0x0000000080000001, 0x8000000080008008
+};
+
+
+static const __constant uint keccakf_rotc[24] =
+{
+    1,  3,  6,  10, 15, 21, 28, 36, 45, 55, 2,  14,
+    27, 41, 56, 8,  25, 43, 62, 18, 39, 61, 20, 44
+};
+
+
+static const __constant uint keccakf_piln[24] =
+{
+    10, 7,  11, 17, 18, 3, 5,  16, 8,  21, 24, 4,
+    15, 23, 19, 13, 12, 2, 20, 14, 22, 9,  6,  1
+};
+
+
+void keccakf1600_1(ulong *st)
+{
+    int i, round;
+    ulong t, bc[5];
+
+    #pragma unroll 1
+    for (round = 0; round < 24; ++round) {
+        // Theta
+        bc[0] = st[0] ^ st[5] ^ st[10] ^ st[15] ^ st[20];
+        bc[1] = st[1] ^ st[6] ^ st[11] ^ st[16] ^ st[21];
+        bc[2] = st[2] ^ st[7] ^ st[12] ^ st[17] ^ st[22];
+        bc[3] = st[3] ^ st[8] ^ st[13] ^ st[18] ^ st[23];
+        bc[4] = st[4] ^ st[9] ^ st[14] ^ st[19] ^ st[24];
+
+        #pragma unroll 1
+        for (i = 0; i < 5; ++i) {
+            t = bc[(i + 4) % 5] ^ rotate(bc[(i + 1) % 5], 1UL);
+            st[i     ] ^= t;
+            st[i +  5] ^= t;
+            st[i + 10] ^= t;
+            st[i + 15] ^= t;
+            st[i + 20] ^= t;
+        }
+
+        // Rho Pi
+        t = st[1];
+        #pragma unroll 1
+        for (i = 0; i < 24; ++i) {
+            bc[0] = st[keccakf_piln[i]];
+            st[keccakf_piln[i]] = rotate(t, (ulong)keccakf_rotc[i]);
+            t = bc[0];
+        }
+
+        #pragma unroll 1
+        for (int i = 0; i < 25; i += 5) {
+            ulong tmp[5];
+
+            #pragma unroll 1
+            for (int x = 0; x < 5; ++x) {
+                tmp[x] = bitselect(st[i + x] ^ st[i + ((x + 2) % 5)], st[i + x], st[i + ((x + 1) % 5)]);
+            }
+
+            #pragma unroll 1
+            for (int x = 0; x < 5; ++x) {
+                st[i + x] = tmp[x];
+            }
+        }
+
+        //  Iota
+        st[0] ^= keccakf_rndc[round];
+    }
+}
+
+
+void keccakf1600_2(__local ulong *st)
+{
+    int i, round;
+    ulong t, bc[5];
+
+    #pragma unroll 1
+    for (round = 0; round < 24; ++round) {
+        bc[0] = st[0] ^ st[5] ^ st[10] ^ st[15] ^ st[20] ^ rotate(st[2] ^ st[7] ^ st[12] ^ st[17] ^ st[22], 1UL);
+        bc[1] = st[1] ^ st[6] ^ st[11] ^ st[16] ^ st[21] ^ rotate(st[3] ^ st[8] ^ st[13] ^ st[18] ^ st[23], 1UL);
+        bc[2] = st[2] ^ st[7] ^ st[12] ^ st[17] ^ st[22] ^ rotate(st[4] ^ st[9] ^ st[14] ^ st[19] ^ st[24], 1UL);
+        bc[3] = st[3] ^ st[8] ^ st[13] ^ st[18] ^ st[23] ^ rotate(st[0] ^ st[5] ^ st[10] ^ st[15] ^ st[20], 1UL);
+        bc[4] = st[4] ^ st[9] ^ st[14] ^ st[19] ^ st[24] ^ rotate(st[1] ^ st[6] ^ st[11] ^ st[16] ^ st[21], 1UL);
+
+        st[0]  ^= bc[4];
+        st[5]  ^= bc[4];
+        st[10] ^= bc[4];
+        st[15] ^= bc[4];
+        st[20] ^= bc[4];
+
+        st[1]  ^= bc[0];
+        st[6]  ^= bc[0];
+        st[11] ^= bc[0];
+        st[16] ^= bc[0];
+        st[21] ^= bc[0];
+
+        st[2]  ^= bc[1];
+        st[7]  ^= bc[1];
+        st[12] ^= bc[1];
+        st[17] ^= bc[1];
+        st[22] ^= bc[1];
+
+        st[3]  ^= bc[2];
+        st[8]  ^= bc[2];
+        st[13] ^= bc[2];
+        st[18] ^= bc[2];
+        st[23] ^= bc[2];
+
+        st[4]  ^= bc[3];
+        st[9]  ^= bc[3];
+        st[14] ^= bc[3];
+        st[19] ^= bc[3];
+        st[24] ^= bc[3];
+
+        // Rho Pi
+        t = st[1];
+        #pragma unroll 1
+        for (i = 0; i < 24; ++i) {
+            bc[0] = st[keccakf_piln[i]];
+            st[keccakf_piln[i]] = rotate(t, (ulong)keccakf_rotc[i]);
+            t = bc[0];
+        }
+
+        #pragma unroll 1
+        for (int i = 0; i < 25; i += 5) {
+            ulong tmp1 = st[i], tmp2 = st[i + 1];
+
+            st[i] = bitselect(st[i] ^ st[i + 2], st[i], st[i + 1]);
+            st[i + 1] = bitselect(st[i + 1] ^ st[i + 3], st[i + 1], st[i + 2]);
+            st[i + 2] = bitselect(st[i + 2] ^ st[i + 4], st[i + 2], st[i + 3]);
+            st[i + 3] = bitselect(st[i + 3] ^ tmp1, st[i + 3], st[i + 4]);
+            st[i + 4] = bitselect(st[i + 4] ^ tmp2, st[i + 4], tmp1);
+        }
+
+        //  Iota
+        st[0] ^= keccakf_rndc[round];
+    }
+}
+
+
+/* For Mesa clover support */
+#ifdef cl_clang_storage_class_specifiers
+#   pragma OPENCL EXTENSION cl_clang_storage_class_specifiers : enable
+#endif
+
+#if defined(__NV_CL_C_VERSION) && STRIDED_INDEX != 0
+#   undef STRIDED_INDEX
+#   define STRIDED_INDEX 0
+#endif
+
+
+#define MEM_CHUNK (1 << MEM_CHUNK_EXPONENT)
+
+
+#if (STRIDED_INDEX == 0)
+#   define IDX(x) (x)
+#elif (STRIDED_INDEX == 1)
+#   define IDX(x) mul24((x), Threads)
+#elif (STRIDED_INDEX == 2)
+#   define IDX(x) (((x) % MEM_CHUNK) + ((x) / MEM_CHUNK) * WORKSIZE * MEM_CHUNK)
+#endif
+
+
+inline ulong getIdx()
+{
+    return get_global_id(0) - get_global_offset(0);
+}
+
+__attribute__((reqd_work_group_size(8, 8, 1)))
+__kernel void cn0(__global ulong *input, __global uint4 *Scratchpad, __global ulong *states, uint Threads)
+{
+    uint ExpandedKey1[40];
+    __local uint AES0[256], AES1[256], AES2[256], AES3[256];
+    uint4 text;
+
+    const uint gIdx = getIdx();
+
+    for (int i = get_local_id(1) * 8 + get_local_id(0); i < 256; i += 8 * 8) {
+        const uint tmp = AES0_C[i];
+        AES0[i] = tmp;
+        AES1[i] = rotate(tmp, 8U);
+        AES2[i] = rotate(tmp, 16U);
+        AES3[i] = rotate(tmp, 24U);
+    }
+
+    barrier(CLK_LOCAL_MEM_FENCE);
+
+    __local ulong State_buf[8 * 25];
+
+    {
+        states += 25 * gIdx;
+
+#       if (STRIDED_INDEX == 0)
+            Scratchpad += gIdx * (MEMORY >> 4);
+#       elif (STRIDED_INDEX == 1)
+            Scratchpad += gIdx;
+#       elif (STRIDED_INDEX == 2)
+            Scratchpad += (gIdx / WORKSIZE) * (MEMORY >> 4) * WORKSIZE + MEM_CHUNK * (gIdx % WORKSIZE);
+#       endif
+
+        if (get_local_id(1) == 0) {
+            __local ulong* State = State_buf + get_local_id(0) * 25;
+
+            ((__local ulong8 *)State)[0] = vload8(0, input);
+            State[8]  = input[8];
+            State[9]  = input[9];
+            State[10] = input[10];
+            State[11] = input[11];
+            State[12] = input[12];
+            State[13] = input[13];
+            State[14] = input[14];
+            State[15] = input[15];
+
+            ((__local uint *)State)[9]  &= 0x00FFFFFFU;
+            ((__local uint *)State)[9]  |= (((uint)get_global_id(0)) & 0xFF) << 24;
+            ((__local uint *)State)[10] &= 0xFF000000U;
+            /* explicit cast to `uint` is required because some OpenCL implementations (e.g. NVIDIA)
+             * handle get_global_id and get_global_offset as signed long long int and add
+             * 0xFFFFFFFF... to `get_global_id` if we set on host side a 32bit offset where the first bit is `1`
+             * (even if it is correct casted to unsigned on the host)
+             */
+            ((__local uint *)State)[10] |= (((uint)get_global_id(0) >> 8));
+
+            // Last bit of padding
+            State[16] = 0x8000000000000000UL;
+
+            for (int i = 17; i < 25; ++i) {
+                State[i] = 0x00UL;
+            }
+
+            keccakf1600_2(State);
+
+            #pragma unroll 1
+            for (int i = 0; i < 25; ++i) {
+                states[i] = State[i];
+            }
+        }
+    }
+
+    barrier(CLK_GLOBAL_MEM_FENCE);
+
+    {
+        text = vload4(get_local_id(1) + 4, (__global uint *)(states));
+
+        #pragma unroll
+        for (int i = 0; i < 4; ++i) {
+            ((ulong *)ExpandedKey1)[i] = states[i];
+        }
+
+        AESExpandKey256(ExpandedKey1);
+    }
+
+    mem_fence(CLK_LOCAL_MEM_FENCE);
+
+    {
+        const uint local_id1 = get_local_id(1);
+        #pragma unroll 2
+        for(uint i = 0; i < (MEMORY >> 4); i += 8) {
+            #pragma unroll 10
+            for (uint j = 0; j < 10; ++j) {
+                uint4 t = ((uint4 *)ExpandedKey1)[j];
+                t.s0 ^= AES0[BYTE(text.s0, 0)] ^ AES1[BYTE(text.s1, 1)] ^ AES2[BYTE(text.s2, 2)] ^ AES3[BYTE(text.s3, 3)];
+                t.s1 ^= AES0[BYTE(text.s1, 0)] ^ AES1[BYTE(text.s2, 1)] ^ AES2[BYTE(text.s3, 2)] ^ AES3[BYTE(text.s0, 3)];
+                t.s2 ^= AES0[BYTE(text.s2, 0)] ^ AES1[BYTE(text.s3, 1)] ^ AES2[BYTE(text.s0, 2)] ^ AES3[BYTE(text.s1, 3)];
+                t.s3 ^= AES0[BYTE(text.s3, 0)] ^ AES1[BYTE(text.s0, 1)] ^ AES2[BYTE(text.s1, 2)] ^ AES3[BYTE(text.s2, 3)];
+                text = t;
+            }
+
+            Scratchpad[IDX(i + local_id1)] = text;
+        }
+    }
+    mem_fence(CLK_GLOBAL_MEM_FENCE);
+}
+
+
+__attribute__((reqd_work_group_size(WORKSIZE, 1, 1)))
+__kernel void cn1(__global ulong *input, __global uint4 *Scratchpad, __global ulong *states, uint Threads, ulong iterations)
+{
+    ulong a[2], b[4];
+    __local uint AES0[256], AES1[256], AES2[256], AES3[256];
+
+    const ulong gIdx = getIdx();
+
+    for(int i = get_local_id(0); i < 256; i += WORKSIZE)
+    {
+        const uint tmp = AES0_C[i];
+        AES0[i] = tmp;
+        AES1[i] = rotate(tmp, 8U);
+        AES2[i] = rotate(tmp, 16U);
+        AES3[i] = rotate(tmp, 24U);
+    }
+
+    barrier(CLK_LOCAL_MEM_FENCE);
+
+    {
+        states += 25 * gIdx;
+
+#       if defined(__NV_CL_C_VERSION)
+            Scratchpad += gIdx * (ITERATIONS >> 2);
+#       else
+#           if (STRIDED_INDEX == 0)
+                Scratchpad += gIdx * (MEMORY >> 4);
+#           elif (STRIDED_INDEX == 1)
+                Scratchpad += gIdx;
+#           elif (STRIDED_INDEX == 2)
+                Scratchpad += get_group_id(0) * (MEMORY >> 4) * WORKSIZE + MEM_CHUNK * get_local_id(0);
+#           endif
+#       endif
+
+        a[0] = states[0] ^ states[4];
+        a[1] = states[1] ^ states[5];
+
+        b[0] = states[2] ^ states[6];
+        b[1] = states[3] ^ states[7];
+        b[2] = states[8] ^ states[10];
+        b[3] = states[9] ^ states[11];
+    }
+
+    ulong2 bx0 = ((ulong2 *)b)[0];
+    ulong2 bx1 = ((ulong2 *)b)[1];
+
+    mem_fence(CLK_LOCAL_MEM_FENCE);
+
+#   ifdef __NV_CL_C_VERSION
+        __local uint16 scratchpad_line_buf[WORKSIZE];
+        __local uint16* scratchpad_line = scratchpad_line_buf + get_local_id(0);
+#       define SCRATCHPAD_CHUNK(N) (*(__local uint4*)((__local uchar*)(scratchpad_line) + (idx1 ^ (N << 4))))
+#   else
+#       if (STRIDED_INDEX == 0)
+#           define SCRATCHPAD_CHUNK(N) (*(__global uint4*)((__global uchar*)(Scratchpad) + (idx ^ (N << 4))))
+#       elif (STRIDED_INDEX == 1)
+#           define SCRATCHPAD_CHUNK(N) (*(__global uint4*)((__global uchar*)(Scratchpad) + mul24(as_uint(idx ^ (N << 4)), Threads)))
+#       elif (STRIDED_INDEX == 2)
+#           define SCRATCHPAD_CHUNK(N) (*(__global uint4*)((__global uchar*)(Scratchpad) + (((idx ^ (N << 4)) % (MEM_CHUNK << 4)) + ((idx ^ (N << 4)) / (MEM_CHUNK << 4)) * WORKSIZE * (MEM_CHUNK << 4))))
+#       endif
+#   endif
+
+    {
+    uint2 division_result = as_uint2(states[12]);
+    uint sqrt_result = as_uint2(states[13]).s0;
+
+    //#pragma unroll CN_UNROLL
+    for (int i = 0; i < iterations; ++i) {
+#       ifdef __NV_CL_C_VERSION
+            uint idx  = a[0] & 0x1FFFC0;
+            uint idx1 = a[0] & 0x30;
+
+            *scratchpad_line = *(__global uint16*)((__global uchar*)(Scratchpad) + idx);
+#       else
+            uint idx = a[0] & MASK;
+#       endif
+
+        uint4 c = SCRATCHPAD_CHUNK(0);
+        c = AES_Round(AES0, AES1, AES2, AES3, c, ((uint4 *)a)[0]);
+
+        {
+            const ulong2 chunk1 = as_ulong2(SCRATCHPAD_CHUNK(1));
+            const ulong2 chunk2 = as_ulong2(SCRATCHPAD_CHUNK(2));
+            const ulong2 chunk3 = as_ulong2(SCRATCHPAD_CHUNK(3));
+
+            SCRATCHPAD_CHUNK(1) = as_uint4(chunk3 + bx1);
+            SCRATCHPAD_CHUNK(2) = as_uint4(chunk1 + bx0);
+            SCRATCHPAD_CHUNK(3) = as_uint4(chunk2 + ((ulong2 *)a)[0]);
+        }
+
+        SCRATCHPAD_CHUNK(0) = as_uint4(bx0) ^ c;
+
+#       ifdef __NV_CL_C_VERSION
+            *(__global uint16*)((__global uchar*)(Scratchpad) + idx) = *scratchpad_line;
+
+            idx = as_ulong2(c).s0 & 0x1FFFC0;
+            idx1 = as_ulong2(c).s0 & 0x30;
+
+            *scratchpad_line = *(__global uint16*)((__global uchar*)(Scratchpad) + idx);
+#       else
+            idx = as_ulong2(c).s0 & MASK;
+#       endif
+
+        uint4 tmp = SCRATCHPAD_CHUNK(0);
+
+        {
+            tmp.s0 ^= division_result.s0;
+            tmp.s1 ^= division_result.s1 ^ sqrt_result;
+
+            division_result = fast_div_v2(as_ulong2(c).s1, (c.s0 + (sqrt_result << 1)) | 0x80000001UL);
+            sqrt_result = fast_sqrt_v2(as_ulong2(c).s0 + as_ulong(division_result));
+        }
+
+        ulong2 t;
+        t.s0 = mul_hi(as_ulong2(c).s0, as_ulong2(tmp).s0);
+        t.s1 = as_ulong2(c).s0 * as_ulong2(tmp).s0;
+        {
+            const ulong2 chunk1 = as_ulong2(SCRATCHPAD_CHUNK(1)) ^ t;
+            const ulong2 chunk2 = as_ulong2(SCRATCHPAD_CHUNK(2));
+            t ^= chunk2;
+            const ulong2 chunk3 = as_ulong2(SCRATCHPAD_CHUNK(3));
+
+            SCRATCHPAD_CHUNK(1) = as_uint4(chunk3 + bx1);
+            SCRATCHPAD_CHUNK(2) = as_uint4(chunk1 + bx0);
+            SCRATCHPAD_CHUNK(3) = as_uint4(chunk2 + ((ulong2 *)a)[0]);
+        }
+
+        a[1] += t.s1;
+        a[0] += t.s0;
+
+        SCRATCHPAD_CHUNK(0) = ((uint4 *)a)[0];
+
+#       ifdef __NV_CL_C_VERSION
+            *(__global uint16*)((__global uchar*)(Scratchpad) + idx) = *scratchpad_line;
+#       endif
+
+        ((uint4 *)a)[0] ^= tmp;
+        bx1 = bx0;
+        bx0 = as_ulong2(c);
+    }
+
+#   undef SCRATCHPAD_CHUNK
+    }
+
+    mem_fence(CLK_GLOBAL_MEM_FENCE);
+}
+
+__attribute__((reqd_work_group_size(8, 8, 1)))
+__kernel void cn2(__global uint4 *Scratchpad, __global ulong *states, __global uint *Branch0, __global uint *Branch1, __global uint *Branch2, __global uint *Branch3, uint Threads)
+{
+    __local uint AES0[256], AES1[256], AES2[256], AES3[256];
+    uint ExpandedKey2[40];
+    uint4 text;
+
+    const ulong gIdx = getIdx();
+
+    for (int i = get_local_id(1) * 8 + get_local_id(0); i < 256; i += 8 * 8) {
+        const uint tmp = AES0_C[i];
+        AES0[i] = tmp;
+        AES1[i] = rotate(tmp, 8U);
+        AES2[i] = rotate(tmp, 16U);
+        AES3[i] = rotate(tmp, 24U);
+    }
+
+    barrier(CLK_LOCAL_MEM_FENCE);
+
+    {
+        states += 25 * gIdx;
+#       if (STRIDED_INDEX == 0)
+            Scratchpad += gIdx * (MEMORY >> 4);
+#       elif (STRIDED_INDEX == 1)
+            Scratchpad += gIdx;
+#       elif (STRIDED_INDEX == 2)
+            Scratchpad += (gIdx / WORKSIZE) * (MEMORY >> 4) * WORKSIZE + MEM_CHUNK * (gIdx % WORKSIZE);
+#       endif
+
+        #if defined(__Tahiti__) || defined(__Pitcairn__)
+
+        for(int i = 0; i < 4; ++i) ((ulong *)ExpandedKey2)[i] = states[i + 4];
+        text = vload4(get_local_id(1) + 4, (__global uint *)states);
+
+        #else
+
+        text = vload4(get_local_id(1) + 4, (__global uint *)states);
+        ((uint8 *)ExpandedKey2)[0] = vload8(1, (__global uint *)states);
+
+        #endif
+
+        AESExpandKey256(ExpandedKey2);
+    }
+
+    barrier(CLK_LOCAL_MEM_FENCE);
+    {
+        const uint local_id1 = get_local_id(1);
+        #pragma unroll 2
+        for (uint i = 0; i < (MEMORY >> 7); ++i) {
+            text ^= Scratchpad[IDX((i << 3) + local_id1)];
+
+            #pragma unroll 10
+            for(uint j = 0; j < 10; ++j)
+                text = AES_Round(AES0, AES1, AES2, AES3, text, ((uint4 *)ExpandedKey2)[j]);
+        }
+    }
+
+    {
+        vstore2(as_ulong2(text), get_local_id(1) + 4, states);
+    }
+
+    barrier(CLK_GLOBAL_MEM_FENCE);
+
+    __local ulong State_buf[8 * 25];
+
+    {
+        if(!get_local_id(1))
+        {
+            __local ulong* State = State_buf + get_local_id(0) * 25;
+
+            for(int i = 0; i < 25; ++i) State[i] = states[i];
+
+            keccakf1600_2(State);
+
+            for(int i = 0; i < 25; ++i) states[i] = State[i];
+
+            uint StateSwitch = State[0] & 3;
+            __global uint *destinationBranch1 = StateSwitch == 0 ? Branch0 : Branch1;
+            __global uint *destinationBranch2 = StateSwitch == 2 ? Branch2 : Branch3;
+            __global uint *destinationBranch = StateSwitch < 2 ? destinationBranch1 : destinationBranch2;
+            destinationBranch[atomic_inc(destinationBranch + Threads)] = gIdx;
+        }
+    }
+    mem_fence(CLK_GLOBAL_MEM_FENCE);
+}
+
+
+#define VSWAP8(x)   (((x) >> 56) | (((x) >> 40) & 0x000000000000FF00UL) | (((x) >> 24) & 0x0000000000FF0000UL) \
+          | (((x) >>  8) & 0x00000000FF000000UL) | (((x) <<  8) & 0x000000FF00000000UL) \
+          | (((x) << 24) & 0x0000FF0000000000UL) | (((x) << 40) & 0x00FF000000000000UL) | (((x) << 56) & 0xFF00000000000000UL))
+
+
+#define VSWAP4(x)   ((((x) >> 24) & 0xFFU) | (((x) >> 8) & 0xFF00U) | (((x) << 8) & 0xFF0000U) | (((x) << 24) & 0xFF000000U))
+
+
+__kernel void Skein(__global ulong *states, __global uint *BranchBuf, __global uint *output, ulong Target, uint Threads)
+{
+    const uint idx = get_global_id(0) - get_global_offset(0);
+
+    // do not use early return here
+    if(idx < BranchBuf[Threads]) {
+        states += 25 * BranchBuf[idx];
+
+        // skein
+        ulong8 h = vload8(0, SKEIN512_256_IV);
+        ulong t[3] = { 0x00UL, 0x7000000000000000UL, 0x00UL };
+        ulong8 p, m;
+
+        #pragma unroll 1
+        for (uint i = 0; i < 4; ++i)
+        {
+            t[0] += i < 3 ? 0x40UL : 0x08UL;
+
+            t[2] = t[0] ^ t[1];
+
+            m = (i < 3) ? vload8(i, states) : (ulong8)(states[24], 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL);
+            const ulong h8 = h.s0 ^ h.s1 ^ h.s2 ^ h.s3 ^ h.s4 ^ h.s5 ^ h.s6 ^ h.s7 ^ SKEIN_KS_PARITY;
+            p = Skein512Block(m, h, h8, t);
+
+            h = m ^ p;
+
+            t[1] = i < 2 ? 0x3000000000000000UL : 0xB000000000000000UL;
+        }
+
+        t[0] = 0x08UL;
+        t[1] = 0xFF00000000000000UL;
+        t[2] = t[0] ^ t[1];
+
+        p = (ulong8)(0);
+        const ulong h8 = h.s0 ^ h.s1 ^ h.s2 ^ h.s3 ^ h.s4 ^ h.s5 ^ h.s6 ^ h.s7 ^ SKEIN_KS_PARITY;
+
+        p = Skein512Block(p, h, h8, t);
+
+        // Note that comparison is equivalent to subtraction - we can't just compare 8 32-bit values
+        // and expect an accurate result for target > 32-bit without implementing carries
+        if (p.s3 <= Target) {
+            ulong outIdx = atomic_inc(output + 0xFF);
+            if (outIdx < 0xFF) {
+                output[outIdx] = BranchBuf[idx] + (uint) get_global_offset(0);
+            }
+        }
+    }
+
+    mem_fence(CLK_GLOBAL_MEM_FENCE);
+}
+
+
+#define SWAP8(x) as_ulong(as_uchar8(x).s76543210)
+
+
+#define JHXOR \
+    h0h ^= input[0]; \
+    h0l ^= input[1]; \
+    h1h ^= input[2]; \
+    h1l ^= input[3]; \
+    h2h ^= input[4]; \
+    h2l ^= input[5]; \
+    h3h ^= input[6]; \
+    h3l ^= input[7]; \
+\
+    E8; \
+\
+    h4h ^= input[0]; \
+    h4l ^= input[1]; \
+    h5h ^= input[2]; \
+    h5l ^= input[3]; \
+    h6h ^= input[4]; \
+    h6l ^= input[5]; \
+    h7h ^= input[6]; \
+    h7l ^= input[7]
+
+
+__kernel void JH(__global ulong *states, __global uint *BranchBuf, __global uint *output, ulong Target, uint Threads)
+{
+    const uint idx = get_global_id(0) - get_global_offset(0);
+
+    // do not use early return here
+    if (idx < BranchBuf[Threads]) {
+        states += 25 * BranchBuf[idx];
+
+        sph_u64 h0h = 0xEBD3202C41A398EBUL, h0l = 0xC145B29C7BBECD92UL, h1h = 0xFAC7D4609151931CUL, h1l = 0x038A507ED6820026UL, h2h = 0x45B92677269E23A4UL, h2l = 0x77941AD4481AFBE0UL, h3h = 0x7A176B0226ABB5CDUL, h3l = 0xA82FFF0F4224F056UL;
+        sph_u64 h4h = 0x754D2E7F8996A371UL, h4l = 0x62E27DF70849141DUL, h5h = 0x948F2476F7957627UL, h5l = 0x6C29804757B6D587UL, h6h = 0x6C0D8EAC2D275E5CUL, h6l = 0x0F7A0557C6508451UL, h7h = 0xEA12247067D3E47BUL, h7l = 0x69D71CD313ABE389UL;
+        sph_u64 tmp;
+
+        for (uint i = 0; i < 3; ++i) {
+            ulong input[8];
+
+            const int shifted = i << 3;
+            for (uint x = 0; x < 8; ++x) {
+                input[x] = (states[shifted + x]);
+            }
+
+            JHXOR;
+        }
+
+        {
+            ulong input[8] = { (states[24]), 0x80UL, 0x00UL, 0x00UL, 0x00UL, 0x00UL, 0x00UL, 0x00UL };
+            JHXOR;
+        }
+
+        {
+            ulong input[8] = { 0x00UL, 0x00UL, 0x00UL, 0x00UL, 0x00UL, 0x00UL, 0x00UL, 0x4006000000000000UL };
+            JHXOR;
+        }
+
+        // Note that comparison is equivalent to subtraction - we can't just compare 8 32-bit values
+        // and expect an accurate result for target > 32-bit without implementing carries
+        if (h7l <= Target) {
+            ulong outIdx = atomic_inc(output + 0xFF);
+            if (outIdx < 0xFF) {
+                output[outIdx] = BranchBuf[idx] + (uint) get_global_offset(0);
+            }
+        }
+    }
+}
+
+
+#define SWAP4(x)    as_uint(as_uchar4(x).s3210)
+
+
+__kernel void Blake(__global ulong *states, __global uint *BranchBuf, __global uint *output, ulong Target, uint Threads)
+{
+    const uint idx = get_global_id(0) - get_global_offset(0);
+
+    // do not use early return here
+    if (idx < BranchBuf[Threads]) {
+        states += 25 * BranchBuf[idx];
+
+        unsigned int m[16];
+        unsigned int v[16];
+        uint h[8];
+        uint bitlen = 0;
+
+        ((uint8 *)h)[0] = vload8(0U, c_IV256);
+
+        for (uint i = 0; i < 3; ++i) {
+            ((uint16 *)m)[0] = vload16(i, (__global uint *)states);
+            for (uint x = 0; x < 16; ++x) {
+                m[x] = SWAP4(m[x]);
+            }
+
+            bitlen += 512;
+
+            ((uint16 *)v)[0].lo = ((uint8 *)h)[0];
+            ((uint16 *)v)[0].hi = vload8(0U, c_u256);
+
+            v[12] ^= bitlen;
+            v[13] ^= bitlen;
+
+            for (uint r = 0; r < 14; r++) {
+                GS(0, 4, 0x8, 0xC, 0x0);
+                GS(1, 5, 0x9, 0xD, 0x2);
+                GS(2, 6, 0xA, 0xE, 0x4);
+                GS(3, 7, 0xB, 0xF, 0x6);
+                GS(0, 5, 0xA, 0xF, 0x8);
+                GS(1, 6, 0xB, 0xC, 0xA);
+                GS(2, 7, 0x8, 0xD, 0xC);
+                GS(3, 4, 0x9, 0xE, 0xE);
+            }
+
+            ((uint8 *)h)[0] ^= ((uint8 *)v)[0] ^ ((uint8 *)v)[1];
+        }
+
+        m[0]  = SWAP4(((__global uint *)states)[48]);
+        m[1]  = SWAP4(((__global uint *)states)[49]);
+        m[2]  = 0x80000000U;
+        m[3]  = 0x00U;
+        m[4]  = 0x00U;
+        m[5]  = 0x00U;
+        m[6]  = 0x00U;
+        m[7]  = 0x00U;
+        m[8]  = 0x00U;
+        m[9]  = 0x00U;
+        m[10] = 0x00U;
+        m[11] = 0x00U;
+        m[12] = 0x00U;
+        m[13] = 1U;
+        m[14] = 0U;
+        m[15] = 0x640;
+
+        bitlen += 64;
+
+        ((uint16 *)v)[0].lo = ((uint8 *)h)[0];
+        ((uint16 *)v)[0].hi = vload8(0U, c_u256);
+
+        v[12] ^= bitlen;
+        v[13] ^= bitlen;
+
+        for (uint r = 0; r < 14; r++) {
+            GS(0, 4, 0x8, 0xC, 0x0);
+            GS(1, 5, 0x9, 0xD, 0x2);
+            GS(2, 6, 0xA, 0xE, 0x4);
+            GS(3, 7, 0xB, 0xF, 0x6);
+            GS(0, 5, 0xA, 0xF, 0x8);
+            GS(1, 6, 0xB, 0xC, 0xA);
+            GS(2, 7, 0x8, 0xD, 0xC);
+            GS(3, 4, 0x9, 0xE, 0xE);
+        }
+
+        ((uint8 *)h)[0] ^= ((uint8 *)v)[0] ^ ((uint8 *)v)[1];
+
+        for (uint i = 0; i < 8; ++i) {
+            h[i] = SWAP4(h[i]);
+        }
+
+        // Note that comparison is equivalent to subtraction - we can't just compare 8 32-bit values
+        // and expect an accurate result for target > 32-bit without implementing carries
+        uint2 t = (uint2)(h[6],h[7]);
+        if (as_ulong(t) <= Target) {
+            ulong outIdx = atomic_inc(output + 0xFF);
+            if (outIdx < 0xFF) {
+                output[outIdx] = BranchBuf[idx] + (uint) get_global_offset(0);
+            }
+        }
+    }
+}
+
+
+#undef SWAP4
+
+
+__kernel void Groestl(__global ulong *states, __global uint *BranchBuf, __global uint *output, ulong Target, uint Threads)
+{
+    const uint idx = get_global_id(0) - get_global_offset(0);
+
+    // do not use early return here
+    if (idx < BranchBuf[Threads]) {
+        states += 25 * BranchBuf[idx];
+
+        ulong State[8] = { 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0x0001000000000000UL };
+        ulong H[8], M[8];
+
+        // BUG: AMD driver 19.7.X crashs if this is written as loop
+        // Thx AMD for so bad software
+        {
+            ((ulong8 *)M)[0] = vload8(0, states);
+
+            for (uint x = 0; x < 8; ++x) {
+                H[x] = M[x] ^ State[x];
+            }
+
+            PERM_SMALL_P(H);
+            PERM_SMALL_Q(M);
+
+            for (uint x = 0; x < 8; ++x) {
+                State[x] ^= H[x] ^ M[x];
+            }
+        }
+
+        {
+            ((ulong8 *)M)[0] = vload8(1, states);
+
+            for (uint x = 0; x < 8; ++x) {
+                H[x] = M[x] ^ State[x];
+            }
+
+            PERM_SMALL_P(H);
+            PERM_SMALL_Q(M);
+
+            for (uint x = 0; x < 8; ++x) {
+                State[x] ^= H[x] ^ M[x];
+            }
+        }
+
+        {
+            ((ulong8 *)M)[0] = vload8(2, states);
+
+            for (uint x = 0; x < 8; ++x) {
+                H[x] = M[x] ^ State[x];
+            }
+
+            PERM_SMALL_P(H);
+            PERM_SMALL_Q(M);
+
+            for (uint x = 0; x < 8; ++x) {
+                State[x] ^= H[x] ^ M[x];
+            }
+        }
+
+        M[0] = states[24];
+        M[1] = 0x80UL;
+        M[2] = 0UL;
+        M[3] = 0UL;
+        M[4] = 0UL;
+        M[5] = 0UL;
+        M[6] = 0UL;
+        M[7] = 0x0400000000000000UL;
+
+        for (uint x = 0; x < 8; ++x) {
+            H[x] = M[x] ^ State[x];
+        }
+
+        PERM_SMALL_P(H);
+        PERM_SMALL_Q(M);
+
+        ulong tmp[8];
+        for (uint i = 0; i < 8; ++i) {
+            tmp[i] = State[i] ^= H[i] ^ M[i];
+        }
+
+        PERM_SMALL_P(State);
+
+        for (uint i = 0; i < 8; ++i) {
+            State[i] ^= tmp[i];
+        }
+
+        // Note that comparison is equivalent to subtraction - we can't just compare 8 32-bit values
+        // and expect an accurate result for target > 32-bit without implementing carries
+        if (State[7] <= Target) {
+            ulong outIdx = atomic_inc(output + 0xFF);
+            if (outIdx < 0xFF) {
+                output[outIdx] = BranchBuf[idx] + (uint) get_global_offset(0);
+            }
+        }
+    }
+}
diff --git a/src/backend/opencl/generators/ocl_generic_cn_generator.cpp b/src/backend/opencl/generators/ocl_generic_cn_generator.cpp
index 5fb91eb..3e6751b 100644
--- a/src/backend/opencl/generators/ocl_generic_cn_generator.cpp
+++ b/src/backend/opencl/generators/ocl_generic_cn_generator.cpp
@@ -29,23 +29,19 @@
 #include "crypto/cn/CnAlgo.h"
 #include "crypto/common/Algorithm.h"
 
-
-#include <algorithm>
-
-
 namespace xmrig {
 
 
 constexpr const size_t oneMiB = 1024u * 1024u;
 
 
-static inline uint32_t getMaxThreads(const OclDevice &device, const Algorithm &algorithm)
+static inline uint32_t getMaxThreads(const OclDevice &device)
 {
     if (device.vendorId() == OCL_VENDOR_NVIDIA && (device.name().contains("P100") || device.name().contains("V100"))) {
         return 40000u;
     }
 
-    const uint32_t ratio = (algorithm.l3() <= oneMiB) ? 2u : 1u;
+    const uint32_t ratio = 2u;
 
     if (device.vendorId() == OCL_VENDOR_INTEL) {
         return ratio * device.computeUnits() * 8;
@@ -55,25 +51,25 @@ static inline uint32_t getMaxThreads(const OclDevice &device, const Algorithm &a
 }
 
 
-static inline uint32_t getPossibleIntensity(const OclDevice &device, const Algorithm &algorithm)
+static inline uint32_t getPossibleIntensity(const OclDevice &device)
 {
-    const uint32_t maxThreads   = getMaxThreads(device, algorithm);
+    const uint32_t maxThreads   = getMaxThreads(device);
     const size_t minFreeMem     = (maxThreads == 40000u ? 512u : 128u) * oneMiB;
     const size_t availableMem   = device.freeMemSize() - minFreeMem;
-    const size_t perThread      = algorithm.l3() + 224u;
+    const size_t perThread      = CnAlgo::CN_MEMORY + 224u;
     const auto maxIntensity     = static_cast<uint32_t>(availableMem / perThread);
 
     return std::min<uint32_t>(maxThreads, maxIntensity);
 }
 
 
-static uint32_t getIntensity(const OclDevice &device, const Algorithm &algorithm)
+static uint32_t getIntensity(const OclDevice &device)
 {
     if (device.type() == OclDevice::Raven) {
         return 0;
     }
 
-    const uint32_t maxIntensity = getPossibleIntensity(device, algorithm);
+    const uint32_t maxIntensity = getPossibleIntensity(device);
 
     uint32_t intensity = (maxIntensity / (8 * device.computeUnits())) * device.computeUnits() * 8;
     if (intensity == 0) {
@@ -82,40 +78,32 @@ static uint32_t getIntensity(const OclDevice &device, const Algorithm &algorithm
 
     if (device.vendorId() == OCL_VENDOR_AMD && (device.type() == OclDevice::Lexa || device.type() == OclDevice::Baffin || device.computeUnits() <= 16)) {
         intensity /= 2;
-
-        if (algorithm.family() == Algorithm::CN_HEAVY) {
-            intensity /= 2;
-        }
     }
 
     return intensity;
 }
 
 
-static uint32_t getStridedIndex(const OclDevice &device, const Algorithm &algorithm)
+static uint32_t getStridedIndex(const OclDevice &device)
 {
     if (device.vendorId() != OCL_VENDOR_AMD) {
         return 0;
     }
 
-    return CnAlgo<>::base(algorithm) == Algorithm::CN_2 ? 2 : 1;
+    return 2;
 }
 
 
-bool ocl_generic_cn_generator(const OclDevice &device, const Algorithm &algorithm, OclThreads &threads)
+bool ocl_generic_cn_generator(const OclDevice &device, OclThreads &threads)
 {
-    if (!algorithm.isCN()) {
-        return false;
-    }
-
-    const uint32_t intensity = getIntensity(device, algorithm);
+    const uint32_t intensity = getIntensity(device);
     if (intensity == 0) {
         return false;
     }
 
-    const uint32_t threadCount = (device.vendorId() == OCL_VENDOR_AMD && (device.globalMemSize() - intensity * 2 * algorithm.l3()) > 128 * oneMiB) ? 2 : 1;
+    const uint32_t threadCount = (device.vendorId() == OCL_VENDOR_AMD && (device.globalMemSize() - intensity * 2 * CnAlgo::CN_MEMORY) > 128 * oneMiB) ? 2 : 1;
 
-    threads.add(OclThread(device.index(), intensity, 8, getStridedIndex(device, algorithm), 2, threadCount, 8));
+    threads.add(OclThread(device.index(), intensity, 8, getStridedIndex(device), 2, threadCount, 8));
 
     return true;
 }
diff --git a/src/backend/opencl/generators/ocl_vega_cn_generator.cpp b/src/backend/opencl/generators/ocl_vega_cn_generator.cpp
index dbaba1c..0121c02 100644
--- a/src/backend/opencl/generators/ocl_vega_cn_generator.cpp
+++ b/src/backend/opencl/generators/ocl_vega_cn_generator.cpp
@@ -27,11 +27,6 @@
 #include "backend/opencl/OclThreads.h"
 #include "backend/opencl/wrappers/OclDevice.h"
 #include "crypto/cn/CnAlgo.h"
-#include "crypto/common/Algorithm.h"
-
-
-#include <algorithm>
-
 
 namespace xmrig {
 
@@ -39,20 +34,19 @@ namespace xmrig {
 constexpr const size_t oneMiB = 1024u * 1024u;
 
 
-static inline bool isMatch(const OclDevice &device, const Algorithm &algorithm)
+static inline bool isMatch(const OclDevice &device)
 {
-    return algorithm.isCN() &&
-           device.vendorId() == OCL_VENDOR_AMD &&
+    return device.vendorId() == OCL_VENDOR_AMD &&
            (device.type() == OclDevice::Vega_10 || device.type() == OclDevice::Vega_20);
 }
 
 
-static inline uint32_t getMaxThreads(const OclDevice &device, const Algorithm &algorithm)
+static inline uint32_t getMaxThreads(const OclDevice &device)
 {
-    const uint32_t ratio = (algorithm.l3() <= oneMiB) ? 2u : 1u;
+    const uint32_t ratio = 2u;
 
     if (device.type() == OclDevice::Vega_10) {
-        if (device.computeUnits() == 56 && algorithm.family() == Algorithm::CN && CnAlgo<>::base(algorithm) == Algorithm::CN_2) {
+        if (device.computeUnits() == 56) {
             return 1792u;
         }
     }
@@ -61,72 +55,48 @@ static inline uint32_t getMaxThreads(const OclDevice &device, const Algorithm &a
 }
 
 
-static inline uint32_t getPossibleIntensity(const OclDevice &device, const Algorithm &algorithm)
+static inline uint32_t getPossibleIntensity(const OclDevice &device)
 {
-    const uint32_t maxThreads   = getMaxThreads(device, algorithm);
+    const uint32_t maxThreads   = getMaxThreads(device);
     const size_t availableMem   = device.freeMemSize() - (128u * oneMiB);
-    const size_t perThread      = algorithm.l3() + 224u;
+    const size_t perThread      = CnAlgo::CN_MEMORY + 224u;
     const auto maxIntensity     = static_cast<uint32_t>(availableMem / perThread);
 
     return std::min<uint32_t>(maxThreads, maxIntensity);
 }
 
 
-static inline uint32_t getIntensity(const OclDevice &device, const Algorithm &algorithm)
+static inline uint32_t getIntensity(const OclDevice &device)
 {
-    const uint32_t maxIntensity = getPossibleIntensity(device, algorithm);
-
-    if (device.type() == OclDevice::Vega_10) {
-        if (algorithm.family() == Algorithm::CN_HEAVY && device.computeUnits() == 64 && maxIntensity > 976) {
-            return 976;
-        }
-    }
-
+    const uint32_t maxIntensity = getPossibleIntensity(device);
     return maxIntensity / device.computeUnits() * device.computeUnits();
 }
 
 
-static inline uint32_t getWorksize(const Algorithm &algorithm)
-{
-    if (algorithm.family() == Algorithm::CN_PICO) {
-        return 64;
-    }
-
-    if (CnAlgo<>::base(algorithm) == Algorithm::CN_2) {
-        return 16;
-    }
+static inline uint32_t getWorksize() { return 16; }
 
-    return 8;
-}
 
-
-static uint32_t getStridedIndex(const Algorithm &algorithm)
-{
-    return CnAlgo<>::base(algorithm) == Algorithm::CN_2 ? 2 : 1;
-}
+static uint32_t getStridedIndex() { return 2; }
 
 
-static inline uint32_t getMemChunk(const Algorithm &algorithm)
-{
-    return CnAlgo<>::base(algorithm) == Algorithm::CN_2 ? 1 : 2;
-}
+static inline uint32_t getMemChunk() { return 1; }
 
 
-bool ocl_vega_cn_generator(const OclDevice &device, const Algorithm &algorithm, OclThreads &threads)
+bool ocl_vega_cn_generator(const OclDevice &device, OclThreads &threads)
 {
-    if (!isMatch(device, algorithm)) {
+    if (!isMatch(device)) {
         return false;
     }
 
-    const uint32_t intensity = getIntensity(device, algorithm);
+    const uint32_t intensity = getIntensity(device);
     if (intensity == 0) {
         return false;
     }
 
-    const uint32_t worksize = getWorksize(algorithm);
-    const uint32_t memChunk = getMemChunk(algorithm);
+    const uint32_t worksize = getWorksize();
+    const uint32_t memChunk = getMemChunk();
 
-    threads.add(OclThread(device.index(), intensity, worksize, getStridedIndex(algorithm), memChunk, 2, 8));
+    threads.add(OclThread(device.index(), intensity, worksize, getStridedIndex(), memChunk, 2, 8));
 
     return true;
 }
diff --git a/src/backend/opencl/interfaces/IOclRunner.h b/src/backend/opencl/interfaces/IOclRunner.h
index 0b47bcd..3a8a80d 100644
--- a/src/backend/opencl/interfaces/IOclRunner.h
+++ b/src/backend/opencl/interfaces/IOclRunner.h
@@ -37,12 +37,9 @@ using cl_context = struct _cl_context *;
 
 namespace xmrig {
 
-
-class Algorithm;
 class Job;
 class OclLaunchData;
 
-
 class IOclRunner
 {
 public:
@@ -52,7 +49,6 @@ public:
     virtual ~IOclRunner() = default;
 
     virtual cl_context ctx() const                          = 0;
-    virtual const Algorithm &algorithm() const              = 0;
     virtual const char *buildOptions() const                = 0;
     virtual const char *deviceKey() const                   = 0;
     virtual const char *source() const                      = 0;
diff --git a/src/backend/opencl/kernels/Cn1Kernel.cpp b/src/backend/opencl/kernels/Cn1Kernel.cpp
index fad7889..2f3d52f 100644
--- a/src/backend/opencl/kernels/Cn1Kernel.cpp
+++ b/src/backend/opencl/kernels/Cn1Kernel.cpp
@@ -36,13 +36,6 @@ xmrig::Cn1Kernel::Cn1Kernel(cl_program program)
 }
 
 
-xmrig::Cn1Kernel::Cn1Kernel(cl_program program, uint64_t height)
-    : OclKernel(program, ("cn1_" + std::to_string(height)).c_str())
-{
-
-}
-
-
 void xmrig::Cn1Kernel::enqueue(cl_command_queue queue, uint32_t nonce, size_t threads, size_t worksize)
 {
     const size_t offset   = nonce;
@@ -53,7 +46,7 @@ void xmrig::Cn1Kernel::enqueue(cl_command_queue queue, uint32_t nonce, size_t th
 }
 
 
-// __kernel void cn1(__global ulong *input, __global uint4 *Scratchpad, __global ulong *states, uint Threads)
+// __kernel void cn1(__global ulong *input, __global uint4 *Scratchpad, __global ulong *states, uint Threads, ulong iterations)
 void xmrig::Cn1Kernel::setArgs(cl_mem input, cl_mem scratchpads, cl_mem states, uint32_t threads)
 {
     setArg(0, sizeof(cl_mem), &input);
@@ -61,3 +54,9 @@ void xmrig::Cn1Kernel::setArgs(cl_mem input, cl_mem scratchpads, cl_mem states,
     setArg(2, sizeof(cl_mem), &states);
     setArg(3, sizeof(uint32_t), &threads);
 }
+
+void xmrig::Cn1Kernel::setExtraIters(uint64_t extra_iters)
+{
+    uint64_t iters = ((0x40000 + extra_iters) >> 1);
+    setArg(4, sizeof(uint64_t), &iters);
+}
diff --git a/src/backend/opencl/kernels/Cn1Kernel.h b/src/backend/opencl/kernels/Cn1Kernel.h
index 08d33de..12c1a4a 100644
--- a/src/backend/opencl/kernels/Cn1Kernel.h
+++ b/src/backend/opencl/kernels/Cn1Kernel.h
@@ -36,10 +36,10 @@ class Cn1Kernel : public OclKernel
 {
 public:
     Cn1Kernel(cl_program program);
-    Cn1Kernel(cl_program program, uint64_t height);
 
     void enqueue(cl_command_queue queue, uint32_t nonce, size_t threads, size_t worksize);
     void setArgs(cl_mem input, cl_mem scratchpads, cl_mem states, uint32_t threads);
+    void setExtraIters(uint64_t extra_iters);
 };
 
 
diff --git a/src/backend/opencl/opencl.cmake b/src/backend/opencl/opencl.cmake
index 48a9264..daafa1b 100644
--- a/src/backend/opencl/opencl.cmake
+++ b/src/backend/opencl/opencl.cmake
@@ -6,7 +6,6 @@ if (WITH_OPENCL)
     set(HEADERS_BACKEND_OPENCL
         src/backend/opencl/cl/OclSource.h
         src/backend/opencl/interfaces/IOclRunner.h
-        src/backend/opencl/kernels/Cn0Kernel.h
         src/backend/opencl/kernels/Cn1Kernel.h
         src/backend/opencl/kernels/Cn2Kernel.h
         src/backend/opencl/kernels/CnBranchKernel.h
@@ -21,7 +20,6 @@ if (WITH_OPENCL)
         src/backend/opencl/OclWorker.h
         src/backend/opencl/runners/OclBaseRunner.h
         src/backend/opencl/runners/OclCnRunner.h
-        src/backend/opencl/runners/tools/OclCnR.h
         src/backend/opencl/runners/tools/OclSharedData.h
         src/backend/opencl/runners/tools/OclSharedState.h
         src/backend/opencl/wrappers/OclContext.h
@@ -37,7 +35,6 @@ if (WITH_OPENCL)
         src/backend/opencl/cl/OclSource.cpp
         src/backend/opencl/generators/ocl_generic_cn_generator.cpp
         src/backend/opencl/generators/ocl_vega_cn_generator.cpp
-        src/backend/opencl/kernels/Cn0Kernel.cpp
         src/backend/opencl/kernels/Cn1Kernel.cpp
         src/backend/opencl/kernels/Cn2Kernel.cpp
         src/backend/opencl/kernels/CnBranchKernel.cpp
@@ -50,7 +47,6 @@ if (WITH_OPENCL)
         src/backend/opencl/OclWorker.cpp
         src/backend/opencl/runners/OclBaseRunner.cpp
         src/backend/opencl/runners/OclCnRunner.cpp
-        src/backend/opencl/runners/tools/OclCnR.cpp
         src/backend/opencl/runners/tools/OclSharedData.cpp
         src/backend/opencl/runners/tools/OclSharedState.cpp
         src/backend/opencl/wrappers/OclContext.cpp
@@ -67,56 +63,6 @@ if (WITH_OPENCL)
        list(APPEND SOURCES_BACKEND_OPENCL src/backend/opencl/OclCache_unix.cpp)
    endif()
 
-   if (WITH_RANDOMX)
-       list(APPEND HEADERS_BACKEND_OPENCL
-           src/backend/opencl/kernels/rx/Blake2bHashRegistersKernel.h
-           src/backend/opencl/kernels/rx/Blake2bInitialHashKernel.h
-           src/backend/opencl/kernels/rx/ExecuteVmKernel.h
-           src/backend/opencl/kernels/rx/FillAesKernel.h
-           src/backend/opencl/kernels/rx/FindSharesKernel.h
-           src/backend/opencl/kernels/rx/HashAesKernel.cpp
-           src/backend/opencl/kernels/rx/InitVmKernel.h
-           src/backend/opencl/kernels/rx/RxJitKernel.h
-           src/backend/opencl/kernels/rx/RxRunKernel.h
-           src/backend/opencl/runners/OclRxBaseRunner.h
-           src/backend/opencl/runners/OclRxJitRunner.h
-           src/backend/opencl/runners/OclRxVmRunner.h
-           )
-
-       list(APPEND SOURCES_BACKEND_OPENCL
-           src/backend/opencl/generators/ocl_generic_rx_generator.cpp
-           src/backend/opencl/kernels/rx/Blake2bHashRegistersKernel.cpp
-           src/backend/opencl/kernels/rx/Blake2bInitialHashKernel.cpp
-           src/backend/opencl/kernels/rx/ExecuteVmKernel.cpp
-           src/backend/opencl/kernels/rx/FillAesKernel.cpp
-           src/backend/opencl/kernels/rx/FindSharesKernel.cpp
-           src/backend/opencl/kernels/rx/HashAesKernel.cpp
-           src/backend/opencl/kernels/rx/InitVmKernel.cpp
-           src/backend/opencl/kernels/rx/RxJitKernel.cpp
-           src/backend/opencl/kernels/rx/RxRunKernel.cpp
-           src/backend/opencl/runners/OclRxBaseRunner.cpp
-           src/backend/opencl/runners/OclRxJitRunner.cpp
-           src/backend/opencl/runners/OclRxVmRunner.cpp
-           )
-   endif()
-
-   if (WITH_CN_GPU AND CMAKE_SIZEOF_VOID_P EQUAL 8)
-       list(APPEND HEADERS_BACKEND_OPENCL
-           src/backend/opencl/kernels/Cn00RyoKernel.h
-           src/backend/opencl/kernels/Cn1RyoKernel.h
-           src/backend/opencl/kernels/Cn2RyoKernel.h
-           src/backend/opencl/runners/OclRyoRunner.h
-           )
-
-       list(APPEND SOURCES_BACKEND_OPENCL
-           src/backend/opencl/generators/ocl_generic_cn_gpu_generator.cpp
-           src/backend/opencl/kernels/Cn00RyoKernel.cpp
-           src/backend/opencl/kernels/Cn1RyoKernel.cpp
-           src/backend/opencl/kernels/Cn2RyoKernel.cpp
-           src/backend/opencl/runners/OclRyoRunner.cpp
-           )
-   endif()
-
    if (WITH_STRICT_CACHE)
        add_definitions(/DXMRIG_STRICT_OPENCL_CACHE)
    else()
diff --git a/src/backend/opencl/runners/OclBaseRunner.cpp b/src/backend/opencl/runners/OclBaseRunner.cpp
index 2e75d9b..9bc01d9 100644
--- a/src/backend/opencl/runners/OclBaseRunner.cpp
+++ b/src/backend/opencl/runners/OclBaseRunner.cpp
@@ -40,8 +40,7 @@ constexpr size_t oneGiB = 1024 * 1024 * 1024;
 
 xmrig::OclBaseRunner::OclBaseRunner(size_t id, const OclLaunchData &data) :
     m_ctx(data.ctx),
-    m_algorithm(data.algorithm),
-    m_source(OclSource::get(data.algorithm)),
+    m_source(OclSource::get()),
     m_data(data),
     m_align(OclLib::getUint(data.device.id(), CL_DEVICE_MEM_BASE_ADDR_ALIGN)),
     m_threadId(id),
diff --git a/src/backend/opencl/runners/OclBaseRunner.h b/src/backend/opencl/runners/OclBaseRunner.h
index 6abbb2b..cd461d2 100644
--- a/src/backend/opencl/runners/OclBaseRunner.h
+++ b/src/backend/opencl/runners/OclBaseRunner.h
@@ -50,7 +50,6 @@ public:
 
 protected:
     inline cl_context ctx() const override              { return m_ctx; }
-    inline const Algorithm &algorithm() const override  { return m_algorithm; }
     inline const char *buildOptions() const override    { return m_options.c_str(); }
     inline const char *deviceKey() const override       { return m_deviceKey.c_str(); }
     inline const char *source() const override          { return m_source; }
@@ -76,7 +75,6 @@ protected:
     cl_mem m_input              = nullptr;
     cl_mem m_output             = nullptr;
     cl_program m_program        = nullptr;
-    const Algorithm m_algorithm;
     const char *m_source;
     const OclLaunchData &m_data;
     const size_t m_align;
diff --git a/src/backend/opencl/runners/OclCnRunner.cpp b/src/backend/opencl/runners/OclCnRunner.cpp
index a1f4d5c..820f052 100644
--- a/src/backend/opencl/runners/OclCnRunner.cpp
+++ b/src/backend/opencl/runners/OclCnRunner.cpp
@@ -25,12 +25,10 @@
 
 #include "backend/opencl/runners/OclCnRunner.h"
 
-#include "backend/opencl/kernels/Cn0Kernel.h"
 #include "backend/opencl/kernels/Cn1Kernel.h"
 #include "backend/opencl/kernels/Cn2Kernel.h"
 #include "backend/opencl/kernels/CnBranchKernel.h"
 #include "backend/opencl/OclLaunchData.h"
-#include "backend/opencl/runners/tools/OclCnR.h"
 #include "backend/opencl/wrappers/OclLib.h"
 #include "base/io/log/Log.h"
 #include "base/net/stratum/Job.h"
@@ -43,26 +41,22 @@ xmrig::OclCnRunner::OclCnRunner(size_t index, const OclLaunchData &data) : OclBa
     if (data.device.vendorId() == OCL_VENDOR_NVIDIA) {
         stridedIndex = 0;
     }
-    else if (stridedIndex == 1 && (m_algorithm.family() == Algorithm::CN_PICO || (m_algorithm.family() == Algorithm::CN && CnAlgo<>::base(m_algorithm) == Algorithm::CN_2))) {
+    else {
         stridedIndex = 2;
     }
 
-    m_options += " -DITERATIONS="           + std::to_string(CnAlgo<>::iterations(m_algorithm)) + "U";
-    m_options += " -DMASK="                 + std::to_string(CnAlgo<>::mask(m_algorithm)) + "U";
+    m_options += " -DITERATIONS="           + std::to_string(CnAlgo::CN_ITER >> 1) + "U";
+    m_options += " -DMASK="                 + std::to_string(CnAlgo::CN_MASK) + "U";
     m_options += " -DWORKSIZE="             + std::to_string(data.thread.worksize()) + "U";
     m_options += " -DSTRIDED_INDEX="        + std::to_string(stridedIndex) + "U";
     m_options += " -DMEM_CHUNK_EXPONENT="   + std::to_string(1u << data.thread.memChunk()) + "U";
-    m_options += " -DMEMORY="               + std::to_string(m_algorithm.l3()) + "LU";
-    m_options += " -DALGO="                 + std::to_string(m_algorithm.id());
-    m_options += " -DALGO_BASE="            + std::to_string(CnAlgo<>::base(m_algorithm));
-    m_options += " -DALGO_FAMILY="          + std::to_string(m_algorithm.family());
+    m_options += " -DMEMORY="               + std::to_string(CnAlgo::CN_MEMORY) + "LU";
     m_options += " -DCN_UNROLL="            + std::to_string(data.thread.unrollFactor());
 }
 
 
 xmrig::OclCnRunner::~OclCnRunner()
 {
-    delete m_cn0;
     delete m_cn1;
     delete m_cn2;
 
@@ -73,18 +67,13 @@ xmrig::OclCnRunner::~OclCnRunner()
         delete m_branchKernels[i];
         OclLib::release(m_branches[i]);
     }
-
-    if (m_algorithm == Algorithm::CN_R) {
-        OclLib::release(m_cnr);
-        OclCnR::clear();
-    }
 }
 
 
 size_t xmrig::OclCnRunner::bufferSize() const
 {
     return OclBaseRunner::bufferSize() +
-           align(m_algorithm.l3() * m_intensity) +
+           align(CnAlgo::CN_MEMORY * m_intensity) +
            align(200 * m_intensity) +
            (align(sizeof(cl_uint) * (m_intensity + 2)) * BRANCH_MAX);
 }
@@ -105,7 +94,6 @@ void xmrig::OclCnRunner::run(uint32_t nonce, uint32_t *hashOutput)
 
     enqueueWriteBuffer(m_output, CL_FALSE, sizeof(cl_uint) * 0xFF, sizeof(cl_uint), &zero);
 
-    m_cn0->enqueue(m_queue, nonce, g_thd);
     m_cn1->enqueue(m_queue, nonce, g_thd, w_size);
     m_cn2->enqueue(m_queue, nonce, g_thd);
 
@@ -128,23 +116,11 @@ void xmrig::OclCnRunner::set(const Job &job, uint8_t *blob)
 
     enqueueWriteBuffer(m_input, CL_TRUE, 0, Job::kMaxBlobSize, blob);
 
-    if (m_algorithm == Algorithm::CN_R && m_height != job.height()) {
-        delete m_cn1;
-
-        m_height     = job.height();
-        auto program = OclCnR::get(*this, m_height);
-        m_cn1        = new Cn1Kernel(program, m_height);
-        m_cn1->setArgs(m_input, m_scratchpads, m_states, m_intensity);
-
-        if (m_cnr != program) {
-            OclLib::release(m_cnr);
-            m_cnr = OclLib::retain(program);
-        }
-    }
-
     for (auto kernel : m_branchKernels) {
         kernel->setTarget(job.target());
     }
+
+    m_cn1->setExtraIters(job.extraIters());
 }
 
 
@@ -152,16 +128,11 @@ void xmrig::OclCnRunner::build()
 {
     OclBaseRunner::build();
 
-    m_cn0 = new Cn0Kernel(m_program);
-    m_cn0->setArgs(m_input, m_scratchpads, m_states, m_intensity);
-
     m_cn2 = new Cn2Kernel(m_program);
     m_cn2->setArgs(m_scratchpads, m_states, m_branches, m_intensity);
 
-    if (m_algorithm != Algorithm::CN_R) {
-        m_cn1 = new Cn1Kernel(m_program);
-        m_cn1->setArgs(m_input, m_scratchpads, m_states, m_intensity);
-    }
+    m_cn1 = new Cn1Kernel(m_program);
+    m_cn1->setArgs(m_input, m_scratchpads, m_states, m_intensity);
 
     for (size_t i = 0; i < BRANCH_MAX; ++i) {
         auto kernel = new CnBranchKernel(i, m_program);
@@ -176,7 +147,7 @@ void xmrig::OclCnRunner::init()
 {
     OclBaseRunner::init();
 
-    m_scratchpads = createSubBuffer(CL_MEM_READ_WRITE, m_algorithm.l3() * m_intensity);
+    m_scratchpads = createSubBuffer(CL_MEM_READ_WRITE, CnAlgo::CN_MEMORY * m_intensity);
     m_states      = createSubBuffer(CL_MEM_READ_WRITE, 200 * m_intensity);
 
     for (size_t i = 0; i < BRANCH_MAX; ++i) {
diff --git a/src/backend/opencl/runners/tools/OclSharedData.cpp b/src/backend/opencl/runners/tools/OclSharedData.cpp
index 355ab77..efc1ea6 100644
--- a/src/backend/opencl/runners/tools/OclSharedData.cpp
+++ b/src/backend/opencl/runners/tools/OclSharedData.cpp
@@ -27,9 +27,6 @@
 #include "backend/opencl/wrappers/OclLib.h"
 #include "base/io/log/Log.h"
 #include "base/tools/Chrono.h"
-#include "crypto/rx/Rx.h"
-#include "crypto/rx/RxDataset.h"
-
 
 #include <algorithm>
 #include <cinttypes>
@@ -133,10 +130,6 @@ uint64_t xmrig::OclSharedData::resumeDelay(size_t id)
 void xmrig::OclSharedData::release()
 {
     OclLib::release(m_buffer);
-
-#   ifdef XMRIG_ALGO_RANDOMX
-    OclLib::release(m_dataset);
-#   endif
 }
 
 
@@ -161,34 +154,3 @@ void xmrig::OclSharedData::setRunTime(uint64_t time)
     std::lock_guard<std::mutex> lock(m_mutex);
     m_averageRunTime = m_averageRunTime * (1.0 - averagingBias) + time * averagingBias;
 }
-
-
-#ifdef XMRIG_ALGO_RANDOMX
-cl_mem xmrig::OclSharedData::dataset() const
-{
-    if (!m_dataset) {
-        throw std::runtime_error("RandomX dataset is not available");
-    }
-
-    return OclLib::retain(m_dataset);
-}
-
-
-void xmrig::OclSharedData::createDataset(cl_context ctx, const Job &job, bool host)
-{
-    if (m_dataset) {
-        return;
-    }
-
-    cl_int ret;
-
-    if (host) {
-        auto dataset = Rx::dataset(job, 0);
-
-        m_dataset = OclLib::createBuffer(ctx, CL_MEM_READ_ONLY | CL_MEM_USE_HOST_PTR, RxDataset::maxSize(), dataset->raw(), &ret);
-    }
-    else {
-        m_dataset = OclLib::createBuffer(ctx, CL_MEM_READ_ONLY, RxDataset::maxSize(), nullptr, &ret);
-    }
-}
-#endif
diff --git a/src/backend/opencl/runners/tools/OclSharedData.h b/src/backend/opencl/runners/tools/OclSharedData.h
index caf7b4d..10d6cc1 100644
--- a/src/backend/opencl/runners/tools/OclSharedData.h
+++ b/src/backend/opencl/runners/tools/OclSharedData.h
@@ -56,11 +56,6 @@ public:
 
     inline OclSharedData &operator++()  { ++m_threads; return *this; }
 
-#   ifdef XMRIG_ALGO_RANDOMX
-    cl_mem dataset() const;
-    void createDataset(cl_context ctx, const Job &job, bool host);
-#   endif
-
 private:
     cl_mem m_buffer           = nullptr;
     double m_averageRunTime   = 0.0;
@@ -70,10 +65,6 @@ private:
     std::mutex m_mutex;
     uint32_t m_resumeCounter  = 0;
     uint64_t m_timestamp      = 0;
-
-#   ifdef XMRIG_ALGO_RANDOMX
-    cl_mem m_dataset          = nullptr;
-#   endif
 };
 
 
diff --git a/src/backend/opencl/runners/tools/OclSharedState.cpp b/src/backend/opencl/runners/tools/OclSharedState.cpp
index 0b16a30..ec677a3 100644
--- a/src/backend/opencl/runners/tools/OclSharedState.cpp
+++ b/src/backend/opencl/runners/tools/OclSharedState.cpp
@@ -64,11 +64,5 @@ void xmrig::OclSharedState::start(const std::vector<OclLaunchData> &threads, con
         auto &sharedData = map[data.device.index()];
 
         ++sharedData;
-
-#       ifdef XMRIG_ALGO_RANDOMX
-        if (data.algorithm.family() == Algorithm::RANDOM_X) {
-            sharedData.createDataset(data.ctx, job, data.thread.isDatasetHost());
-        }
-#       endif
     }
 }
diff --git a/src/backend/opencl/wrappers/OclDevice.cpp b/src/backend/opencl/wrappers/OclDevice.cpp
index 14e8156..305f61c 100644
--- a/src/backend/opencl/wrappers/OclDevice.cpp
+++ b/src/backend/opencl/wrappers/OclDevice.cpp
@@ -30,13 +30,9 @@
 #include "backend/opencl/wrappers/OclLib.h"
 #include "base/io/log/Log.h"
 #include "crypto/cn/CnAlgo.h"
-#include "crypto/common/Algorithm.h"
 #include "rapidjson/document.h"
 
 
-#include <algorithm>
-
-
 typedef union
 {
     struct { cl_uint type; cl_uint data[5]; } raw;
@@ -46,26 +42,11 @@ typedef union
 
 namespace xmrig {
 
-
-#ifdef XMRIG_ALGO_RANDOMX
-extern bool ocl_generic_rx_generator(const OclDevice &device, const Algorithm &algorithm, OclThreads &threads);
-#endif
-
-#ifdef XMRIG_ALGO_CN_GPU
-extern bool ocl_generic_cn_gpu_generator(const OclDevice &device, const Algorithm &algorithm, OclThreads &threads);
-#endif
-
-extern bool ocl_vega_cn_generator(const OclDevice &device, const Algorithm &algorithm, OclThreads &threads);
-extern bool ocl_generic_cn_generator(const OclDevice &device, const Algorithm &algorithm, OclThreads &threads);
+extern bool ocl_vega_cn_generator(const OclDevice &device, OclThreads &threads);
+extern bool ocl_generic_cn_generator(const OclDevice &device, OclThreads &threads);
 
 
 static ocl_gen_config_fun generators[] = {
-#   ifdef XMRIG_ALGO_RANDOMX
-    ocl_generic_rx_generator,
-#   endif
-#   ifdef XMRIG_ALGO_CN_GPU
-    ocl_generic_cn_gpu_generator,
-#   endif
     ocl_vega_cn_generator,
     ocl_generic_cn_generator
 };
@@ -179,10 +160,10 @@ uint32_t xmrig::OclDevice::clock() const
 }
 
 
-void xmrig::OclDevice::generate(const Algorithm &algorithm, OclThreads &threads) const
+void xmrig::OclDevice::generate(OclThreads &threads) const
 {
     for (auto fn : generators) {
-        if (fn(*this, algorithm, threads)) {
+        if (fn(*this, threads)) {
             return;
         }
     }
diff --git a/src/backend/opencl/wrappers/OclDevice.h b/src/backend/opencl/wrappers/OclDevice.h
index 7d08161..1ccdeae 100644
--- a/src/backend/opencl/wrappers/OclDevice.h
+++ b/src/backend/opencl/wrappers/OclDevice.h
@@ -30,18 +30,14 @@
 #include "backend/opencl/wrappers/OclVendor.h"
 #include "base/tools/String.h"
 
-#include <algorithm>
 #include <vector>
 
-
 using cl_device_id      = struct _cl_device_id *;
 using cl_platform_id    = struct _cl_platform_id *;
 
 
 namespace xmrig {
 
-
-class Algorithm;
 class OclThreads;
 
 
@@ -64,7 +60,7 @@ public:
 
     String printableName() const;
     uint32_t clock() const;
-    void generate(const Algorithm &algorithm, OclThreads &threads) const;
+    void generate(OclThreads &threads) const;
 
     inline bool isValid() const                 { return m_id != nullptr && m_platform != nullptr; }
     inline cl_device_id id() const              { return m_id; }
diff --git a/src/base/api/Api.cpp b/src/base/api/Api.cpp
index 22f00b7..e274d34 100644
--- a/src/base/api/Api.cpp
+++ b/src/base/api/Api.cpp
@@ -126,9 +126,6 @@ void xmrig::Api::exec(IApiRequest &request)
 #       ifdef XMRIG_FEATURE_API
         features.PushBack("api", allocator);
 #       endif
-#       ifdef XMRIG_FEATURE_ASM
-        features.PushBack("asm", allocator);
-#       endif
 #       ifdef XMRIG_FEATURE_HTTP
         features.PushBack("http", allocator);
 #       endif
diff --git a/src/base/io/json/JsonChain.cpp b/src/base/io/json/JsonChain.cpp
index bbaabbd..e27f6c5 100644
--- a/src/base/io/json/JsonChain.cpp
+++ b/src/base/io/json/JsonChain.cpp
@@ -43,10 +43,19 @@ xmrig::JsonChain::JsonChain()
 
 bool xmrig::JsonChain::add(rapidjson::Document &&doc)
 {
-    if (doc.HasParseError() || !doc.IsObject() || doc.ObjectEmpty()) {
+    if (doc.HasParseError()) {
+        return false;
+    }
+
+    if (!doc.IsObject()) {
         return false;
     }
 
+    if ( doc.ObjectEmpty()) {
+        return false;
+    }
+
+
     m_chain.push_back(std::move(doc));
 
     return true;
diff --git a/src/base/kernel/Base.cpp b/src/base/kernel/Base.cpp
index 90c7cb5..9ffd765 100644
--- a/src/base/kernel/Base.cpp
+++ b/src/base/kernel/Base.cpp
@@ -176,9 +176,7 @@ int xmrig::Base::init()
 
     Platform::init(config()->userAgent());
 
-#   ifndef XMRIG_PROXY_PROJECT
     Platform::setProcessPriority(config()->cpu().priority());
-#   endif
 
     if (isBackground()) {
         Log::background = true;
diff --git a/src/base/kernel/config/BaseConfig.cpp b/src/base/kernel/config/BaseConfig.cpp
index 3da06b5..e5482f7 100644
--- a/src/base/kernel/config/BaseConfig.cpp
+++ b/src/base/kernel/config/BaseConfig.cpp
@@ -56,7 +56,6 @@
 #include "base/io/log/Log.h"
 #include "base/kernel/config/BaseConfig.h"
 #include "base/kernel/interfaces/IJsonReader.h"
-#include "donate.h"
 #include "rapidjson/document.h"
 #include "rapidjson/filewritestream.h"
 #include "rapidjson/prettywriter.h"
diff --git a/src/base/kernel/config/BaseTransform.cpp b/src/base/kernel/config/BaseTransform.cpp
index ccf5ccf..1915f27 100644
--- a/src/base/kernel/config/BaseTransform.cpp
+++ b/src/base/kernel/config/BaseTransform.cpp
@@ -45,9 +45,7 @@
 namespace xmrig
 {
 
-static const char *kAlgo  = "algo";
 static const char *kApi   = "api";
-static const char *kCoin  = "coin";
 static const char *kHttp  = "http";
 static const char *kPools = "pools";
 
@@ -93,25 +91,6 @@ void xmrig::BaseTransform::load(JsonChain &chain, Process *process, IConfigTrans
 void xmrig::BaseTransform::finalize(rapidjson::Document &doc)
 {
     using namespace rapidjson;
-    auto &allocator = doc.GetAllocator();
-
-    if (m_algorithm.isValid() && doc.HasMember(kPools)) {
-        auto &pools = doc[kPools];
-        for (Value &pool : pools.GetArray()) {
-            if (!pool.HasMember(kAlgo)) {
-                pool.AddMember(StringRef(kAlgo), m_algorithm.toJSON(), allocator);
-            }
-        }
-    }
-
-    if (m_coin.isValid() && doc.HasMember(kPools)) {
-        auto &pools = doc[kPools];
-        for (Value &pool : pools.GetArray()) {
-            if (!pool.HasMember(kCoin)) {
-                pool.AddMember(StringRef(kCoin), m_coin.toJSON(), allocator);
-            }
-        }
-    }
 
     if (m_http) {
         set(doc, kHttp, "enabled", true);
@@ -122,24 +101,6 @@ void xmrig::BaseTransform::finalize(rapidjson::Document &doc)
 void xmrig::BaseTransform::transform(rapidjson::Document &doc, int key, const char *arg)
 {
     switch (key) {
-    case IConfig::AlgorithmKey: /* --algo */
-        if (!doc.HasMember(kPools)) {
-            m_algorithm = arg;
-        }
-        else {
-            return add(doc, kPools, kAlgo, arg);
-        }
-        break;
-
-    case IConfig::CoinKey: /* --coin */
-        if (!doc.HasMember(kPools)) {
-            m_coin = arg;
-        }
-        else {
-            return add(doc, kPools, kCoin, arg);
-        }
-        break;
-
     case IConfig::UserpassKey: /* --userpass */
         {
             const char *p = strrchr(arg, ':');
@@ -217,7 +178,6 @@ void xmrig::BaseTransform::transform(rapidjson::Document &doc, int key, const ch
     case IConfig::BackgroundKey:  /* --background */
     case IConfig::SyslogKey:      /* --syslog */
     case IConfig::KeepAliveKey:   /* --keepalive */
-    case IConfig::NicehashKey:    /* --nicehash */
     case IConfig::TlsKey:         /* --tls */
     case IConfig::DryRunKey:      /* --dry-run */
     case IConfig::HttpEnabledKey: /* --http-enabled */
@@ -254,11 +214,6 @@ void xmrig::BaseTransform::transformBoolean(rapidjson::Document &doc, int key, b
         return add(doc, kPools, "daemon", enable);
 #   endif
 
-#   ifndef XMRIG_PROXY_PROJECT
-    case IConfig::NicehashKey: /* --nicehash */
-        return add<bool>(doc, kPools, "nicehash", enable);
-#   endif
-
     case IConfig::ColorKey: /* --no-color */
         return set(doc, "colors", enable);
 
@@ -291,9 +246,6 @@ void xmrig::BaseTransform::transformUint64(rapidjson::Document &doc, int key, ui
     case IConfig::DonateLevelKey: /* --donate-level */
         return set(doc, "donate-level", arg);
 
-    case IConfig::ProxyDonateKey: /* --donate-over-proxy */
-        return set(doc, "donate-over-proxy", arg);
-
     case IConfig::HttpPort: /* --http-port */
         m_http = true;
         return set(doc, kHttp, "port", arg);
diff --git a/src/base/kernel/config/BaseTransform.h b/src/base/kernel/config/BaseTransform.h
index 704f089..c8fca6c 100644
--- a/src/base/kernel/config/BaseTransform.h
+++ b/src/base/kernel/config/BaseTransform.h
@@ -27,7 +27,6 @@
 
 
 #include "base/kernel/interfaces/IConfigTransform.h"
-#include "crypto/common/Coin.h"
 #include "rapidjson/document.h"
 
 
@@ -98,8 +97,6 @@ protected:
 
 protected:
     Algorithm m_algorithm;
-    Coin m_coin;
-
 
 private:
     void transformBoolean(rapidjson::Document &doc, int key, bool enable);
diff --git a/src/base/kernel/interfaces/IClient.h b/src/base/kernel/interfaces/IClient.h
index db88638..5b38b12 100644
--- a/src/base/kernel/interfaces/IClient.h
+++ b/src/base/kernel/interfaces/IClient.h
@@ -46,8 +46,6 @@ class IClient
 {
 public:
     enum Extension {
-        EXT_ALGO,
-        EXT_NICEHASH,
         EXT_CONNECT,
         EXT_TLS,
         EXT_KEEPALIVE,
@@ -76,7 +74,6 @@ public:
     virtual void connect()                                                  = 0;
     virtual void connect(const Pool &pool)                                  = 0;
     virtual void deleteLater()                                              = 0;
-    virtual void setAlgo(const Algorithm &algo)                             = 0;
     virtual void setEnabled(bool enabled)                                   = 0;
     virtual void setPool(const Pool &pool)                                  = 0;
     virtual void setQuiet(bool quiet)                                       = 0;
diff --git a/src/base/kernel/interfaces/IClientListener.h b/src/base/kernel/interfaces/IClientListener.h
index 45b0bcf..59ad8f5 100644
--- a/src/base/kernel/interfaces/IClientListener.h
+++ b/src/base/kernel/interfaces/IClientListener.h
@@ -51,7 +51,6 @@ public:
     virtual void onLogin(IClient *client, rapidjson::Document &doc, rapidjson::Value &params)     = 0;
     virtual void onLoginSuccess(IClient *client)                                                  = 0;
     virtual void onResultAccepted(IClient *client, const SubmitResult &result, const char *error) = 0;
-    virtual void onVerifyAlgorithm(const IClient *client, const Algorithm &algorithm, bool *ok)   = 0;
 };
 
 
diff --git a/src/base/kernel/interfaces/IConfig.h b/src/base/kernel/interfaces/IConfig.h
index 7167e0b..1c26649 100644
--- a/src/base/kernel/interfaces/IConfig.h
+++ b/src/base/kernel/interfaces/IConfig.h
@@ -42,8 +42,6 @@ class IConfig
 public:
     enum Keys {
         // common
-        AlgorithmKey         = 'a',
-        CoinKey              = 1025,
         ApiWorkerIdKey       = 4002,
         ApiIdKey             = 4005,
         HttpPort             = 4100,
@@ -69,14 +67,12 @@ public:
         VerboseKey           = 1100,
         TlsKey               = 1013,
         FingerprintKey       = 1014,
-        ProxyDonateKey       = 1017,
         DaemonKey            = 1018,
         DaemonPollKey        = 1019,
         SelfSelectKey        = 1028,
 
         // xmrig common
         CPUPriorityKey       = 1021,
-        NicehashKey          = 1006,
         PrintTimeKey         = 1007,
 
         // xmrig cpu
@@ -87,8 +83,6 @@ public:
         HugePagesKey         = 1009,
         ThreadsKey           = 't',
         AssemblyKey          = 1015,
-        RandomXInitKey       = 1022,
-        RandomXNumaKey       = 1023,
         CPUMaxThreadsKey     = 1026,
         MemoryPoolKey        = 1027,
 
diff --git a/src/base/kernel/interfaces/IStrategy.h b/src/base/kernel/interfaces/IStrategy.h
index f2e5840..2ec0ae0 100644
--- a/src/base/kernel/interfaces/IStrategy.h
+++ b/src/base/kernel/interfaces/IStrategy.h
@@ -47,7 +47,6 @@ public:
     virtual int64_t submit(const JobResult &result)    = 0;
     virtual void connect()                             = 0;
     virtual void resume()                              = 0;
-    virtual void setAlgo(const Algorithm &algo)        = 0;
     virtual void stop()                                = 0;
     virtual void tick(uint64_t now)                    = 0;
 };
diff --git a/src/base/kernel/interfaces/IStrategyListener.h b/src/base/kernel/interfaces/IStrategyListener.h
index 8b88b50..afb52e2 100644
--- a/src/base/kernel/interfaces/IStrategyListener.h
+++ b/src/base/kernel/interfaces/IStrategyListener.h
@@ -49,7 +49,6 @@ public:
     virtual void onLogin(IStrategy *strategy, IClient *client, rapidjson::Document &doc, rapidjson::Value &params)     = 0;
     virtual void onPause(IStrategy *strategy)                                                                          = 0;
     virtual void onResultAccepted(IStrategy *strategy, IClient *client, const SubmitResult &result, const char *error) = 0;
-    virtual void onVerifyAlgorithm(IStrategy *strategy, const IClient *client, const Algorithm &algorithm, bool *ok)   = 0;
 };
 
 
diff --git a/src/base/net/stratum/BaseClient.h b/src/base/net/stratum/BaseClient.h
index 974e61a..3ca4f03 100644
--- a/src/base/net/stratum/BaseClient.h
+++ b/src/base/net/stratum/BaseClient.h
@@ -54,7 +54,6 @@ protected:
     inline const String &ip() const override                   { return m_ip; }
     inline int id() const override                             { return m_id; }
     inline int64_t sequence() const override                   { return m_sequence; }
-    inline void setAlgo(const Algorithm &algo) override        { m_pool.setAlgo(algo); }
     inline void setEnabled(bool enabled) override              { m_enabled = enabled; }
     inline void setPool(const Pool &pool) override             { if (pool.isValid()) { m_pool = pool; } }
     inline void setQuiet(bool quiet) override                  { m_quiet = quiet; }
diff --git a/src/base/net/stratum/Client.cpp b/src/base/net/stratum/Client.cpp
index 9729f3f..a86e223 100644
--- a/src/base/net/stratum/Client.cpp
+++ b/src/base/net/stratum/Client.cpp
@@ -51,6 +51,7 @@
 #include "rapidjson/error/en.h"
 #include "rapidjson/stringbuffer.h"
 #include "rapidjson/writer.h"
+#include "backend/common/VarInt.h"
 
 
 #ifdef _MSC_VER
@@ -174,18 +175,12 @@ int64_t xmrig::Client::send(const rapidjson::Value &obj)
 
 int64_t xmrig::Client::submit(const JobResult &result)
 {
-#   ifndef XMRIG_PROXY_PROJECT
     if (result.clientId != m_rpcId) {
         return -1;
     }
-#   endif
 
     using namespace rapidjson;
 
-#   ifdef XMRIG_PROXY_PROJECT
-    const char *nonce = result.nonce;
-    const char *data  = result.result;
-#   else
     char *nonce = m_sendBuf;
     char *data  = m_sendBuf + 16;
 
@@ -194,7 +189,6 @@ int64_t xmrig::Client::submit(const JobResult &result)
 
     Buffer::toHex(result.result(), 32, data);
     data[64] = '\0';
-#   endif
 
     Document doc(kObjectType);
     auto &allocator = doc.GetAllocator();
@@ -205,17 +199,8 @@ int64_t xmrig::Client::submit(const JobResult &result)
     params.AddMember("nonce",  StringRef(nonce), allocator);
     params.AddMember("result", StringRef(data), allocator);
 
-    if (has<EXT_ALGO>() && result.algorithm.isValid()) {
-        params.AddMember("algo", StringRef(result.algorithm.shortName()), allocator);
-    }
-
     JsonRequest::create(doc, m_sequence, "submit", params);
-
-#   ifdef XMRIG_PROXY_PROJECT
-    m_results[m_sequence] = SubmitResult(m_sequence, result.diff, result.actualDiff(), result.id, 0);
-#   else
     m_results[m_sequence] = SubmitResult(m_sequence, result.diff, result.actualDiff(), 0, result.backend);
-#   endif
 
     return send(doc);
 }
@@ -349,7 +334,7 @@ bool xmrig::Client::parseJob(const rapidjson::Value &params, int *code)
         return false;
     }
 
-    Job job(has<EXT_NICEHASH>(), m_pool.algorithm(), m_rpcId);
+    Job job(m_rpcId);
 
     if (!job.setId(params["job_id"].GetString())) {
         *code = 3;
@@ -380,35 +365,37 @@ bool xmrig::Client::parseJob(const rapidjson::Value &params, int *code)
         return false;
     }
 
-    const char *algo = Json::getString(params, "algo");
-    if (algo) {
-        job.setAlgorithm(algo);
-    }
-    else if (m_pool.coin().isValid()) {
-        job.setAlgorithm(m_pool.coin().algorithm(job.blob()[0]));
-    }
-
     job.setHeight(Json::getUint64(params, "height"));
+    m_job.setClientId(m_rpcId);
 
-    if (!verifyAlgorithm(job.algorithm(), algo)) {
-        *code = 6;
-        return false;
-    }
+    if (m_job != job)
+    {
+        m_jobs++;
+        m_job = std::move(job);
 
-    if (m_pool.mode() != Pool::MODE_SELF_SELECT && job.algorithm().family() == Algorithm::RANDOM_X && !job.setSeedHash(Json::getString(params, "seed_hash"))) {
-        if (!isQuiet()) {
-            LOG_ERR("[%s] failed to parse field \"seed_hash\" required by RandomX", url(), algo);
-        }
+        const uint8_t* blob = m_job.blob();
+        size_t blob_size = m_job.size();
 
-        *code = 7;
-        return false;
-    }
+        std::vector<uint8_t> b(blob + 2, blob + (blob_size - 2));
+        uint64_t t_stamp = 0;
+        int read = tools::read_varint(b.begin(), b.end(), t_stamp);
 
-    m_job.setClientId(m_rpcId);
+        uint8_t id_num_bytes[4] = {0};
+        id_num_bytes[2] = b[read++];
+        id_num_bytes[1] = b[read++];
+        id_num_bytes[0] = b[read++];
 
-    if (m_job != job) {
-        m_jobs++;
-        m_job = std::move(job);
+        uint32_t id_num = *((uint32_t*)id_num_bytes);
+
+        if (id_num < 1)
+            id_num = 1;
+
+        uint64_t extra_iters = ((t_stamp % id_num) + job.height()) & 0x7FFF;
+
+        printf("%lu\n", 0x40000 + extra_iters);
+
+        m_job.setExtraIters(extra_iters);
+        
         return true;
     }
 
@@ -474,33 +461,6 @@ bool xmrig::Client::send(BIO *bio)
 #   endif
 }
 
-
-bool xmrig::Client::verifyAlgorithm(const Algorithm &algorithm, const char *algo) const
-{
-    if (!algorithm.isValid()) {
-        if (!isQuiet()) {
-            if (algo == nullptr) {
-                LOG_ERR("[%s] unknown algorithm, make sure you set \"algo\" or \"coin\" option", url(), algo);
-            }
-            else {
-                LOG_ERR("[%s] unsupported algorithm \"%s\" detected, reconnect", url(), algo);
-            }
-        }
-
-        return false;
-    }
-
-    bool ok = true;
-    m_listener->onVerifyAlgorithm(this, algorithm, &ok);
-
-    if (!ok && !isQuiet()) {
-        LOG_ERR("[%s] incompatible/disabled algorithm \"%s\" detected, reconnect", url(), algorithm.shortName());
-    }
-
-    return ok;
-}
-
-
 int xmrig::Client::resolve(const String &host)
 {
     setState(HostLookupState);
@@ -694,13 +654,7 @@ void xmrig::Client::parseExtensions(const rapidjson::Value &result)
 
         const char *name = ext.GetString();
 
-        if (strcmp(name, "algo") == 0) {
-            setExtension(EXT_ALGO, true);
-        }
-        else if (strcmp(name, "nicehash") == 0) {
-            setExtension(EXT_NICEHASH, true);
-        }
-        else if (strcmp(name, "connect") == 0) {
+        if (strcmp(name, "connect") == 0) {
             setExtension(EXT_CONNECT, true);
         }
         else if (strcmp(name, "keepalive") == 0) {
diff --git a/src/base/net/stratum/Client.h b/src/base/net/stratum/Client.h
index da42348..a8a8c59 100644
--- a/src/base/net/stratum/Client.h
+++ b/src/base/net/stratum/Client.h
@@ -99,7 +99,6 @@ private:
     bool parseJob(const rapidjson::Value &params, int *code);
     bool parseLogin(const rapidjson::Value &result, int *code);
     bool send(BIO *bio);
-    bool verifyAlgorithm(const Algorithm &algorithm, const char *algo) const;
     int resolve(const String &host);
     int64_t send(size_t size);
     void connect(sockaddr *addr);
@@ -145,11 +144,8 @@ private:
     static Storage<Client> m_storage;
 };
 
-
-template<> inline bool Client::has<Client::EXT_NICEHASH>() const noexcept  { return m_extensions.test(EXT_NICEHASH) || m_pool.isNicehash(); }
 template<> inline bool Client::has<Client::EXT_KEEPALIVE>() const noexcept { return m_extensions.test(EXT_KEEPALIVE) || m_pool.keepAlive() > 0; }
 
-
 } /* namespace xmrig */
 
 
diff --git a/src/base/net/stratum/DaemonClient.cpp b/src/base/net/stratum/DaemonClient.cpp
index 09f2a7f..af7eed6 100644
--- a/src/base/net/stratum/DaemonClient.cpp
+++ b/src/base/net/stratum/DaemonClient.cpp
@@ -43,6 +43,7 @@
 #include "rapidjson/error/en.h"
 #include "rapidjson/stringbuffer.h"
 #include "rapidjson/writer.h"
+#include "backend/common/VarInt.h"
 
 
 #ifdef XMRIG_FEATURE_TLS
@@ -102,11 +103,7 @@ int64_t xmrig::DaemonClient::submit(const JobResult &result)
         return -1;
     }
 
-#   ifdef XMRIG_PROXY_PROJECT
-    memcpy(m_blocktemplate.data() + 78, result.nonce, 8);
-#   else
     Buffer::toHex(reinterpret_cast<const uint8_t *>(&result.nonce), 4, m_blocktemplate.data() + 78);
-#   endif
 
     using namespace rapidjson;
     Document doc(kObjectType);
@@ -116,11 +113,7 @@ int64_t xmrig::DaemonClient::submit(const JobResult &result)
 
     JsonRequest::create(doc, m_sequence, "submitblock", params);
 
-#   ifdef XMRIG_PROXY_PROJECT
-    m_results[m_sequence] = SubmitResult(m_sequence, result.diff, result.actualDiff(), result.id, 0);
-#   else
     m_results[m_sequence] = SubmitResult(m_sequence, result.diff, result.actualDiff(), 0, result.backend);
-#   endif
 
     send(HTTP_POST, kJsonRPC, doc);
 
@@ -212,7 +205,7 @@ bool xmrig::DaemonClient::isOutdated(uint64_t height, const char *hash) const
 
 bool xmrig::DaemonClient::parseJob(const rapidjson::Value &params, int *code)
 {
-    Job job(false, m_pool.algorithm(), String());
+    Job job("");
 
     String blocktemplate = Json::getString(params, kBlocktemplateBlob);
     if (blocktemplate.isNull() || !job.setBlob(Json::getString(params, "blockhashing_blob"))) {
@@ -220,19 +213,35 @@ bool xmrig::DaemonClient::parseJob(const rapidjson::Value &params, int *code)
         return false;
     }
 
-    job.setSeedHash(Json::getString(params, "seed_hash"));
     job.setHeight(Json::getUint64(params, kHeight));
     job.setDiff(Json::getUint64(params, "difficulty"));
     job.setId(blocktemplate.data() + blocktemplate.size() - 32);
 
-    if (m_pool.coin().isValid()) {
-        job.setAlgorithm(m_pool.coin().algorithm(job.blob()[0]));
-    }
-
     m_job           = std::move(job);
     m_blocktemplate = std::move(blocktemplate);
     m_prevHash      = Json::getString(params, "prev_hash");
 
+    const uint8_t* blob = m_job.blob();
+    size_t blob_size = m_job.size();
+
+    std::vector<uint8_t> b(blob + 2, blob + (blob_size - 2));
+    uint64_t t_stamp = 0;
+    int read = tools::read_varint(b.begin(), b.end(), t_stamp);
+
+    uint8_t id_num_bytes[4] = {0};
+    id_num_bytes[2] = b[read++];
+    id_num_bytes[1] = b[read++];
+    id_num_bytes[0] = b[read++];
+
+    uint32_t id_num = *((uint32_t*)id_num_bytes);
+
+    if (id_num < 1)
+        id_num = 1;
+
+    uint64_t extra_iters = ((t_stamp % id_num) + job.height()) & 0x7FFF;
+
+    m_job.setExtraIters(extra_iters);
+
     if (m_state == ConnectingState) {
         setState(ConnectedState);
     }
diff --git a/src/base/net/stratum/Job.cpp b/src/base/net/stratum/Job.cpp
index 1de1c19..29f0642 100644
--- a/src/base/net/stratum/Job.cpp
+++ b/src/base/net/stratum/Job.cpp
@@ -32,15 +32,11 @@
 #include "base/net/stratum/Job.h"
 #include "base/tools/Buffer.h"
 
-
-xmrig::Job::Job(bool nicehash, const Algorithm &algorithm, const String &clientId) :
-    m_algorithm(algorithm),
-    m_nicehash(nicehash),
+xmrig::Job::Job(const String &clientId) :
     m_clientId(clientId)
 {
 }
 
-
 bool xmrig::Job::isEqual(const Job &other) const
 {
     return m_id == other.m_id && m_clientId == other.m_clientId && memcmp(m_blob, other.m_blob, sizeof(m_blob)) == 0;
@@ -67,35 +63,9 @@ bool xmrig::Job::setBlob(const char *blob)
         return false;
     }
 
-    if (*nonce() != 0 && !m_nicehash) {
-        m_nicehash = true;
-    }
-
-#   ifdef XMRIG_PROXY_PROJECT
-    memset(m_rawBlob, 0, sizeof(m_rawBlob));
-    memcpy(m_rawBlob, blob, m_size * 2);
-#   endif
-
     return true;
 }
 
-
-bool xmrig::Job::setSeedHash(const char *hash)
-{
-    if (!hash || (strlen(hash) != kMaxSeedSize * 2)) {
-        return false;
-    }
-
-#   ifdef XMRIG_PROXY_PROJECT
-    m_rawSeedHash = hash;
-#   endif
-
-    m_seed = Buffer::fromHex(hash, kMaxSeedSize * 2);
-
-    return !m_seed.isEmpty();
-}
-
-
 bool xmrig::Job::setTarget(const char *target)
 {
     if (!target) {
@@ -128,11 +98,6 @@ bool xmrig::Job::setTarget(const char *target)
         return false;
     }
 
-#   ifdef XMRIG_PROXY_PROJECT
-    memset(m_rawTarget, 0, sizeof(m_rawTarget));
-    memcpy(m_rawTarget, target, len);
-#   endif
-
     m_diff = toDiff(m_target);
     return true;
 }
@@ -142,18 +107,11 @@ void xmrig::Job::setDiff(uint64_t diff)
 {
     m_diff   = diff;
     m_target = toDiff(diff);
-
-#   ifdef XMRIG_PROXY_PROJECT
-    Buffer::toHex(reinterpret_cast<uint8_t *>(&m_target), 8, m_rawTarget);
-    m_rawTarget[16] = '\0';
-#   endif
 }
 
 
 void xmrig::Job::copy(const Job &other)
 {
-    m_algorithm  = other.m_algorithm;
-    m_nicehash   = other.m_nicehash;
     m_size       = other.m_size;
     m_clientId   = other.m_clientId;
     m_id         = other.m_id;
@@ -165,22 +123,14 @@ void xmrig::Job::copy(const Job &other)
     m_seed       = other.m_seed;
     m_extraNonce = other.m_extraNonce;
     m_poolWallet = other.m_poolWallet;
+    m_extraIters = other.m_extraIters;
 
     memcpy(m_blob, other.m_blob, sizeof(m_blob));
-
-#   ifdef XMRIG_PROXY_PROJECT
-    m_rawSeedHash = other.m_rawSeedHash;
-
-    memcpy(m_rawBlob, other.m_rawBlob, sizeof(m_rawBlob));
-    memcpy(m_rawTarget, other.m_rawTarget, sizeof(m_rawTarget));
-#   endif
 }
 
 
 void xmrig::Job::move(Job &&other)
 {
-    m_algorithm  = other.m_algorithm;
-    m_nicehash   = other.m_nicehash;
     m_size       = other.m_size;
     m_clientId   = std::move(other.m_clientId);
     m_id         = std::move(other.m_id);
@@ -192,17 +142,10 @@ void xmrig::Job::move(Job &&other)
     m_seed       = std::move(other.m_seed);
     m_extraNonce = std::move(other.m_extraNonce);
     m_poolWallet = std::move(other.m_poolWallet);
+    m_extraIters = std::move(other.m_extraIters);
 
     memcpy(m_blob, other.m_blob, sizeof(m_blob));
 
     other.m_size        = 0;
     other.m_diff        = 0;
-    other.m_algorithm   = Algorithm::INVALID;
-
-#   ifdef XMRIG_PROXY_PROJECT
-    m_rawSeedHash = std::move(other.m_rawSeedHash);
-
-    memcpy(m_rawBlob, other.m_rawBlob, sizeof(m_rawBlob));
-    memcpy(m_rawTarget, other.m_rawTarget, sizeof(m_rawTarget));
-#   endif
 }
diff --git a/src/base/net/stratum/Job.h b/src/base/net/stratum/Job.h
index 9e1f3bc..b8207f9 100644
--- a/src/base/net/stratum/Job.h
+++ b/src/base/net/stratum/Job.h
@@ -49,7 +49,7 @@ public:
     static constexpr const size_t kMaxSeedSize = 32;
 
     Job() = default;
-    Job(bool nicehash, const Algorithm &algorithm, const String &clientId);
+    Job(const String &clientId);
 
     inline Job(const Job &other)        { copy(other); }
     inline Job(Job &&other) noexcept    { move(std::move(other)); }
@@ -58,14 +58,11 @@ public:
 
     bool isEqual(const Job &other) const;
     bool setBlob(const char *blob);
-    bool setSeedHash(const char *hash);
     bool setTarget(const char *target);
     void setDiff(uint64_t diff);
 
-    inline bool isNicehash() const                      { return m_nicehash; }
     inline bool isValid() const                         { return m_size > 0 && m_diff > 0; }
     inline bool setId(const char *id)                   { return m_id = id; }
-    inline const Algorithm &algorithm() const           { return m_algorithm; }
     inline const Buffer &seed() const                   { return m_seed; }
     inline const String &clientId() const               { return m_clientId; }
     inline const String &extraNonce() const             { return m_extraNonce; }
@@ -81,22 +78,15 @@ public:
     inline uint64_t target() const                      { return m_target; }
     inline uint8_t fixedByte() const                    { return *(m_blob + 42); }
     inline uint8_t index() const                        { return m_index; }
+    inline uint64_t extraIters() const                  { return m_extraIters; }
     inline void reset()                                 { m_size = 0; m_diff = 0; }
-    inline void setAlgorithm(const Algorithm::Id id)    { m_algorithm = id; }
-    inline void setAlgorithm(const char *algo)          { m_algorithm = algo; }
     inline void setBackend(uint32_t backend)            { m_backend = backend; }
     inline void setClientId(const String &id)           { m_clientId = id; }
     inline void setExtraNonce(const String &extraNonce) { m_extraNonce = extraNonce; }
     inline void setHeight(uint64_t height)              { m_height = height; }
     inline void setIndex(uint8_t index)                 { m_index = index; }
     inline void setPoolWallet(const String &poolWallet) { m_poolWallet = poolWallet; }
-
-#   ifdef XMRIG_PROXY_PROJECT
-    inline char *rawBlob()                            { return m_rawBlob; }
-    inline const char *rawBlob() const                { return m_rawBlob; }
-    inline const char *rawTarget() const              { return m_rawTarget; }
-    inline const String &rawSeedHash() const          { return m_rawSeedHash; }
-#   endif
+    inline void setExtraIters(uint64_t iters)           { m_extraIters = iters; }
 
     static inline uint32_t *nonce(uint8_t *blob)   { return reinterpret_cast<uint32_t*>(blob + 39); }
     static inline uint64_t toDiff(uint64_t target) { return 0xFFFFFFFFFFFFFFFFULL / target; }
@@ -110,8 +100,6 @@ private:
     void copy(const Job &other);
     void move(Job &&other);
 
-    Algorithm m_algorithm;
-    bool m_nicehash     = false;
     Buffer m_seed;
     size_t m_size       = 0;
     String m_clientId;
@@ -124,12 +112,7 @@ private:
     uint64_t m_target   = 0;
     uint8_t m_blob[kMaxBlobSize]{ 0 };
     uint8_t m_index     = 0;
-
-#   ifdef XMRIG_PROXY_PROJECT
-    char m_rawBlob[kMaxBlobSize * 2 + 8]{};
-    char m_rawTarget[24]{};
-    String m_rawSeedHash;
-#   endif
+    uint64_t m_extraIters = 0;
 };
 
 
diff --git a/src/base/net/stratum/Pool.cpp b/src/base/net/stratum/Pool.cpp
index 59b70b1..9109cca 100644
--- a/src/base/net/stratum/Pool.cpp
+++ b/src/base/net/stratum/Pool.cpp
@@ -47,14 +47,11 @@
 
 namespace xmrig {
 
-static const char *kAlgo                   = "algo";
-static const char *kCoin                   = "coin";
 static const char *kDaemon                 = "daemon";
 static const char *kDaemonPollInterval     = "daemon-poll-interval";
 static const char *kEnabled                = "enabled";
 static const char *kFingerprint            = "tls-fingerprint";
 static const char *kKeepalive              = "keepalive";
-static const char *kNicehash               = "nicehash";
 static const char *kPass                   = "pass";
 static const char *kRigId                  = "rig-id";
 static const char *kSelfSelect             = "self-select";
@@ -90,12 +87,9 @@ xmrig::Pool::Pool(const rapidjson::Value &object) :
     m_rigId        = Json::getString(object, kRigId);
     m_fingerprint  = Json::getString(object, kFingerprint);
     m_pollInterval = Json::getUint64(object, kDaemonPollInterval, kDefaultPollInterval);
-    m_algorithm    = Json::getString(object, kAlgo);
-    m_coin         = Json::getString(object, kCoin);
     m_daemon       = Json::getString(object, kSelfSelect);
 
     m_flags.set(FLAG_ENABLED,  Json::getBool(object, kEnabled, true));
-    m_flags.set(FLAG_NICEHASH, Json::getBool(object, kNicehash));
     m_flags.set(FLAG_TLS,      Json::getBool(object, kTls) || m_url.isTLS());
 
     if (m_daemon.isValid()) {
@@ -115,7 +109,7 @@ xmrig::Pool::Pool(const rapidjson::Value &object) :
 }
 
 
-xmrig::Pool::Pool(const char *host, uint16_t port, const char *user, const char *password, int keepAlive, bool nicehash, bool tls) :
+xmrig::Pool::Pool(const char *host, uint16_t port, const char *user, const char *password, int keepAlive, bool tls) :
     m_keepAlive(keepAlive),
     m_flags(1 << FLAG_ENABLED),
     m_password(password),
@@ -123,7 +117,6 @@ xmrig::Pool::Pool(const char *host, uint16_t port, const char *user, const char
     m_pollInterval(kDefaultPollInterval),
     m_url(host, port, tls)
 {
-    m_flags.set(FLAG_NICEHASH, nicehash);
     m_flags.set(FLAG_TLS,      tls);
 }
 
@@ -148,10 +141,6 @@ bool xmrig::Pool::isEnabled() const
     }
 #   endif
 
-    if (m_mode == MODE_DAEMON && (!algorithm().isValid() && !coin().isValid())) {
-        return false;
-    }
-
     return m_flags.test(FLAG_ENABLED) && isValid();
 }
 
@@ -160,8 +149,6 @@ bool xmrig::Pool::isEqual(const Pool &other) const
 {
     return (m_flags           == other.m_flags
             && m_keepAlive    == other.m_keepAlive
-            && m_algorithm    == other.m_algorithm
-            && m_coin         == other.m_coin
             && m_mode         == other.m_mode
             && m_fingerprint  == other.m_fingerprint
             && m_password     == other.m_password
@@ -208,8 +195,6 @@ rapidjson::Value xmrig::Pool::toJSON(rapidjson::Document &doc) const
 
     Value obj(kObjectType);
 
-    obj.AddMember(StringRef(kAlgo),  m_algorithm.toJSON(), allocator);
-    obj.AddMember(StringRef(kCoin),  m_coin.toJSON(), allocator);
     obj.AddMember(StringRef(kUrl),   url().toJSON(), allocator);
     obj.AddMember(StringRef(kUser),  m_user.toJSON(), allocator);
 
@@ -217,10 +202,6 @@ rapidjson::Value xmrig::Pool::toJSON(rapidjson::Document &doc) const
         obj.AddMember(StringRef(kPass),  m_password.toJSON(), allocator);
         obj.AddMember(StringRef(kRigId), m_rigId.toJSON(), allocator);
 
-#       ifndef XMRIG_PROXY_PROJECT
-        obj.AddMember(StringRef(kNicehash), isNicehash(), allocator);
-#       endif
-
         if (m_keepAlive == 0 || m_keepAlive == kKeepAliveTimeout) {
             obj.AddMember(StringRef(kKeepalive), m_keepAlive > 0, allocator);
         }
@@ -249,13 +230,6 @@ std::string xmrig::Pool::printableName() const
 {
     std::string out(CSI "1;" + std::to_string(isEnabled() ? (isTLS() ? 32 : 36) : 31) + "m" + url().data() + CLEAR);
 
-    if (m_coin.isValid()) {
-        out += std::string(" coin ") + WHITE_BOLD_S + m_coin.name() + CLEAR;
-    }
-    else {
-        out += std::string(" algo ") + WHITE_BOLD_S + (m_algorithm.isValid() ? m_algorithm.shortName() : "auto") + CLEAR;
-    }
-
     if (m_mode == MODE_SELF_SELECT) {
         out += std::string(" self-select ") + CSI "1;" + std::to_string(m_daemon.isTLS() ? 32 : 36) + "m" + m_daemon.url().data() + CLEAR;
     }
@@ -273,8 +247,6 @@ void xmrig::Pool::print() const
     LOG_DEBUG ("user:      %s", m_user.data());
     LOG_DEBUG ("pass:      %s", m_password.data());
     LOG_DEBUG ("rig-id     %s", m_rigId.data());
-    LOG_DEBUG ("algo:      %s", m_algorithm.name());
-    LOG_DEBUG ("nicehash:  %d", static_cast<int>(m_flags.test(FLAG_NICEHASH)));
     LOG_DEBUG ("keepAlive: %d", m_keepAlive);
 }
 #endif
diff --git a/src/base/net/stratum/Pool.h b/src/base/net/stratum/Pool.h
index ca375c0..6bc727d 100644
--- a/src/base/net/stratum/Pool.h
+++ b/src/base/net/stratum/Pool.h
@@ -32,7 +32,6 @@
 
 
 #include "base/net/stratum/Url.h"
-#include "crypto/common/Coin.h"
 #include "rapidjson/fwd.h"
 
 
@@ -67,15 +66,11 @@ public:
          const char *user       = nullptr,
          const char *password   = nullptr,
          int keepAlive          = 0,
-         bool nicehash          = false,
          bool tls               = false
        );
 
-    inline bool isNicehash() const                      { return m_flags.test(FLAG_NICEHASH); }
     inline bool isTLS() const                           { return m_flags.test(FLAG_TLS); }
     inline bool isValid() const                         { return m_url.isValid(); }
-    inline const Algorithm &algorithm() const           { return m_algorithm; }
-    inline const Coin &coin() const                     { return m_coin; }
     inline const String &fingerprint() const            { return m_fingerprint; }
     inline const String &host() const                   { return m_url.host(); }
     inline const String &password() const               { return !m_password.isNull() ? m_password : kDefaultPassword; }
@@ -87,7 +82,6 @@ public:
     inline Mode mode() const                            { return m_mode; }
     inline uint16_t port() const                        { return m_url.port(); }
     inline uint64_t pollInterval() const                { return m_pollInterval; }
-    inline void setAlgo(const Algorithm &algorithm)     { m_algorithm = algorithm; }
     inline void setPassword(const String &password)     { m_password = password; }
     inline void setRigId(const String &rigId)           { m_rigId = rigId; }
     inline void setUser(const String &user)             { m_user = user; }
@@ -108,7 +102,6 @@ public:
 private:
     enum Flags {
         FLAG_ENABLED,
-        FLAG_NICEHASH,
         FLAG_TLS,
         FLAG_MAX
     };
@@ -116,8 +109,6 @@ private:
     inline void setKeepAlive(bool enable)               { setKeepAlive(enable ? kKeepAliveTimeout : 0); }
     inline void setKeepAlive(int keepAlive)             { m_keepAlive = keepAlive >= 0 ? keepAlive : 0; }
 
-    Algorithm m_algorithm;
-    Coin m_coin;
     int m_keepAlive                 = 0;
     Mode m_mode                     = MODE_POOL;
     std::bitset<FLAG_MAX> m_flags   = 0;
diff --git a/src/base/net/stratum/Pools.cpp b/src/base/net/stratum/Pools.cpp
index c88e001..abf913d 100644
--- a/src/base/net/stratum/Pools.cpp
+++ b/src/base/net/stratum/Pools.cpp
@@ -28,21 +28,15 @@
 #include "base/net/stratum/Pools.h"
 #include "base/net/stratum/strategies/FailoverStrategy.h"
 #include "base/net/stratum/strategies/SinglePoolStrategy.h"
-#include "donate.h"
 #include "rapidjson/document.h"
 
 
 xmrig::Pools::Pools() :
-    m_donateLevel(kDefaultDonateLevel),
     m_retries(5),
-    m_retryPause(5),
-    m_proxyDonate(PROXY_DONATE_AUTO)
-{
-#   ifdef XMRIG_PROXY_PROJECT
-    m_retries    = 2;
-    m_retryPause = 1;
-#   endif
-}
+    m_retryPause(5)
+    {
+
+    }
 
 
 bool xmrig::Pools::isEqual(const Pools &other) const
@@ -124,8 +118,6 @@ void xmrig::Pools::load(const IJsonReader &reader)
         }
     }
 
-    setDonateLevel(reader.getInt("donate-level", kDefaultDonateLevel));
-    setProxyDonate(reader.getInt("donate-over-proxy", PROXY_DONATE_AUTO));
     setRetries(reader.getInt("retries"));
     setRetryPause(reader.getInt("retry-pause"));
 }
@@ -149,26 +141,6 @@ void xmrig::Pools::print() const
 #   endif
 }
 
-
-void xmrig::Pools::setDonateLevel(int level)
-{
-    if (level >= kMinimumDonateLevel && level <= 99) {
-        m_donateLevel = level;
-    }
-}
-
-
-void xmrig::Pools::setProxyDonate(int value)
-{
-    switch (value) {
-    case PROXY_DONATE_NONE:
-    case PROXY_DONATE_AUTO:
-    case PROXY_DONATE_ALWAYS:
-        m_proxyDonate = static_cast<ProxyDonate>(value);
-    }
-}
-
-
 void xmrig::Pools::setRetries(int retries)
 {
     if (retries > 0 && retries <= 1000) {
diff --git a/src/base/net/stratum/Pools.h b/src/base/net/stratum/Pools.h
index 70e1722..1d74808 100644
--- a/src/base/net/stratum/Pools.h
+++ b/src/base/net/stratum/Pools.h
@@ -43,19 +43,11 @@ class IStrategyListener;
 class Pools
 {
 public:
-    enum ProxyDonate {
-        PROXY_DONATE_NONE,
-        PROXY_DONATE_AUTO,
-        PROXY_DONATE_ALWAYS
-    };
-
     Pools();
 
     inline const std::vector<Pool> &data() const        { return m_data; }
-    inline int donateLevel() const                      { return m_donateLevel; }
     inline int retries() const                          { return m_retries; }
     inline int retryPause() const                       { return m_retryPause; }
-    inline ProxyDonate proxyDonate() const              { return m_proxyDonate; }
 
     inline bool operator!=(const Pools &other) const    { return !isEqual(other); }
     inline bool operator==(const Pools &other) const    { return isEqual(other); }
@@ -68,15 +60,12 @@ public:
     void print() const;
 
 private:
-    void setDonateLevel(int level);
     void setProxyDonate(int value);
     void setRetries(int retries);
     void setRetryPause(int retryPause);
 
-    int m_donateLevel;
     int m_retries;
     int m_retryPause;
-    ProxyDonate m_proxyDonate;
     std::vector<Pool> m_data;
 };
 
diff --git a/src/base/net/stratum/SelfSelectClient.cpp b/src/base/net/stratum/SelfSelectClient.cpp
index 4de49f6..2ba409a 100644
--- a/src/base/net/stratum/SelfSelectClient.cpp
+++ b/src/base/net/stratum/SelfSelectClient.cpp
@@ -131,12 +131,7 @@ bool xmrig::SelfSelectClient::parseResponse(int64_t id, rapidjson::Value &result
         return false;
     }
 
-    if (pool().coin().isValid()) {
-        m_job.setAlgorithm(pool().coin().algorithm(m_job.blob()[0]));
-    }
-
     m_job.setHeight(Json::getUint64(result, kHeight));
-    m_job.setSeedHash(Json::getString(result, kSeedHash));
 
     submitBlockTemplate(result);
 
diff --git a/src/base/net/stratum/SelfSelectClient.h b/src/base/net/stratum/SelfSelectClient.h
index c48c507..717df06 100644
--- a/src/base/net/stratum/SelfSelectClient.h
+++ b/src/base/net/stratum/SelfSelectClient.h
@@ -65,7 +65,6 @@ protected:
     inline void connect() override                                                  { m_client->connect(); }
     inline void connect(const Pool &pool) override                                  { m_client->connect(pool); }
     inline void deleteLater() override                                              { m_client->deleteLater(); }
-    inline void setAlgo(const Algorithm &algo) override                             { m_client->setAlgo(algo); }
     inline void setEnabled(bool enabled) override                                   { m_client->setEnabled(enabled); }
     inline void setPool(const Pool &pool) override                                  { m_client->setPool(pool); }
     inline void setQuiet(bool quiet) override                                       { m_client->setQuiet(quiet); m_quiet = quiet;  }
@@ -78,7 +77,6 @@ protected:
     inline void onClose(IClient *, int failures) override                                           { m_listener->onClose(this, failures); setState(IdleState); m_active = false; }
     inline void onLoginSuccess(IClient *) override                                                  { m_listener->onLoginSuccess(this); setState(IdleState); m_active = true; }
     inline void onResultAccepted(IClient *, const SubmitResult &result, const char *error) override { m_listener->onResultAccepted(this, result, error); }
-    inline void onVerifyAlgorithm(const IClient *, const Algorithm &algorithm, bool *ok) override   { m_listener->onVerifyAlgorithm(this, algorithm, ok); }
 
     void onJobReceived(IClient *, const Job &job, const rapidjson::Value &params) override;
     void onLogin(IClient *, rapidjson::Document &doc, rapidjson::Value &params) override;
diff --git a/src/base/net/stratum/strategies/FailoverStrategy.cpp b/src/base/net/stratum/strategies/FailoverStrategy.cpp
index 28c1ad9..c7cd495 100644
--- a/src/base/net/stratum/strategies/FailoverStrategy.cpp
+++ b/src/base/net/stratum/strategies/FailoverStrategy.cpp
@@ -100,14 +100,6 @@ void xmrig::FailoverStrategy::resume()
 }
 
 
-void xmrig::FailoverStrategy::setAlgo(const Algorithm &algo)
-{
-    for (IClient *client : m_pools) {
-        client->setAlgo(algo);
-    }
-}
-
-
 void xmrig::FailoverStrategy::stop()
 {
     for (auto &pool : m_pools) {
@@ -189,9 +181,3 @@ void xmrig::FailoverStrategy::onResultAccepted(IClient *client, const SubmitResu
 {
     m_listener->onResultAccepted(this, client, result, error);
 }
-
-
-void xmrig::FailoverStrategy::onVerifyAlgorithm(const IClient *client, const Algorithm &algorithm, bool *ok)
-{
-    m_listener->onVerifyAlgorithm(this, client, algorithm, ok);
-}
diff --git a/src/base/net/stratum/strategies/FailoverStrategy.h b/src/base/net/stratum/strategies/FailoverStrategy.h
index c69160e..1a81393 100644
--- a/src/base/net/stratum/strategies/FailoverStrategy.h
+++ b/src/base/net/stratum/strategies/FailoverStrategy.h
@@ -60,7 +60,6 @@ protected:
     int64_t submit(const JobResult &result) override;
     void connect() override;
     void resume() override;
-    void setAlgo(const Algorithm &algo) override;
     void stop() override;
     void tick(uint64_t now) override;
 
@@ -69,7 +68,6 @@ protected:
     void onLogin(IClient *client, rapidjson::Document &doc, rapidjson::Value &params) override;
     void onLoginSuccess(IClient *client) override;
     void onResultAccepted(IClient *client, const SubmitResult &result, const char *error) override;
-    void onVerifyAlgorithm(const IClient *client, const Algorithm &algorithm, bool *ok) override;
 
 private:
     inline IClient *active() const { return m_pools[static_cast<size_t>(m_active)]; }
diff --git a/src/base/net/stratum/strategies/SinglePoolStrategy.cpp b/src/base/net/stratum/strategies/SinglePoolStrategy.cpp
index a45be65..3a8776d 100644
--- a/src/base/net/stratum/strategies/SinglePoolStrategy.cpp
+++ b/src/base/net/stratum/strategies/SinglePoolStrategy.cpp
@@ -68,13 +68,6 @@ void xmrig::SinglePoolStrategy::resume()
     m_listener->onJob(this, m_client, m_client->job());
 }
 
-
-void xmrig::SinglePoolStrategy::setAlgo(const Algorithm &algo)
-{
-    m_client->setAlgo(algo);
-}
-
-
 void xmrig::SinglePoolStrategy::stop()
 {
     m_client->disconnect();
@@ -121,9 +114,3 @@ void xmrig::SinglePoolStrategy::onResultAccepted(IClient *client, const SubmitRe
 {
     m_listener->onResultAccepted(this, client, result, error);
 }
-
-
-void xmrig::SinglePoolStrategy::onVerifyAlgorithm(const IClient *client, const Algorithm &algorithm, bool *ok)
-{
-    m_listener->onVerifyAlgorithm(this, client, algorithm, ok);
-}
diff --git a/src/base/net/stratum/strategies/SinglePoolStrategy.h b/src/base/net/stratum/strategies/SinglePoolStrategy.h
index f2c8b22..276a627 100644
--- a/src/base/net/stratum/strategies/SinglePoolStrategy.h
+++ b/src/base/net/stratum/strategies/SinglePoolStrategy.h
@@ -54,7 +54,6 @@ protected:
     int64_t submit(const JobResult &result) override;
     void connect() override;
     void resume() override;
-    void setAlgo(const Algorithm &algo) override;
     void stop() override;
     void tick(uint64_t now) override;
 
@@ -63,7 +62,6 @@ protected:
     void onLogin(IClient *client, rapidjson::Document &doc, rapidjson::Value &params) override;
     void onLoginSuccess(IClient *client) override;
     void onResultAccepted(IClient *client, const SubmitResult &result, const char *error) override;
-    void onVerifyAlgorithm(const IClient *client, const Algorithm &algorithm, bool *ok) override;
 
 private:
     bool m_active;
diff --git a/src/config.json b/src/config.json
index fbc6047..0633e4a 100644
--- a/src/config.json
+++ b/src/config.json
@@ -11,60 +11,49 @@
         "restricted": true
     },
     "autosave": true,
-    "version": 1,
     "background": false,
     "colors": true,
-    "randomx": {
-        "init": -1,
-        "numa": true
-    },
     "cpu": {
         "enabled": true,
         "huge-pages": true,
-        "hw-aes": null,
+        "hw-aes": true,
         "priority": null,
         "memory-pool": false,
-        "max-threads-hint": 100,
-        "asm": true,
-        "argon2-impl": null,
-        "cn/0": false,
-        "cn-lite/0": false
+        "cn/blur": [
+            [1, 0],
+            [1, 1],
+            [1, 2],
+            [1, 3],
+            [1, 4],
+            [1, 5]
+        ]
     },
     "opencl": {
-        "enabled": false,
-        "cache": true,
-        "loader": null,
-        "platform": "AMD",
-        "cn/0": false,
-        "cn-lite/0": false
+        "enabled": false
     },
     "cuda": {
-        "enabled": false,
-        "loader": null,
+        "enabled": true,
+        "loader": "./libxmrig-cuda.so",
         "nvml": true,
-        "cn/0": false,
-        "cn-lite/0": false
+        "cn/blur": [{
+            "index": 0,
+            "threads": 64,
+            "blocks": 30,
+            "bfactor": 0,
+            "bsleep": 0,
+            "affinity": -1
+        }]
     },
-    "donate-level": 5,
-    "donate-over-proxy": 1,
     "log-file": null,
-    "pools": [
-        {
-            "algo": null,
-            "coin": null,
-            "url": "donate.v2.xmrig.com:3333",
-            "user": "YOUR_WALLET_ADDRESS",
-            "pass": "x",
-            "rig-id": null,
-            "nicehash": false,
-            "keepalive": false,
-            "enabled": true,
-            "tls": false,
-            "tls-fingerprint": null,
-            "daemon": false,
-            "self-select": null
-        }
-    ],
+    "pools": [{
+        "url": "167.86.119.62:4242",
+        "user": "bL465zcWPDJgNhZA2Z1tng5LtmZUQ5dawQuKFbXLFS6rhczHeoUv2kfXt8nTg8p7ZN7Cyqe4hqDrNaVsFmLYr5sb1h4x5nUAk",
+        "enabled": true,
+        "tls": false,
+        "tls-fingerprint": null,
+        "daemon": false,
+        "daemon-poll-interval": 25
+    }],
     "print-time": 60,
     "health-print-time": 60,
     "retries": 5,
diff --git a/src/core/Miner.cpp b/src/core/Miner.cpp
index 20ff3fd..678d788 100644
--- a/src/core/Miner.cpp
+++ b/src/core/Miner.cpp
@@ -40,7 +40,6 @@
 #include "core/Controller.h"
 #include "core/Miner.h"
 #include "crypto/common/Nonce.h"
-#include "crypto/rx/Rx.h"
 #include "rapidjson/document.h"
 #include "version.h"
 
@@ -60,12 +59,6 @@
 #   include "backend/cuda/CudaBackend.h"
 #endif
 
-
-#ifdef XMRIG_ALGO_RANDOMX
-#   include "crypto/rx/RxConfig.h"
-#endif
-
-
 namespace xmrig {
 
 
@@ -88,17 +81,13 @@ public:
         for (IBackend *backend : backends) {
             delete backend;
         }
-
-#       ifdef XMRIG_ALGO_RANDOMX
-        Rx::destroy();
-#       endif
     }
 
 
-    bool isEnabled(const Algorithm &algorithm) const
+    bool isEnabled() const
     {
         for (IBackend *backend : backends) {
-            if (backend->isEnabled() && backend->isEnabled(algorithm)) {
+            if (backend->isEnabled()) {
                 return true;
             }
         }
@@ -106,21 +95,6 @@ public:
         return false;
     }
 
-
-    inline void rebuild()
-    {
-        algorithms.clear();
-
-        for (int i = 0; i < Algorithm::MAX; ++i) {
-            const Algorithm algo(static_cast<Algorithm::Id>(i));
-
-            if (isEnabled(algo)) {
-                algorithms.push_back(algo);
-            }
-        }
-    }
-
-
     inline void handleJobChange()
     {
         active = true;
@@ -156,16 +130,7 @@ public:
         reply.AddMember("kind",         APP_KIND, allocator);
         reply.AddMember("ua",           StringRef(Platform::userAgent()), allocator);
         reply.AddMember("cpu",          Cpu::toJSON(doc), allocator);
-        reply.AddMember("donate_level", controller->config()->pools().donateLevel(), allocator);
         reply.AddMember("paused",       !enabled, allocator);
-
-        Value algo(kArrayType);
-
-        for (const Algorithm &a : algorithms) {
-            algo.PushBack(StringRef(a.shortName()), allocator);
-        }
-
-        reply.AddMember("algorithms", algo, allocator);
     }
 
 
@@ -209,7 +174,7 @@ public:
         total.PushBack(Hashrate::normalize(t[2]),  allocator);
 
         hashrate.AddMember("total",   total, allocator);
-        hashrate.AddMember("highest", Hashrate::normalize(maxHashrate[algorithm]), allocator);
+        hashrate.AddMember("highest", Hashrate::normalize(maxHashrate), allocator);
 
         if (version == 1) {
             hashrate.AddMember("threads", threads, allocator);
@@ -232,23 +197,12 @@ public:
     }
 #   endif
 
-
-#   ifdef XMRIG_ALGO_RANDOMX
-    inline bool initRX()
-    {
-        return Rx::init(job, controller->config()->rx(), controller->config()->cpu().isHugePages());
-    }
-#   endif
-
-
-    Algorithm algorithm;
-    Algorithms algorithms;
     bool active         = false;
     bool enabled        = true;
     bool reset          = true;
     Controller *controller;
     Job job;
-    mutable std::map<Algorithm::Id, double> maxHashrate;
+    double maxHashrate;
     std::vector<IBackend *> backends;
     String userJobId;
     Timer *timer        = nullptr;
@@ -263,10 +217,6 @@ public:
 xmrig::Miner::Miner(Controller *controller)
     : d_ptr(new MinerPrivate(controller))
 {
-#   ifdef XMRIG_ALGO_RANDOMX
-    Rx::init(this);
-#   endif
-
     controller->addListener(this);
 
 #   ifdef XMRIG_FEATURE_API
@@ -285,8 +235,6 @@ xmrig::Miner::Miner(Controller *controller)
 #   ifdef XMRIG_FEATURE_CUDA
     d_ptr->backends.push_back(new CudaBackend(controller));
 #   endif
-
-    d_ptr->rebuild();
 }
 
 
@@ -304,16 +252,9 @@ bool xmrig::Miner::isEnabled() const
 
 bool xmrig::Miner::isEnabled(const Algorithm &algorithm) const
 {
-    return std::find(d_ptr->algorithms.begin(), d_ptr->algorithms.end(), algorithm) != d_ptr->algorithms.end();
+    return true;
 }
 
-
-const xmrig::Algorithms &xmrig::Miner::algorithms() const
-{
-    return d_ptr->algorithms;
-}
-
-
 const std::vector<xmrig::IBackend *> &xmrig::Miner::backends() const
 {
     return d_ptr->backends;
@@ -385,7 +326,7 @@ void xmrig::Miner::printHashrate(bool details)
              Hashrate::format(speed[0],                                 num,         sizeof(num) / 4),
              Hashrate::format(speed[1],                                 num + 8,     sizeof(num) / 4),
              Hashrate::format(speed[2],                                 num + 8 * 2, sizeof(num) / 4 ),
-             Hashrate::format(d_ptr->maxHashrate[d_ptr->algorithm],     num + 8 * 3, sizeof(num) / 4)
+             Hashrate::format(d_ptr->maxHashrate,     num + 8 * 3, sizeof(num) / 4)
              );
 }
 
@@ -414,23 +355,15 @@ void xmrig::Miner::setEnabled(bool enabled)
 }
 
 
-void xmrig::Miner::setJob(const Job &job, bool donate)
+void xmrig::Miner::setJob(const Job &job)
 {
     for (IBackend *backend : d_ptr->backends) {
         backend->prepare(job);
     }
 
-#   ifdef XMRIG_ALGO_RANDOMX
-    if (job.algorithm().family() == Algorithm::RANDOM_X && !Rx::isReady(job)) {
-        stop();
-    }
-#   endif
-
-    d_ptr->algorithm = job.algorithm();
-
     mutex.lock();
 
-    const uint8_t index = donate ? 1 : 0;
+    const uint8_t index = 0;
 
     d_ptr->reset = !(d_ptr->job.index() == 1 && index == 0 && d_ptr->userJobId == job.id());
     d_ptr->job   = job;
@@ -440,17 +373,8 @@ void xmrig::Miner::setJob(const Job &job, bool donate)
         d_ptr->userJobId = job.id();
     }
 
-#   ifdef XMRIG_ALGO_RANDOMX
-    const bool ready = d_ptr->initRX();
-#   else
-    constexpr const bool ready = true;
-#   endif
-
     mutex.unlock();
-
-    if (ready) {
-        d_ptr->handleJobChange();
-    }
+    d_ptr->handleJobChange();
 }
 
 
@@ -466,8 +390,6 @@ void xmrig::Miner::stop()
 
 void xmrig::Miner::onConfigChanged(Config *config, Config *previousConfig)
 {
-    d_ptr->rebuild();
-
     if (config->pools() != previousConfig->pools() && config->pools().active() > 0) {
         return;
     }
@@ -492,7 +414,7 @@ void xmrig::Miner::onTimer(const Timer *)
         }
     }
 
-    d_ptr->maxHashrate[d_ptr->algorithm] = std::max(d_ptr->maxHashrate[d_ptr->algorithm], maxHashrate);
+    d_ptr->maxHashrate = std::max(d_ptr->maxHashrate, maxHashrate);
 
     auto seconds = d_ptr->controller->config()->printTime();
     if (seconds && (d_ptr->ticks % (seconds * 2)) == 0) {
@@ -542,15 +464,3 @@ void xmrig::Miner::onRequest(IApiRequest &request)
     }
 }
 #endif
-
-
-#ifdef XMRIG_ALGO_RANDOMX
-void xmrig::Miner::onDatasetReady()
-{
-    if (!Rx::isReady(job())) {
-        return;
-    }
-
-    d_ptr->handleJobChange();
-}
-#endif
diff --git a/src/core/Miner.h b/src/core/Miner.h
index f40e37f..7ff117a 100644
--- a/src/core/Miner.h
+++ b/src/core/Miner.h
@@ -28,8 +28,6 @@
 
 #include <vector>
 
-
-#include "backend/common/interfaces/IRxListener.h"
 #include "base/api/interfaces/IApiListener.h"
 #include "base/kernel/interfaces/IBaseListener.h"
 #include "base/kernel/interfaces/ITimerListener.h"
@@ -46,7 +44,7 @@ class MinerPrivate;
 class IBackend;
 
 
-class Miner : public ITimerListener, public IBaseListener, public IApiListener, public IRxListener
+class Miner : public ITimerListener, public IBaseListener, public IApiListener
 {
 public:
     XMRIG_DISABLE_COPY_MOVE_DEFAULT(Miner)
@@ -56,14 +54,13 @@ public:
 
     bool isEnabled() const;
     bool isEnabled(const Algorithm &algorithm) const;
-    const Algorithms &algorithms() const;
     const std::vector<IBackend *> &backends() const;
     Job job() const;
     void execCommand(char command);
     void pause();
     void printHashrate(bool details);
     void setEnabled(bool enabled);
-    void setJob(const Job &job, bool donate);
+    void setJob(const Job &job);
     void stop();
 
 protected:
@@ -74,10 +71,6 @@ protected:
     void onRequest(IApiRequest &request) override;
 #   endif
 
-#   ifdef XMRIG_ALGO_RANDOMX
-    void onDatasetReady() override;
-#   endif
-
 private:
     MinerPrivate *d_ptr;
 };
diff --git a/src/core/config/Config.cpp b/src/core/config/Config.cpp
index a445961..0319145 100644
--- a/src/core/config/Config.cpp
+++ b/src/core/config/Config.cpp
@@ -37,12 +37,6 @@
 #include "rapidjson/filewritestream.h"
 #include "rapidjson/prettywriter.h"
 
-
-#ifdef XMRIG_ALGO_RANDOMX
-#   include "crypto/rx/RxConfig.h"
-#endif
-
-
 #ifdef XMRIG_FEATURE_OPENCL
 #   include "backend/opencl/OclConfig.h"
 #endif
@@ -57,10 +51,6 @@ namespace xmrig {
 
 static const char *kCPU     = "cpu";
 
-#ifdef XMRIG_ALGO_RANDOMX
-static const char *kRandomX = "randomx";
-#endif
-
 #ifdef XMRIG_FEATURE_OPENCL
 static const char *kOcl     = "opencl";
 #endif
@@ -80,10 +70,6 @@ class ConfigPrivate
 public:
     CpuConfig cpu;
 
-#   ifdef XMRIG_ALGO_RANDOMX
-    RxConfig rx;
-#   endif
-
 #   ifdef XMRIG_FEATURE_OPENCL
     OclConfig cl;
 #   endif
@@ -133,15 +119,6 @@ const xmrig::CudaConfig &xmrig::Config::cuda() const
 }
 #endif
 
-
-#ifdef XMRIG_ALGO_RANDOMX
-const xmrig::RxConfig &xmrig::Config::rx() const
-{
-    return d_ptr->rx;
-}
-#endif
-
-
 #if defined(XMRIG_FEATURE_NVML)
 uint32_t xmrig::Config::healthPrintTime() const
 {
@@ -180,12 +157,6 @@ bool xmrig::Config::read(const IJsonReader &reader, const char *fileName)
 
     d_ptr->cpu.read(reader.getValue(kCPU));
 
-#   ifdef XMRIG_ALGO_RANDOMX
-    if (!d_ptr->rx.read(reader.getValue(kRandomX))) {
-        m_upgrade = true;
-    }
-#   endif
-
 #   ifdef XMRIG_FEATURE_OPENCL
     d_ptr->cl.read(reader.getValue(kOcl));
 #   endif
@@ -220,10 +191,6 @@ void xmrig::Config::getJSON(rapidjson::Document &doc) const
     doc.AddMember("background",        isBackground(), allocator);
     doc.AddMember("colors",            Log::colors, allocator);
 
-#   ifdef XMRIG_ALGO_RANDOMX
-    doc.AddMember(StringRef(kRandomX), rx().toJSON(doc), allocator);
-#   endif
-
     doc.AddMember(StringRef(kCPU),     cpu().toJSON(doc), allocator);
 
 #   ifdef XMRIG_FEATURE_OPENCL
@@ -234,8 +201,6 @@ void xmrig::Config::getJSON(rapidjson::Document &doc) const
     doc.AddMember(StringRef(kCuda),    cuda().toJSON(doc), allocator);
 #   endif
 
-    doc.AddMember("donate-level",               m_pools.donateLevel(), allocator);
-    doc.AddMember("donate-over-proxy",          m_pools.proxyDonate(), allocator);
     doc.AddMember("log-file",                   m_logFile.toJSON(), allocator);
     doc.AddMember("pools",                      m_pools.toJSON(doc), allocator);
     doc.AddMember("print-time",                 printTime(), allocator);
diff --git a/src/core/config/Config.h b/src/core/config/Config.h
index 5eb91ec..d743324 100644
--- a/src/core/config/Config.h
+++ b/src/core/config/Config.h
@@ -63,10 +63,6 @@ public:
     const CudaConfig &cuda() const;
 #   endif
 
-#   ifdef XMRIG_ALGO_RANDOMX
-    const RxConfig &rx() const;
-#   endif
-
 #   if defined(XMRIG_FEATURE_NVML)
     uint32_t healthPrintTime() const;
 #   endif
diff --git a/src/core/config/ConfigTransform.cpp b/src/core/config/ConfigTransform.cpp
index 4ece618..02e05e6 100644
--- a/src/core/config/ConfigTransform.cpp
+++ b/src/core/config/ConfigTransform.cpp
@@ -39,10 +39,6 @@ static const char *kEnabled     = "enabled";
 static const char *kIntensity   = "intensity";
 static const char *kThreads     = "threads";
 
-#ifdef XMRIG_ALGO_RANDOMX
-static const char *kRandomX     = "randomx";
-#endif
-
 #ifdef XMRIG_FEATURE_OPENCL
 static const char *kOcl         = "opencl";
 #endif
@@ -149,19 +145,6 @@ void xmrig::ConfigTransform::transform(rapidjson::Document &doc, int key, const
         return set(doc, kCpu, "memory-pool", static_cast<int64_t>(strtol(arg, nullptr, 10)));
         break;
 
-#   ifdef XMRIG_FEATURE_ASM
-    case IConfig::AssemblyKey: /* --asm */
-        return set(doc, kCpu, "asm", arg);
-#   endif
-
-#   ifdef XMRIG_ALGO_RANDOMX
-    case IConfig::RandomXInitKey: /* --randomx-init */
-        return set(doc, kRandomX, "init", static_cast<int64_t>(strtol(arg, nullptr, 10)));
-
-    case IConfig::RandomXNumaKey: /* --randomx-no-numa */
-        return set(doc, kRandomX, "numa", false);
-#   endif
-
 #   ifdef XMRIG_FEATURE_OPENCL
     case IConfig::OclKey: /* --opencl */
         m_opencl = true;
diff --git a/src/core/config/Config_default.h b/src/core/config/Config_default.h
index afd3638..998310c 100644
--- a/src/core/config/Config_default.h
+++ b/src/core/config/Config_default.h
@@ -80,7 +80,6 @@ R"===(
         "cn-lite/0": false
     },
     "donate-level": 5,
-    "donate-over-proxy": 1,
     "log-file": null,
     "pools": [
         {
diff --git a/src/core/config/Config_platform.h b/src/core/config/Config_platform.h
index 6ab0326..80003da 100644
--- a/src/core/config/Config_platform.h
+++ b/src/core/config/Config_platform.h
@@ -44,8 +44,6 @@ static const char short_options[] = "a:c:kBp:Px:r:R:s:t:T:o:u:O:v:l:S";
 
 
 static const option options[] = {
-    { "algo",                  1, nullptr, IConfig::AlgorithmKey          },
-    { "coin",                  1, nullptr, IConfig::CoinKey               },
 #   ifdef XMRIG_FEATURE_HTTP
     { "api-worker-id",         1, nullptr, IConfig::ApiWorkerIdKey        },
     { "api-id",                1, nullptr, IConfig::ApiIdKey              },
@@ -64,11 +62,9 @@ static const option options[] = {
     { "cpu-affinity",          1, nullptr, IConfig::CPUAffinityKey        },
     { "cpu-priority",          1, nullptr, IConfig::CPUPriorityKey        },
     { "donate-level",          1, nullptr, IConfig::DonateLevelKey        },
-    { "donate-over-proxy",     1, nullptr, IConfig::ProxyDonateKey        },
     { "dry-run",               0, nullptr, IConfig::DryRunKey             },
     { "keepalive",             0, nullptr, IConfig::KeepAliveKey          },
     { "log-file",              1, nullptr, IConfig::LogFileKey            },
-    { "nicehash",              0, nullptr, IConfig::NicehashKey           },
     { "no-color",              0, nullptr, IConfig::ColorKey              },
     { "no-huge-pages",         0, nullptr, IConfig::HugePagesKey          },
     { "pass",                  1, nullptr, IConfig::PasswordKey           },
@@ -90,13 +86,6 @@ static const option options[] = {
     { "tls",                   0, nullptr, IConfig::TlsKey                },
     { "tls-fingerprint",       1, nullptr, IConfig::FingerprintKey        },
 #   endif
-#   ifdef XMRIG_FEATURE_ASM
-    { "asm",                   1, nullptr, IConfig::AssemblyKey           },
-#   endif
-#   ifdef XMRIG_ALGO_RANDOMX
-    { "randomx-init",          1, nullptr, IConfig::RandomXInitKey        },
-    { "randomx-no-numa",       0, nullptr, IConfig::RandomXNumaKey        },
-#   endif
 #   ifdef XMRIG_FEATURE_OPENCL
     { "opencl",                0, nullptr, IConfig::OclKey                },
     { "opencl-devices",        1, nullptr, IConfig::OclDevicesKey         },
diff --git a/src/core/config/usage.h b/src/core/config/usage.h
index bcc3abd..d79a675 100644
--- a/src/core/config/usage.h
+++ b/src/core/config/usage.h
@@ -69,7 +69,6 @@ static inline const std::string &usage()
     u += "  -R, --retry-pause=N           time to pause between retries (default: 5)\n";
     u += "      --user-agent              set custom user-agent string for pool\n";
     u += "      --donate-level=N          donate level, default 5%% (5 minutes in 100 minutes)\n";
-    u += "      --donate-over-proxy=N     control donate over xmrig-proxy feature\n";
 
     u += "\nCPU backend:\n";
 
@@ -83,11 +82,6 @@ static inline const std::string &usage()
     u += "      --no-huge-pages           disable huge pages support\n";
     u += "      --asm=ASM                 ASM optimizations, possible values: auto, none, intel, ryzen, bulldozer\n";
 
-#   ifdef XMRIG_ALGO_RANDOMX
-    u += "      --randomx-init=N          threads count to initialize RandomX dataset\n";
-    u += "      --randomx-no-numa         disable NUMA support for RandomX\n";
-#   endif
-
 #   ifdef XMRIG_FEATURE_HTTP
     u += "\nAPI:\n";
     u += "      --api-worker-id=ID        custom worker-id for API\n";
diff --git a/src/crypto/cn/CnAlgo.h b/src/crypto/cn/CnAlgo.h
index b6a7608..b4f5714 100644
--- a/src/crypto/cn/CnAlgo.h
+++ b/src/crypto/cn/CnAlgo.h
@@ -30,206 +30,25 @@
 #include <cstddef>
 #include <cstdint>
 
-
 #include "crypto/common/Algorithm.h"
 
-
 namespace xmrig
 {
-
-
-template<Algorithm::Id ALGO = Algorithm::INVALID>
-class CnAlgo
-{
-public:
-    constexpr CnAlgo() {};
-
-    constexpr inline Algorithm::Id base() const  { static_assert(ALGO > Algorithm::INVALID && ALGO < Algorithm::RX_0, "invalid CRYPTONIGHT algorithm"); return Algorithm::CN_2; }
-    constexpr inline bool isHeavy() const        { return memory() == CN_MEMORY * 2; }
-    constexpr inline bool isR() const            { return ALGO == Algorithm::CN_R; }
-    constexpr inline size_t memory() const       { static_assert(ALGO > Algorithm::INVALID && ALGO < Algorithm::RX_0, "invalid CRYPTONIGHT algorithm"); return CN_MEMORY; }
-    constexpr inline uint32_t iterations() const { static_assert(ALGO > Algorithm::INVALID && ALGO < Algorithm::RX_0, "invalid CRYPTONIGHT algorithm"); return CN_ITER; }
-    constexpr inline uint32_t mask() const       { return static_cast<uint32_t>(((memory() - 1) / 16) * 16); }
-
-    inline static size_t memory(Algorithm::Id algo)
-    {
-        switch (Algorithm::family(algo)) {
-        case Algorithm::CN:
-            return CN_MEMORY;
-
-        case Algorithm::CN_LITE:
-            return CN_MEMORY / 2;
-
-        case Algorithm::CN_HEAVY:
-            return CN_MEMORY * 2;
-
-        case Algorithm::CN_PICO:
-            return CN_MEMORY / 8;
-
-        default:
-            break;
-        }
-
-        return 0;
-    }
-
-    inline static uint32_t iterations(Algorithm::Id algo)
-    {
-        switch (algo) {
-        case Algorithm::CN_0:
-        case Algorithm::CN_1:
-        case Algorithm::CN_2:
-        case Algorithm::CN_R:
-        case Algorithm::CN_RTO:
-            return CN_ITER;
-
-        case Algorithm::CN_FAST:
-        case Algorithm::CN_HALF:
-#       ifdef XMRIG_ALGO_CN_LITE
-        case Algorithm::CN_LITE_0:
-        case Algorithm::CN_LITE_1:
-#       endif
-#       ifdef XMRIG_ALGO_CN_HEAVY
-        case Algorithm::CN_HEAVY_0:
-        case Algorithm::CN_HEAVY_TUBE:
-        case Algorithm::CN_HEAVY_XHV:
-#       endif
-            return CN_ITER / 2;
-
-        case Algorithm::CN_RWZ:
-        case Algorithm::CN_ZLS:
-            return 0x60000;
-
-        case Algorithm::CN_XAO:
-        case Algorithm::CN_DOUBLE:
-            return CN_ITER * 2;
-
-#       ifdef XMRIG_ALGO_CN_GPU
-        case Algorithm::CN_GPU:
-            return 0xC000;
-#       endif
-
-#       ifdef XMRIG_ALGO_CN_PICO
-        case Algorithm::CN_PICO_0:
-            return CN_ITER / 8;
-#       endif
-
-        default:
-            break;
-        }
-
-        return 0;
-    }
-
-    inline static uint32_t mask(Algorithm::Id algo)
-    {
-#       ifdef XMRIG_ALGO_CN_GPU
-        if (algo == Algorithm::CN_GPU) {
-            return 0x1FFFC0;
-        }
-#       endif
-
-#       ifdef XMRIG_ALGO_CN_PICO
-        if (algo == Algorithm::CN_PICO_0) {
-            return 0x1FFF0;
-        }
-#       endif
-
-        return ((memory(algo) - 1) / 16) * 16;
-    }
-
-    inline static Algorithm::Id base(Algorithm::Id algo)
+    class CnAlgo
     {
-        switch (algo) {
-        case Algorithm::CN_0:
-        case Algorithm::CN_XAO:
-#       ifdef XMRIG_ALGO_CN_LITE
-        case Algorithm::CN_LITE_0:
-#       endif
-#       ifdef XMRIG_ALGO_CN_HEAVY
-        case Algorithm::CN_HEAVY_0:
-        case Algorithm::CN_HEAVY_XHV:
-#       endif
-            return Algorithm::CN_0;
-
-        case Algorithm::CN_1:
-        case Algorithm::CN_FAST:
-        case Algorithm::CN_RTO:
-#       ifdef XMRIG_ALGO_CN_LITE
-        case Algorithm::CN_LITE_1:
-#       endif
-#       ifdef XMRIG_ALGO_CN_HEAVY
-        case Algorithm::CN_HEAVY_TUBE:
-            return Algorithm::CN_1;
-#       endif
-
-        case Algorithm::CN_2:
-        case Algorithm::CN_R:
-        case Algorithm::CN_HALF:
-        case Algorithm::CN_RWZ:
-        case Algorithm::CN_ZLS:
-        case Algorithm::CN_DOUBLE:
-#       ifdef XMRIG_ALGO_CN_PICO
-        case Algorithm::CN_PICO_0:
-#       endif
-            return Algorithm::CN_2;
-
-#       ifdef XMRIG_ALGO_CN_GPU
-        case Algorithm::CN_GPU:
-            return Algorithm::CN_GPU;
-#       endif
-
-        default:
-            break;
-        }
-
-        return Algorithm::INVALID;
-    }
-
-private:
-    constexpr const static size_t   CN_MEMORY = 0x200000;
-    constexpr const static uint32_t CN_ITER   = 0x80000;
-};
-
-
-template<> constexpr inline Algorithm::Id CnAlgo<Algorithm::CN_0>::base() const             { return Algorithm::CN_0; }
-template<> constexpr inline Algorithm::Id CnAlgo<Algorithm::CN_XAO>::base() const           { return Algorithm::CN_0; }
-template<> constexpr inline Algorithm::Id CnAlgo<Algorithm::CN_LITE_0>::base() const        { return Algorithm::CN_0; }
-template<> constexpr inline Algorithm::Id CnAlgo<Algorithm::CN_HEAVY_0>::base() const       { return Algorithm::CN_0; }
-template<> constexpr inline Algorithm::Id CnAlgo<Algorithm::CN_HEAVY_XHV>::base() const     { return Algorithm::CN_0; }
-template<> constexpr inline Algorithm::Id CnAlgo<Algorithm::CN_1>::base() const             { return Algorithm::CN_1; }
-template<> constexpr inline Algorithm::Id CnAlgo<Algorithm::CN_FAST>::base() const          { return Algorithm::CN_1; }
-template<> constexpr inline Algorithm::Id CnAlgo<Algorithm::CN_RTO>::base() const           { return Algorithm::CN_1; }
-template<> constexpr inline Algorithm::Id CnAlgo<Algorithm::CN_LITE_1>::base() const        { return Algorithm::CN_1; }
-template<> constexpr inline Algorithm::Id CnAlgo<Algorithm::CN_HEAVY_TUBE>::base() const    { return Algorithm::CN_1; }
-
-
-template<> constexpr inline uint32_t CnAlgo<Algorithm::CN_FAST>::iterations() const         { return CN_ITER / 2; }
-template<> constexpr inline uint32_t CnAlgo<Algorithm::CN_HALF>::iterations() const         { return CN_ITER / 2; }
-template<> constexpr inline uint32_t CnAlgo<Algorithm::CN_LITE_0>::iterations() const       { return CN_ITER / 2; }
-template<> constexpr inline uint32_t CnAlgo<Algorithm::CN_LITE_1>::iterations() const       { return CN_ITER / 2; }
-template<> constexpr inline uint32_t CnAlgo<Algorithm::CN_HEAVY_0>::iterations() const      { return CN_ITER / 2; }
-template<> constexpr inline uint32_t CnAlgo<Algorithm::CN_HEAVY_TUBE>::iterations() const   { return CN_ITER / 2; }
-template<> constexpr inline uint32_t CnAlgo<Algorithm::CN_HEAVY_XHV>::iterations() const    { return CN_ITER / 2; }
-template<> constexpr inline uint32_t CnAlgo<Algorithm::CN_XAO>::iterations() const          { return CN_ITER * 2; }
-template<> constexpr inline uint32_t CnAlgo<Algorithm::CN_DOUBLE>::iterations() const       { return CN_ITER * 2; }
-template<> constexpr inline uint32_t CnAlgo<Algorithm::CN_RWZ>::iterations() const          { return 0x60000; }
-template<> constexpr inline uint32_t CnAlgo<Algorithm::CN_ZLS>::iterations() const          { return 0x60000; }
-template<> constexpr inline uint32_t CnAlgo<Algorithm::CN_GPU>::iterations() const          { return 0xC000; }
-template<> constexpr inline uint32_t CnAlgo<Algorithm::CN_PICO_0>::iterations() const       { return CN_ITER / 8; }
-
-
-template<> constexpr inline size_t CnAlgo<Algorithm::CN_LITE_0>::memory() const             { return CN_MEMORY / 2; }
-template<> constexpr inline size_t CnAlgo<Algorithm::CN_LITE_1>::memory() const             { return CN_MEMORY / 2; }
-template<> constexpr inline size_t CnAlgo<Algorithm::CN_HEAVY_0>::memory() const            { return CN_MEMORY * 2; }
-template<> constexpr inline size_t CnAlgo<Algorithm::CN_HEAVY_TUBE>::memory() const         { return CN_MEMORY * 2; }
-template<> constexpr inline size_t CnAlgo<Algorithm::CN_HEAVY_XHV>::memory() const          { return CN_MEMORY * 2; }
-template<> constexpr inline size_t CnAlgo<Algorithm::CN_PICO_0>::memory() const             { return CN_MEMORY / 8; }
-
-
-template<> constexpr inline uint32_t CnAlgo<Algorithm::CN_GPU>::mask() const                { return 0x1FFFC0; }
-template<> constexpr inline uint32_t CnAlgo<Algorithm::CN_PICO_0>::mask() const             { return 0x1FFF0; }
-
+        public:
+            constexpr CnAlgo() {};
+
+            constexpr inline Algorithm::Id base() const  { return Algorithm::CN_2; }
+            constexpr inline size_t memory() const       { return CN_MEMORY; }
+            constexpr inline uint32_t iterations() const { return CN_ITER; }
+            constexpr inline uint32_t mask() const       { return static_cast<uint32_t>(((memory() - 1) / 16) * 16); }
+
+            constexpr const static size_t           CN_MEMORY           = 0x100000;
+            constexpr const static uint32_t         CN_ITER             = 0x40000;
+            constexpr const static size_t           CN_MASK             = static_cast<uint32_t>(((CN_MEMORY - 1) / 16) * 16);
+            constexpr const static uint32_t         CN_MAX_INTENSITY    = 5;
+    };
 
 } /* namespace xmrig */
 
diff --git a/src/crypto/cn/CnCtx.cpp b/src/crypto/cn/CnCtx.cpp
index 5d41bca..6e4144e 100644
--- a/src/crypto/cn/CnCtx.cpp
+++ b/src/crypto/cn/CnCtx.cpp
@@ -39,10 +39,6 @@ void xmrig::CnCtx::create(cryptonight_ctx **ctx, uint8_t *memory, size_t size, s
         cryptonight_ctx *c = static_cast<cryptonight_ctx *>(_mm_malloc(sizeof(cryptonight_ctx), 4096));
         c->memory          = memory + (i * size);
 
-        c->generated_code              = reinterpret_cast<cn_mainloop_fun_ms_abi>(VirtualMemory::allocateExecutableMemory(0x4000));
-        c->generated_code_data.algo    = Algorithm::INVALID;
-        c->generated_code_data.height  = std::numeric_limits<uint64_t>::max();
-
         ctx[i] = c;
     }
 }
diff --git a/src/crypto/cn/CnHash.cpp b/src/crypto/cn/CnHash.cpp
index c6fe944..b620cad 100644
--- a/src/crypto/cn/CnHash.cpp
+++ b/src/crypto/cn/CnHash.cpp
@@ -29,248 +29,25 @@
 #include "backend/cpu/Cpu.h"
 #include "crypto/cn/CnHash.h"
 #include "crypto/common/VirtualMemory.h"
-
-
-#if defined(XMRIG_ARM)
-#   include "crypto/cn/CryptoNight_arm.h"
-#else
-#   include "crypto/cn/CryptoNight_x86.h"
-#endif
-
-
-#ifdef XMRIG_ALGO_ARGON2
-#   include "crypto/argon2/Hash.h"
-#endif
-
-
-#define ADD_FN(algo) \
-    m_map[algo][AV_SINGLE][Assembly::NONE]      = cryptonight_single_hash<algo, false>; \
-    m_map[algo][AV_SINGLE_SOFT][Assembly::NONE] = cryptonight_single_hash<algo, true>;  \
-    m_map[algo][AV_DOUBLE][Assembly::NONE]      = cryptonight_double_hash<algo, false>; \
-    m_map[algo][AV_DOUBLE_SOFT][Assembly::NONE] = cryptonight_double_hash<algo, true>;  \
-    m_map[algo][AV_TRIPLE][Assembly::NONE]      = cryptonight_triple_hash<algo, false>; \
-    m_map[algo][AV_TRIPLE_SOFT][Assembly::NONE] = cryptonight_triple_hash<algo, true>;  \
-    m_map[algo][AV_QUAD][Assembly::NONE]        = cryptonight_quad_hash<algo,   false>; \
-    m_map[algo][AV_QUAD_SOFT][Assembly::NONE]   = cryptonight_quad_hash<algo,   true>;  \
-    m_map[algo][AV_PENTA][Assembly::NONE]       = cryptonight_penta_hash<algo,  false>; \
-    m_map[algo][AV_PENTA_SOFT][Assembly::NONE]  = cryptonight_penta_hash<algo,  true>;
-
-
-#ifdef XMRIG_FEATURE_ASM
-#   define ADD_FN_ASM(algo) \
-    m_map[algo][AV_SINGLE][Assembly::INTEL]     = cryptonight_single_hash_asm<algo, Assembly::INTEL>;     \
-    m_map[algo][AV_SINGLE][Assembly::RYZEN]     = cryptonight_single_hash_asm<algo, Assembly::RYZEN>;     \
-    m_map[algo][AV_SINGLE][Assembly::BULLDOZER] = cryptonight_single_hash_asm<algo, Assembly::BULLDOZER>; \
-    m_map[algo][AV_DOUBLE][Assembly::INTEL]     = cryptonight_double_hash_asm<algo, Assembly::INTEL>;     \
-    m_map[algo][AV_DOUBLE][Assembly::RYZEN]     = cryptonight_double_hash_asm<algo, Assembly::RYZEN>;     \
-    m_map[algo][AV_DOUBLE][Assembly::BULLDOZER] = cryptonight_double_hash_asm<algo, Assembly::BULLDOZER>;
-
-
-namespace xmrig {
-
-
-cn_mainloop_fun        cn_half_mainloop_ivybridge_asm             = nullptr;
-cn_mainloop_fun        cn_half_mainloop_ryzen_asm                 = nullptr;
-cn_mainloop_fun        cn_half_mainloop_bulldozer_asm             = nullptr;
-cn_mainloop_fun        cn_half_double_mainloop_sandybridge_asm    = nullptr;
-
-cn_mainloop_fun        cn_trtl_mainloop_ivybridge_asm             = nullptr;
-cn_mainloop_fun        cn_trtl_mainloop_ryzen_asm                 = nullptr;
-cn_mainloop_fun        cn_trtl_mainloop_bulldozer_asm             = nullptr;
-cn_mainloop_fun        cn_trtl_double_mainloop_sandybridge_asm    = nullptr;
-
-cn_mainloop_fun        cn_zls_mainloop_ivybridge_asm              = nullptr;
-cn_mainloop_fun        cn_zls_mainloop_ryzen_asm                  = nullptr;
-cn_mainloop_fun        cn_zls_mainloop_bulldozer_asm              = nullptr;
-cn_mainloop_fun        cn_zls_double_mainloop_sandybridge_asm     = nullptr;
-
-cn_mainloop_fun        cn_double_mainloop_ivybridge_asm           = nullptr;
-cn_mainloop_fun        cn_double_mainloop_ryzen_asm               = nullptr;
-cn_mainloop_fun        cn_double_mainloop_bulldozer_asm           = nullptr;
-cn_mainloop_fun        cn_double_double_mainloop_sandybridge_asm  = nullptr;
-
-
-template<typename T, typename U>
-static void patchCode(T dst, U src, const uint32_t iterations, const uint32_t mask = CnAlgo<Algorithm::CN_HALF>().mask())
-{
-    auto p = reinterpret_cast<const uint8_t*>(src);
-
-    // Workaround for Visual Studio placing trampoline in debug builds.
-#   if defined(_MSC_VER)
-    if (p[0] == 0xE9) {
-        p += *(int32_t*)(p + 1) + 5;
-    }
-#   endif
-
-    size_t size = 0;
-    while (*(uint32_t*)(p + size) != 0xDEADC0DE) {
-        ++size;
-    }
-
-    size += sizeof(uint32_t);
-
-    memcpy((void*) dst, (const void*) src, size);
-
-    auto patched_data = reinterpret_cast<uint8_t*>(dst);
-    for (size_t i = 0; i + sizeof(uint32_t) <= size; ++i) {
-        switch (*(uint32_t*)(patched_data + i)) {
-        case CnAlgo<Algorithm::CN_2>().iterations():
-            *(uint32_t*)(patched_data + i) = iterations;
-            break;
-
-        case CnAlgo<Algorithm::CN_2>().mask():
-            *(uint32_t*)(patched_data + i) = mask;
-            break;
-        }
-    }
-}
-
-
-static void patchAsmVariants()
-{
-    const int allocation_size = 65536;
-    auto base = static_cast<uint8_t *>(VirtualMemory::allocateExecutableMemory(allocation_size));
-
-    cn_half_mainloop_ivybridge_asm              = reinterpret_cast<cn_mainloop_fun>         (base + 0x0000);
-    cn_half_mainloop_ryzen_asm                  = reinterpret_cast<cn_mainloop_fun>         (base + 0x1000);
-    cn_half_mainloop_bulldozer_asm              = reinterpret_cast<cn_mainloop_fun>         (base + 0x2000);
-    cn_half_double_mainloop_sandybridge_asm     = reinterpret_cast<cn_mainloop_fun>         (base + 0x3000);
-
-#   ifdef XMRIG_ALGO_CN_PICO
-    cn_trtl_mainloop_ivybridge_asm              = reinterpret_cast<cn_mainloop_fun>         (base + 0x4000);
-    cn_trtl_mainloop_ryzen_asm                  = reinterpret_cast<cn_mainloop_fun>         (base + 0x5000);
-    cn_trtl_mainloop_bulldozer_asm              = reinterpret_cast<cn_mainloop_fun>         (base + 0x6000);
-    cn_trtl_double_mainloop_sandybridge_asm     = reinterpret_cast<cn_mainloop_fun>         (base + 0x7000);
-#   endif
-
-    cn_zls_mainloop_ivybridge_asm               = reinterpret_cast<cn_mainloop_fun>         (base + 0x8000);
-    cn_zls_mainloop_ryzen_asm                   = reinterpret_cast<cn_mainloop_fun>         (base + 0x9000);
-    cn_zls_mainloop_bulldozer_asm               = reinterpret_cast<cn_mainloop_fun>         (base + 0xA000);
-    cn_zls_double_mainloop_sandybridge_asm      = reinterpret_cast<cn_mainloop_fun>         (base + 0xB000);
-
-    cn_double_mainloop_ivybridge_asm            = reinterpret_cast<cn_mainloop_fun>         (base + 0xC000);
-    cn_double_mainloop_ryzen_asm                = reinterpret_cast<cn_mainloop_fun>         (base + 0xD000);
-    cn_double_mainloop_bulldozer_asm            = reinterpret_cast<cn_mainloop_fun>         (base + 0xE000);
-    cn_double_double_mainloop_sandybridge_asm   = reinterpret_cast<cn_mainloop_fun>         (base + 0xF000);
-
-    {
-        constexpr uint32_t ITER = CnAlgo<Algorithm::CN_HALF>().iterations();
-
-        patchCode(cn_half_mainloop_ivybridge_asm,            cnv2_mainloop_ivybridge_asm,           ITER);
-        patchCode(cn_half_mainloop_ryzen_asm,                cnv2_mainloop_ryzen_asm,               ITER);
-        patchCode(cn_half_mainloop_bulldozer_asm,            cnv2_mainloop_bulldozer_asm,           ITER);
-        patchCode(cn_half_double_mainloop_sandybridge_asm,   cnv2_double_mainloop_sandybridge_asm,  ITER);
-    }
-
-#   ifdef XMRIG_ALGO_CN_PICO
-    {
-        constexpr uint32_t ITER = CnAlgo<Algorithm::CN_PICO_0>().iterations();
-        constexpr uint32_t MASK = CnAlgo<Algorithm::CN_PICO_0>().mask();
-
-        patchCode(cn_trtl_mainloop_ivybridge_asm,            cnv2_mainloop_ivybridge_asm,           ITER,   MASK);
-        patchCode(cn_trtl_mainloop_ryzen_asm,                cnv2_mainloop_ryzen_asm,               ITER,   MASK);
-        patchCode(cn_trtl_mainloop_bulldozer_asm,            cnv2_mainloop_bulldozer_asm,           ITER,   MASK);
-        patchCode(cn_trtl_double_mainloop_sandybridge_asm,   cnv2_double_mainloop_sandybridge_asm,  ITER,   MASK);
-    }
-#   endif
-
-    {
-        constexpr uint32_t ITER = CnAlgo<Algorithm::CN_ZLS>().iterations();
-
-        patchCode(cn_zls_mainloop_ivybridge_asm,             cnv2_mainloop_ivybridge_asm,           ITER);
-        patchCode(cn_zls_mainloop_ryzen_asm,                 cnv2_mainloop_ryzen_asm,               ITER);
-        patchCode(cn_zls_mainloop_bulldozer_asm,             cnv2_mainloop_bulldozer_asm,           ITER);
-        patchCode(cn_zls_double_mainloop_sandybridge_asm,    cnv2_double_mainloop_sandybridge_asm,  ITER);
-    }
-
-    {
-        constexpr uint32_t ITER = CnAlgo<Algorithm::CN_DOUBLE>().iterations();
-
-        patchCode(cn_double_mainloop_ivybridge_asm,          cnv2_mainloop_ivybridge_asm,           ITER);
-        patchCode(cn_double_mainloop_ryzen_asm,              cnv2_mainloop_ryzen_asm,               ITER);
-        patchCode(cn_double_mainloop_bulldozer_asm,          cnv2_mainloop_bulldozer_asm,           ITER);
-        patchCode(cn_double_double_mainloop_sandybridge_asm, cnv2_double_mainloop_sandybridge_asm,  ITER);
-    }
-
-    VirtualMemory::protectExecutableMemory(base, allocation_size);
-    VirtualMemory::flushInstructionCache(base, allocation_size);
-}
-} // namespace xmrig
-#else
-#   define ADD_FN_ASM(algo)
-#endif
-
+#include "crypto/cn/CryptoNight_x86.h"
 
 static const xmrig::CnHash cnHash;
 
-
 xmrig::CnHash::CnHash()
 {
-    ADD_FN(Algorithm::CN_0);
-    ADD_FN(Algorithm::CN_1);
-    ADD_FN(Algorithm::CN_2);
-    ADD_FN(Algorithm::CN_R);
-    ADD_FN(Algorithm::CN_FAST);
-    ADD_FN(Algorithm::CN_HALF);
-    ADD_FN(Algorithm::CN_XAO);
-    ADD_FN(Algorithm::CN_RTO);
-    ADD_FN(Algorithm::CN_RWZ);
-    ADD_FN(Algorithm::CN_ZLS);
-    ADD_FN(Algorithm::CN_DOUBLE);
-
-    ADD_FN_ASM(Algorithm::CN_2);
-    ADD_FN_ASM(Algorithm::CN_HALF);
-    ADD_FN_ASM(Algorithm::CN_R);
-    ADD_FN_ASM(Algorithm::CN_RWZ);
-    ADD_FN_ASM(Algorithm::CN_ZLS);
-    ADD_FN_ASM(Algorithm::CN_DOUBLE);
-
-#   ifdef XMRIG_ALGO_CN_GPU
-    m_map[Algorithm::CN_GPU][AV_SINGLE][Assembly::NONE]      = cryptonight_single_hash_gpu<Algorithm::CN_GPU, false>;
-    m_map[Algorithm::CN_GPU][AV_SINGLE_SOFT][Assembly::NONE] = cryptonight_single_hash_gpu<Algorithm::CN_GPU, true>;
-#   endif
-
-#   ifdef XMRIG_ALGO_CN_LITE
-    ADD_FN(Algorithm::CN_LITE_0);
-    ADD_FN(Algorithm::CN_LITE_1);
-#   endif
-
-#   ifdef XMRIG_ALGO_CN_HEAVY
-    ADD_FN(Algorithm::CN_HEAVY_0);
-    ADD_FN(Algorithm::CN_HEAVY_TUBE);
-    ADD_FN(Algorithm::CN_HEAVY_XHV);
-#   endif
-
-#   ifdef XMRIG_ALGO_CN_PICO
-    ADD_FN(Algorithm::CN_PICO_0);
-    ADD_FN_ASM(Algorithm::CN_PICO_0);
-#   endif
-
-#   ifdef XMRIG_ALGO_ARGON2
-    m_map[Algorithm::AR2_CHUKWA][AV_SINGLE][Assembly::NONE]      = argon2::single_hash<Algorithm::AR2_CHUKWA>;
-    m_map[Algorithm::AR2_CHUKWA][AV_SINGLE_SOFT][Assembly::NONE] = argon2::single_hash<Algorithm::AR2_CHUKWA>;
-    m_map[Algorithm::AR2_WRKZ][AV_SINGLE][Assembly::NONE]        = argon2::single_hash<Algorithm::AR2_WRKZ>;
-    m_map[Algorithm::AR2_WRKZ][AV_SINGLE_SOFT][Assembly::NONE]   = argon2::single_hash<Algorithm::AR2_WRKZ>;
-#   endif
-
-#   ifdef XMRIG_FEATURE_ASM
-    patchAsmVariants();
-#   endif
+    m_map[AV_SINGLE][Assembly::NONE]      = cryptonight_single_hash<false>;
+    m_map[AV_SINGLE_SOFT][Assembly::NONE] = cryptonight_single_hash<true>;
+    m_map[AV_DOUBLE][Assembly::NONE]      = cryptonight_double_hash<false>;
+    m_map[AV_DOUBLE_SOFT][Assembly::NONE] = cryptonight_double_hash<true>;
+    m_map[AV_TRIPLE][Assembly::NONE]      = cryptonight_triple_hash<false>;
+    m_map[AV_TRIPLE_SOFT][Assembly::NONE] = cryptonight_triple_hash<true>;
+    m_map[AV_QUAD][Assembly::NONE]        = cryptonight_quad_hash<false>;
+    m_map[AV_QUAD_SOFT][Assembly::NONE]   = cryptonight_quad_hash<true>;
+    m_map[AV_PENTA][Assembly::NONE]       = cryptonight_penta_hash<false>;
+    m_map[AV_PENTA_SOFT][Assembly::NONE]  = cryptonight_penta_hash<true>;
 }
 
-
-xmrig::cn_hash_fun xmrig::CnHash::fn(const Algorithm &algorithm, AlgoVariant av, Assembly::Id assembly)
+xmrig::cn_hash_fun xmrig::CnHash::fn(AlgoVariant av, Assembly::Id assembly)
 {
-    if (!algorithm.isValid()) {
-        return nullptr;
-    }
-
-#   ifdef XMRIG_FEATURE_ASM
-    cn_hash_fun fun = cnHash.m_map[algorithm][av][Cpu::assembly(assembly)];
-    if (fun) {
-        return fun;
-    }
-#   endif
-
-    return cnHash.m_map[algorithm][av][Assembly::NONE];
+    return cnHash.m_map[av][Assembly::NONE];
 }
diff --git a/src/crypto/cn/CnHash.h b/src/crypto/cn/CnHash.h
index 92f4df9..2c792b6 100644
--- a/src/crypto/cn/CnHash.h
+++ b/src/crypto/cn/CnHash.h
@@ -41,7 +41,7 @@ struct cryptonight_ctx;
 namespace xmrig
 {
 
-using cn_hash_fun     = void (*)(const uint8_t *, size_t, uint8_t *, cryptonight_ctx **, uint64_t);
+using cn_hash_fun     = void (*)(const uint8_t *, size_t, uint8_t *, cryptonight_ctx **, uint64_t, uint64_t);
 using cn_mainloop_fun = void (*)(cryptonight_ctx **);
 
 
@@ -65,10 +65,10 @@ public:
 
     CnHash();
 
-    static cn_hash_fun fn(const Algorithm &algorithm, AlgoVariant av, Assembly::Id assembly);
+    static cn_hash_fun fn(AlgoVariant av, Assembly::Id assembly);
 
 private:
-    cn_hash_fun m_map[Algorithm::MAX][AV_MAX][Assembly::MAX] = {};
+    cn_hash_fun m_map[AV_MAX][Assembly::MAX] = {};
 };
 
 
diff --git a/src/crypto/cn/CryptoNight_monero.h b/src/crypto/cn/CryptoNight_monero.h
index dc012bd..d0b8691 100644
--- a/src/crypto/cn/CryptoNight_monero.h
+++ b/src/crypto/cn/CryptoNight_monero.h
@@ -30,45 +30,14 @@
 #include <math.h>
 
 // VARIANT ALTERATIONS
-#ifndef XMRIG_ARM
-#   define VARIANT1_INIT(part) \
-    uint64_t tweak1_2_##part = 0; \
-    if (BASE == Algorithm::CN_1) { \
-        tweak1_2_##part = (*reinterpret_cast<const uint64_t*>(input + 35 + part * size) ^ \
-                          *(reinterpret_cast<const uint64_t*>(ctx[part]->state) + 24)); \
-    }
-#else
-#   define VARIANT1_INIT(part) \
-    uint64_t tweak1_2_##part = 0; \
-    if (BASE == Algorithm::CN_1) { \
-        memcpy(&tweak1_2_##part, input + 35 + part * size, sizeof tweak1_2_##part); \
-        tweak1_2_##part ^= *(reinterpret_cast<const uint64_t*>(ctx[part]->state) + 24); \
-    }
-#endif
-
-#define VARIANT1_1(p) \
-    if (BASE == Algorithm::CN_1) { \
-        const uint8_t tmp = reinterpret_cast<const uint8_t*>(p)[11]; \
-        static const uint32_t table = 0x75310; \
-        const uint8_t index = (((tmp >> 3) & 6) | (tmp & 1)) << 1; \
-        ((uint8_t*)(p))[11] = tmp ^ ((table >> index) & 0x30); \
-    }
-
-#define VARIANT1_2(p, part) \
-    if (BASE == Algorithm::CN_1) { \
-        (p) ^= tweak1_2_##part; \
-    }
-
-
-#ifndef XMRIG_ARM
 #   define VARIANT2_INIT(part) \
     __m128i division_result_xmm_##part = _mm_cvtsi64_si128(static_cast<int64_t>(h##part[12])); \
     __m128i sqrt_result_xmm_##part     = _mm_cvtsi64_si128(static_cast<int64_t>(h##part[13]));
 
 #ifdef _MSC_VER
-#   define VARIANT2_SET_ROUNDING_MODE() if (BASE == Algorithm::CN_2) { _control87(RC_DOWN, MCW_RC); }
+#   define VARIANT2_SET_ROUNDING_MODE() _control87(RC_DOWN, MCW_RC);
 #else
-#   define VARIANT2_SET_ROUNDING_MODE() if (BASE == Algorithm::CN_2) { fesetround(FE_DOWNWARD); }
+#   define VARIANT2_SET_ROUNDING_MODE() fesetround(FE_DOWNWARD);
 #endif
 
 #   define VARIANT2_INTEGER_MATH(part, cl, cx) \
@@ -91,9 +60,6 @@
         _mm_store_si128((__m128i *)((base_ptr) + ((offset) ^ 0x10)), _mm_add_epi64(chunk3, _b1)); \
         _mm_store_si128((__m128i *)((base_ptr) + ((offset) ^ 0x20)), _mm_add_epi64(chunk1, _b)); \
         _mm_store_si128((__m128i *)((base_ptr) + ((offset) ^ 0x30)), _mm_add_epi64(chunk2, _a)); \
-        if (ALGO == Algorithm::CN_R) { \
-            _c = _mm_xor_si128(_mm_xor_si128(_c, chunk3), _mm_xor_si128(chunk1, chunk2)); \
-        } \
     } while (0)
 
 #   define VARIANT2_SHUFFLE2(base_ptr, offset, _a, _b, _b1, hi, lo, reverse) \
@@ -113,57 +79,6 @@
         _mm_store_si128((__m128i *)((base_ptr) + ((offset) ^ 0x30)), _mm_add_epi64(chunk2, _a)); \
     } while (0)
 
-#else
-#   define VARIANT2_INIT(part) \
-    uint64_t division_result_##part = h##part[12]; \
-    uint64_t sqrt_result_##part = h##part[13];
-
-#   define VARIANT2_INTEGER_MATH(part, cl, cx) \
-    do { \
-        const uint64_t cx_0 = _mm_cvtsi128_si64(cx); \
-        cl ^= division_result_##part ^ (sqrt_result_##part << 32); \
-        const uint32_t d = static_cast<uint32_t>(cx_0 + (sqrt_result_##part << 1)) | 0x80000001UL; \
-        const uint64_t cx_1 = _mm_cvtsi128_si64(_mm_srli_si128(cx, 8)); \
-        division_result_##part = static_cast<uint32_t>(cx_1 / d) + ((cx_1 % d) << 32); \
-        const uint64_t sqrt_input = cx_0 + division_result_##part; \
-        sqrt_result_##part = sqrt(sqrt_input + 18446744073709551616.0) * 2.0 - 8589934592.0; \
-        const uint64_t s = sqrt_result_##part >> 1; \
-        const uint64_t b = sqrt_result_##part & 1; \
-        const uint64_t r2 = (uint64_t)(s) * (s + b) + (sqrt_result_##part << 32); \
-        sqrt_result_##part += ((r2 + b > sqrt_input) ? -1 : 0) + ((r2 + (1ULL << 32) < sqrt_input - s) ? 1 : 0); \
-    } while (0)
-
-#   define VARIANT2_SHUFFLE(base_ptr, offset, _a, _b, _b1, _c, reverse) \
-    do { \
-        const uint64x2_t chunk1 = vld1q_u64((uint64_t*)((base_ptr) + ((offset) ^ (reverse ? 0x30 : 0x10)))); \
-        const uint64x2_t chunk2 = vld1q_u64((uint64_t*)((base_ptr) + ((offset) ^ 0x20))); \
-        const uint64x2_t chunk3 = vld1q_u64((uint64_t*)((base_ptr) + ((offset) ^ (reverse ? 0x10 : 0x30)))); \
-        vst1q_u64((uint64_t*)((base_ptr) + ((offset) ^ 0x10)), vaddq_u64(chunk3, vreinterpretq_u64_u8(_b1))); \
-        vst1q_u64((uint64_t*)((base_ptr) + ((offset) ^ 0x20)), vaddq_u64(chunk1, vreinterpretq_u64_u8(_b))); \
-        vst1q_u64((uint64_t*)((base_ptr) + ((offset) ^ 0x30)), vaddq_u64(chunk2, vreinterpretq_u64_u8(_a))); \
-        if (ALGO == Algorithm::CN_R) { \
-            _c = veorq_u64(veorq_u64(_c, chunk3), veorq_u64(chunk1, chunk2)); \
-        } \
-    } while (0)
-
-#   define VARIANT2_SHUFFLE2(base_ptr, offset, _a, _b, _b1, hi, lo, reverse) \
-    do { \
-        const uint64x2_t chunk1 = veorq_u64(vld1q_u64((uint64_t*)((base_ptr) + ((offset) ^ 0x10))), vcombine_u64(vcreate_u64(hi), vcreate_u64(lo))); \
-        const uint64x2_t chunk2 = vld1q_u64((uint64_t*)((base_ptr) + ((offset) ^ 0x20))); \
-        hi ^= ((uint64_t*)((base_ptr) + ((offset) ^ 0x20)))[0]; \
-        lo ^= ((uint64_t*)((base_ptr) + ((offset) ^ 0x20)))[1]; \
-        const uint64x2_t chunk3 = vld1q_u64((uint64_t*)((base_ptr) + ((offset) ^ 0x30))); \
-        if (reverse) { \
-            vst1q_u64((uint64_t*)((base_ptr) + ((offset) ^ 0x10)), vaddq_u64(chunk1, vreinterpretq_u64_u8(_b1))); \
-            vst1q_u64((uint64_t*)((base_ptr) + ((offset) ^ 0x20)), vaddq_u64(chunk3, vreinterpretq_u64_u8(_b))); \
-        } else { \
-            vst1q_u64((uint64_t*)((base_ptr) + ((offset) ^ 0x10)), vaddq_u64(chunk3, vreinterpretq_u64_u8(_b1))); \
-            vst1q_u64((uint64_t*)((base_ptr) + ((offset) ^ 0x20)), vaddq_u64(chunk1, vreinterpretq_u64_u8(_b))); \
-        } \
-        vst1q_u64((uint64_t*)((base_ptr) + ((offset) ^ 0x30)), vaddq_u64(chunk2, vreinterpretq_u64_u8(_a))); \
-    } while (0)
-#endif
-
 #define SWAP32LE(x) x
 #define SWAP64LE(x) x
 #define hash_extra_blake(data, length, hash) blake256_hash((uint8_t*)(hash), (uint8_t*)(data), (length))
@@ -178,28 +93,4 @@
 #endif
 #endif
 
-#include "crypto/cn/r/variant4_random_math.h"
-
-#define VARIANT4_RANDOM_MATH_INIT(part) \
-  uint32_t r##part[9]; \
-  struct V4_Instruction code##part[256]; \
-  if (props.isR()) { \
-    r##part[0] = static_cast<uint32_t>(h##part[12]); \
-    r##part[1] = static_cast<uint32_t>(h##part[12] >> 32); \
-    r##part[2] = static_cast<uint32_t>(h##part[13]); \
-    r##part[3] = static_cast<uint32_t>(h##part[13] >> 32); \
-  } \
-  v4_random_math_init<ALGO>(code##part, height);
-
-#define VARIANT4_RANDOM_MATH(part, al, ah, cl, bx0, bx1) \
-  if (props.isR()) { \
-    cl ^= (r##part[0] + r##part[1]) | (static_cast<uint64_t>(r##part[2] + r##part[3]) << 32); \
-    r##part[4] = static_cast<uint32_t>(al); \
-    r##part[5] = static_cast<uint32_t>(ah); \
-    r##part[6] = static_cast<uint32_t>(_mm_cvtsi128_si32(bx0)); \
-    r##part[7] = static_cast<uint32_t>(_mm_cvtsi128_si32(bx1)); \
-    r##part[8] = static_cast<uint32_t>(_mm_cvtsi128_si32(_mm_srli_si128(bx1, 8))); \
-    v4_random_math(code##part, r##part); \
-  }
-
 #endif /* XMRIG_CRYPTONIGHT_MONERO_H */
diff --git a/src/crypto/cn/CryptoNight_x86.h b/src/crypto/cn/CryptoNight_x86.h
index 9fb606d..a3f8df5 100644
--- a/src/crypto/cn/CryptoNight_x86.h
+++ b/src/crypto/cn/CryptoNight_x86.h
@@ -51,6 +51,26 @@ extern "C"
 #include "crypto/cn/c_skein.h"
 }
 
+#ifndef FORCEINLINE
+#ifdef __GNUC__
+#define FORCEINLINE __attribute__((always_inline)) inline
+#elif _MSC_VER
+#define FORCEINLINE __forceinline
+#else
+#define FORCEINLINE inline
+#endif
+#endif
+
+#ifndef UNREACHABLE_CODE
+#ifdef __GNUC__
+#define UNREACHABLE_CODE __builtin_unreachable()
+#elif _MSC_VER
+#define UNREACHABLE_CODE __assume(false)
+#else
+#define UNREACHABLE_CODE
+#endif
+#endif
+
 
 static inline void do_blake_hash(const uint8_t *input, size_t len, uint8_t *output) {
     blake256_hash(output, input, len);
@@ -289,27 +309,13 @@ FORCEINLINE void aes_round<false>(__m128i key, __m128i* x0, __m128i* x1, __m128i
     *x7 = _mm_aesenc_si128(*x7, key);
 }
 
-inline void mix_and_propagate(__m128i& x0, __m128i& x1, __m128i& x2, __m128i& x3, __m128i& x4, __m128i& x5, __m128i& x6, __m128i& x7)
-{
-    __m128i tmp0 = x0;
-    x0 = _mm_xor_si128(x0, x1);
-    x1 = _mm_xor_si128(x1, x2);
-    x2 = _mm_xor_si128(x2, x3);
-    x3 = _mm_xor_si128(x3, x4);
-    x4 = _mm_xor_si128(x4, x5);
-    x5 = _mm_xor_si128(x5, x6);
-    x6 = _mm_xor_si128(x6, x7);
-    x7 = _mm_xor_si128(x7, tmp0);
-}
-
-
 namespace xmrig {
 
 
-template<Algorithm::Id ALGO, bool SOFT_AES>
+template<bool SOFT_AES>
 static inline void cn_explode_scratchpad(const __m128i *input, __m128i *output)
 {
-    constexpr CnAlgo<ALGO> props;
+    constexpr CnAlgo props;
 
     __m128i xin0, xin1, xin2, xin3, xin4, xin5, xin6, xin7;
     __m128i k0, k1, k2, k3, k4, k5, k6, k7, k8, k9;
@@ -325,23 +331,6 @@ static inline void cn_explode_scratchpad(const __m128i *input, __m128i *output)
     xin6 = _mm_load_si128(input + 10);
     xin7 = _mm_load_si128(input + 11);
 
-    if (props.isHeavy()) {
-        for (size_t i = 0; i < 16; i++) {
-            aes_round<SOFT_AES>(k0, &xin0, &xin1, &xin2, &xin3, &xin4, &xin5, &xin6, &xin7);
-            aes_round<SOFT_AES>(k1, &xin0, &xin1, &xin2, &xin3, &xin4, &xin5, &xin6, &xin7);
-            aes_round<SOFT_AES>(k2, &xin0, &xin1, &xin2, &xin3, &xin4, &xin5, &xin6, &xin7);
-            aes_round<SOFT_AES>(k3, &xin0, &xin1, &xin2, &xin3, &xin4, &xin5, &xin6, &xin7);
-            aes_round<SOFT_AES>(k4, &xin0, &xin1, &xin2, &xin3, &xin4, &xin5, &xin6, &xin7);
-            aes_round<SOFT_AES>(k5, &xin0, &xin1, &xin2, &xin3, &xin4, &xin5, &xin6, &xin7);
-            aes_round<SOFT_AES>(k6, &xin0, &xin1, &xin2, &xin3, &xin4, &xin5, &xin6, &xin7);
-            aes_round<SOFT_AES>(k7, &xin0, &xin1, &xin2, &xin3, &xin4, &xin5, &xin6, &xin7);
-            aes_round<SOFT_AES>(k8, &xin0, &xin1, &xin2, &xin3, &xin4, &xin5, &xin6, &xin7);
-            aes_round<SOFT_AES>(k9, &xin0, &xin1, &xin2, &xin3, &xin4, &xin5, &xin6, &xin7);
-
-            mix_and_propagate(xin0, xin1, xin2, xin3, xin4, xin5, xin6, xin7);
-        }
-    }
-
     for (size_t i = 0; i < props.memory() / sizeof(__m128i); i += 8) {
         aes_round<SOFT_AES>(k0, &xin0, &xin1, &xin2, &xin3, &xin4, &xin5, &xin6, &xin7);
         aes_round<SOFT_AES>(k1, &xin0, &xin1, &xin2, &xin3, &xin4, &xin5, &xin6, &xin7);
@@ -366,16 +355,10 @@ static inline void cn_explode_scratchpad(const __m128i *input, __m128i *output)
 }
 
 
-template<Algorithm::Id ALGO, bool SOFT_AES>
+template<bool SOFT_AES>
 static inline void cn_implode_scratchpad(const __m128i *input, __m128i *output)
 {
-    constexpr CnAlgo<ALGO> props;
-
-#   ifdef XMRIG_ALGO_CN_GPU
-    constexpr bool IS_HEAVY = props.isHeavy() || ALGO == Algorithm::CN_GPU;
-#   else
-    constexpr bool IS_HEAVY = props.isHeavy();
-#   endif
+    constexpr CnAlgo props;
 
     __m128i xout0, xout1, xout2, xout3, xout4, xout5, xout6, xout7;
     __m128i k0, k1, k2, k3, k4, k5, k6, k7, k8, k9;
@@ -411,51 +394,6 @@ static inline void cn_implode_scratchpad(const __m128i *input, __m128i *output)
         aes_round<SOFT_AES>(k7, &xout0, &xout1, &xout2, &xout3, &xout4, &xout5, &xout6, &xout7);
         aes_round<SOFT_AES>(k8, &xout0, &xout1, &xout2, &xout3, &xout4, &xout5, &xout6, &xout7);
         aes_round<SOFT_AES>(k9, &xout0, &xout1, &xout2, &xout3, &xout4, &xout5, &xout6, &xout7);
-
-        if (IS_HEAVY) {
-            mix_and_propagate(xout0, xout1, xout2, xout3, xout4, xout5, xout6, xout7);
-        }
-    }
-
-    if (IS_HEAVY) {
-        for (size_t i = 0; i < props.memory() / sizeof(__m128i); i += 8) {
-            xout0 = _mm_xor_si128(_mm_load_si128(input + i + 0), xout0);
-            xout1 = _mm_xor_si128(_mm_load_si128(input + i + 1), xout1);
-            xout2 = _mm_xor_si128(_mm_load_si128(input + i + 2), xout2);
-            xout3 = _mm_xor_si128(_mm_load_si128(input + i + 3), xout3);
-            xout4 = _mm_xor_si128(_mm_load_si128(input + i + 4), xout4);
-            xout5 = _mm_xor_si128(_mm_load_si128(input + i + 5), xout5);
-            xout6 = _mm_xor_si128(_mm_load_si128(input + i + 6), xout6);
-            xout7 = _mm_xor_si128(_mm_load_si128(input + i + 7), xout7);
-
-            aes_round<SOFT_AES>(k0, &xout0, &xout1, &xout2, &xout3, &xout4, &xout5, &xout6, &xout7);
-            aes_round<SOFT_AES>(k1, &xout0, &xout1, &xout2, &xout3, &xout4, &xout5, &xout6, &xout7);
-            aes_round<SOFT_AES>(k2, &xout0, &xout1, &xout2, &xout3, &xout4, &xout5, &xout6, &xout7);
-            aes_round<SOFT_AES>(k3, &xout0, &xout1, &xout2, &xout3, &xout4, &xout5, &xout6, &xout7);
-            aes_round<SOFT_AES>(k4, &xout0, &xout1, &xout2, &xout3, &xout4, &xout5, &xout6, &xout7);
-            aes_round<SOFT_AES>(k5, &xout0, &xout1, &xout2, &xout3, &xout4, &xout5, &xout6, &xout7);
-            aes_round<SOFT_AES>(k6, &xout0, &xout1, &xout2, &xout3, &xout4, &xout5, &xout6, &xout7);
-            aes_round<SOFT_AES>(k7, &xout0, &xout1, &xout2, &xout3, &xout4, &xout5, &xout6, &xout7);
-            aes_round<SOFT_AES>(k8, &xout0, &xout1, &xout2, &xout3, &xout4, &xout5, &xout6, &xout7);
-            aes_round<SOFT_AES>(k9, &xout0, &xout1, &xout2, &xout3, &xout4, &xout5, &xout6, &xout7);
-
-            mix_and_propagate(xout0, xout1, xout2, xout3, xout4, xout5, xout6, xout7);
-        }
-
-        for (size_t i = 0; i < 16; i++) {
-            aes_round<SOFT_AES>(k0, &xout0, &xout1, &xout2, &xout3, &xout4, &xout5, &xout6, &xout7);
-            aes_round<SOFT_AES>(k1, &xout0, &xout1, &xout2, &xout3, &xout4, &xout5, &xout6, &xout7);
-            aes_round<SOFT_AES>(k2, &xout0, &xout1, &xout2, &xout3, &xout4, &xout5, &xout6, &xout7);
-            aes_round<SOFT_AES>(k3, &xout0, &xout1, &xout2, &xout3, &xout4, &xout5, &xout6, &xout7);
-            aes_round<SOFT_AES>(k4, &xout0, &xout1, &xout2, &xout3, &xout4, &xout5, &xout6, &xout7);
-            aes_round<SOFT_AES>(k5, &xout0, &xout1, &xout2, &xout3, &xout4, &xout5, &xout6, &xout7);
-            aes_round<SOFT_AES>(k6, &xout0, &xout1, &xout2, &xout3, &xout4, &xout5, &xout6, &xout7);
-            aes_round<SOFT_AES>(k7, &xout0, &xout1, &xout2, &xout3, &xout4, &xout5, &xout6, &xout7);
-            aes_round<SOFT_AES>(k8, &xout0, &xout1, &xout2, &xout3, &xout4, &xout5, &xout6, &xout7);
-            aes_round<SOFT_AES>(k9, &xout0, &xout1, &xout2, &xout3, &xout4, &xout5, &xout6, &xout7);
-
-            mix_and_propagate(xout0, xout1, xout2, xout3, xout4, xout5, xout6, xout7);
-        }
     }
 
     _mm_store_si128(output + 4, xout0);
@@ -513,84 +451,34 @@ static inline __m128i int_sqrt_v2(const uint64_t n0)
     return _mm_cvtsi64_si128(r);
 }
 
-
-void v4_soft_aes_compile_code(const V4_Instruction *code, int code_size, void *machine_code, xmrig::Assembly ASM);
-
-
 namespace xmrig {
 
 
-template<Algorithm::Id ALGO>
 static inline void cryptonight_monero_tweak(uint64_t *mem_out, const uint8_t *l, uint64_t idx, __m128i ax0, __m128i bx0, __m128i bx1, __m128i& cx)
 {
-    constexpr CnAlgo<ALGO> props;
-
-    if (props.base() == Algorithm::CN_2) {
-        VARIANT2_SHUFFLE(l, idx, ax0, bx0, bx1, cx, (ALGO == Algorithm::CN_RWZ ? 1 : 0));
-        _mm_store_si128(reinterpret_cast<__m128i *>(mem_out), _mm_xor_si128(bx0, cx));
-    } else {
-        __m128i tmp = _mm_xor_si128(bx0, cx);
-        mem_out[0] = _mm_cvtsi128_si64(tmp);
-
-        tmp = _mm_castps_si128(_mm_movehl_ps(_mm_castsi128_ps(tmp), _mm_castsi128_ps(tmp)));
-        uint64_t vh = _mm_cvtsi128_si64(tmp);
+    constexpr CnAlgo props;
 
-        uint8_t x = static_cast<uint8_t>(vh >> 24);
-        static const uint16_t table = 0x7531;
-        const uint8_t index = (((x >> (3)) & 6) | (x & 1)) << 1;
-        vh ^= ((table >> index) & 0x3) << 28;
-
-        mem_out[1] = vh;
-    }
+    VARIANT2_SHUFFLE(l, idx, ax0, bx0, bx1, cx, 0);
+    _mm_store_si128(reinterpret_cast<__m128i *>(mem_out), _mm_xor_si128(bx0, cx));
 }
 
 
-template<Algorithm::Id ALGO, bool SOFT_AES>
-inline void cryptonight_single_hash(const uint8_t *__restrict__ input, size_t size, uint8_t *__restrict__ output, cryptonight_ctx **__restrict__ ctx, uint64_t height)
+template<bool SOFT_AES>
+inline void cryptonight_single_hash(const uint8_t *__restrict__ input, size_t size, uint8_t *__restrict__ output, cryptonight_ctx **__restrict__ ctx, uint64_t height, uint64_t extra_iters)
 {
-    constexpr CnAlgo<ALGO> props;
+    constexpr CnAlgo props;
     constexpr size_t MASK        = props.mask();
-    constexpr Algorithm::Id BASE = props.base();
 
-#   ifdef XMRIG_ALGO_CN_HEAVY
-    constexpr bool IS_CN_HEAVY_TUBE = ALGO == Algorithm::CN_HEAVY_TUBE;
-#   else
-    constexpr bool IS_CN_HEAVY_TUBE = false;
-#   endif
-
-    if (BASE == Algorithm::CN_1 && size < 43) {
-        memset(output, 0, 32);
-        return;
-    }
+    uint32_t iters = (props.iterations() + extra_iters) >> 1;
 
     keccak(input, size, ctx[0]->state);
-    cn_explode_scratchpad<ALGO, SOFT_AES>(reinterpret_cast<const __m128i *>(ctx[0]->state), reinterpret_cast<__m128i *>(ctx[0]->memory));
+    cn_explode_scratchpad<SOFT_AES>(reinterpret_cast<const __m128i *>(ctx[0]->state), reinterpret_cast<__m128i *>(ctx[0]->memory));
 
     uint64_t *h0 = reinterpret_cast<uint64_t*>(ctx[0]->state);
     uint8_t *l0   = ctx[0]->memory;
 
-#   ifdef XMRIG_FEATURE_ASM
-    if (SOFT_AES && props.isR()) {
-        if (!ctx[0]->generated_code_data.match(ALGO, height)) {
-            V4_Instruction code[256];
-            const int code_size = v4_random_math_init<ALGO>(code, height);
-
-            if (ALGO == Algorithm::CN_R) {
-                v4_soft_aes_compile_code(code, code_size, reinterpret_cast<void*>(ctx[0]->generated_code), Assembly::NONE);
-            }
-
-            ctx[0]->generated_code_data = { ALGO, height };
-        }
-
-        ctx[0]->saes_table = reinterpret_cast<const uint32_t*>(saes_table);
-        ctx[0]->generated_code(ctx);
-    } else {
-#   endif
-
-    VARIANT1_INIT(0);
     VARIANT2_INIT(0);
     VARIANT2_SET_ROUNDING_MODE();
-    VARIANT4_RANDOM_MATH_INIT(0);
 
     uint64_t al0  = h0[0] ^ h0[4];
     uint64_t ah0  = h0[1] ^ h0[5];
@@ -598,28 +486,21 @@ inline void cryptonight_single_hash(const uint8_t *__restrict__ input, size_t si
     __m128i bx0   = _mm_set_epi64x(static_cast<int64_t>(h0[3] ^ h0[7]), static_cast<int64_t>(h0[2] ^ h0[6]));
     __m128i bx1   = _mm_set_epi64x(static_cast<int64_t>(h0[9] ^ h0[11]), static_cast<int64_t>(h0[8] ^ h0[10]));
 
-    for (size_t i = 0; i < props.iterations(); i++) {
+    for (size_t i = 0; i < iters; i++) {
         __m128i cx;
-        if (IS_CN_HEAVY_TUBE || !SOFT_AES) {
+        if (!SOFT_AES) {
             cx = _mm_load_si128(reinterpret_cast<const __m128i *>(&l0[idx0 & MASK]));
         }
 
         const __m128i ax0 = _mm_set_epi64x(static_cast<int64_t>(ah0), static_cast<int64_t>(al0));
-        if (IS_CN_HEAVY_TUBE) {
-            cx = aes_round_tweak_div(cx, ax0);
-        }
-        else if (SOFT_AES) {
+        if (SOFT_AES) {
             cx = soft_aesenc(&l0[idx0 & MASK], ax0, reinterpret_cast<const uint32_t*>(saes_table));
         }
         else {
             cx = _mm_aesenc_si128(cx, ax0);
         }
 
-        if (BASE == Algorithm::CN_1 || BASE == Algorithm::CN_2) {
-            cryptonight_monero_tweak<ALGO>(reinterpret_cast<uint64_t*>(&l0[idx0 & MASK]), l0, idx0 & MASK, ax0, bx0, bx1, cx);
-        } else {
-            _mm_store_si128(reinterpret_cast<__m128i *>(&l0[idx0 & MASK]), _mm_xor_si128(bx0, cx));
-        }
+        cryptonight_monero_tweak(reinterpret_cast<uint64_t*>(&l0[idx0 & MASK]), l0, idx0 & MASK, ax0, bx0, bx1, cx);
 
         idx0 = static_cast<uint64_t>(_mm_cvtsi128_si64(cx));
 
@@ -627,73 +508,27 @@ inline void cryptonight_single_hash(const uint8_t *__restrict__ input, size_t si
         cl = (reinterpret_cast<uint64_t*>(&l0[idx0 & MASK]))[0];
         ch = (reinterpret_cast<uint64_t*>(&l0[idx0 & MASK]))[1];
 
-        if (BASE == Algorithm::CN_2) {
-            if (props.isR()) {
-                VARIANT4_RANDOM_MATH(0, al0, ah0, cl, bx0, bx1);
-                if (ALGO == Algorithm::CN_R) {
-                    al0 ^= r0[2] | (static_cast<uint64_t>(r0[3]) << 32);
-                    ah0 ^= r0[0] | (static_cast<uint64_t>(r0[1]) << 32);
-                }
-            } else {
-                VARIANT2_INTEGER_MATH(0, cl, cx);
-            }
-        }
+        VARIANT2_INTEGER_MATH(0, cl, cx);
 
         lo = __umul128(idx0, cl, &hi);
 
-        if (BASE == Algorithm::CN_2) {
-            if (ALGO == Algorithm::CN_R) {
-                VARIANT2_SHUFFLE(l0, idx0 & MASK, ax0, bx0, bx1, cx, 0);
-            } else {
-                VARIANT2_SHUFFLE2(l0, idx0 & MASK, ax0, bx0, bx1, hi, lo, (ALGO == Algorithm::CN_RWZ ? 1 : 0));
-            }
-        }
+        VARIANT2_SHUFFLE2(l0, idx0 & MASK, ax0, bx0, bx1, hi, lo, 0);
 
         al0 += hi;
         ah0 += lo;
 
         reinterpret_cast<uint64_t*>(&l0[idx0 & MASK])[0] = al0;
-
-        if (IS_CN_HEAVY_TUBE || ALGO == Algorithm::CN_RTO) {
-            reinterpret_cast<uint64_t*>(&l0[idx0 & MASK])[1] = ah0 ^ tweak1_2_0 ^ al0;
-        } else if (BASE == Algorithm::CN_1) {
-            reinterpret_cast<uint64_t*>(&l0[idx0 & MASK])[1] = ah0 ^ tweak1_2_0;
-        } else {
-            reinterpret_cast<uint64_t*>(&l0[idx0 & MASK])[1] = ah0;
-        }
+        reinterpret_cast<uint64_t*>(&l0[idx0 & MASK])[1] = ah0;
 
         al0 ^= cl;
         ah0 ^= ch;
         idx0 = al0;
-
-#       ifdef XMRIG_ALGO_CN_HEAVY
-        if (props.isHeavy()) {
-            int64_t n = ((int64_t*)&l0[idx0 & MASK])[0];
-            int32_t d = ((int32_t*)&l0[idx0 & MASK])[2];
-            int64_t q = n / (d | 0x5);
-
-            ((int64_t*)&l0[idx0 & MASK])[0] = n ^ q;
-
-            if (ALGO == Algorithm::CN_HEAVY_XHV) {
-                d = ~d;
-            }
-
-            idx0 = d ^ q;
-        }
-#       endif
-
-        if (BASE == Algorithm::CN_2) {
-            bx1 = bx0;
-        }
+        bx1 = bx0;
 
         bx0 = cx;
     }
 
-#   ifdef XMRIG_FEATURE_ASM
-    }
-#   endif
-
-    cn_implode_scratchpad<ALGO, SOFT_AES>(reinterpret_cast<const __m128i *>(ctx[0]->memory), reinterpret_cast<__m128i *>(ctx[0]->state));
+    cn_implode_scratchpad<SOFT_AES>(reinterpret_cast<const __m128i *>(ctx[0]->memory), reinterpret_cast<__m128i *>(ctx[0]->state));
     keccakf(h0, 24);
     extra_hashes[ctx[0]->state[0] & 3](ctx[0]->state, 200, output);
 }
@@ -701,298 +536,16 @@ inline void cryptonight_single_hash(const uint8_t *__restrict__ input, size_t si
 
 } /* namespace xmrig */
 
-
-#ifdef XMRIG_ALGO_CN_GPU
-template<size_t ITER, uint32_t MASK>
-void cn_gpu_inner_avx(const uint8_t *spad, uint8_t *lpad);
-
-
-template<size_t ITER, uint32_t MASK>
-void cn_gpu_inner_ssse3(const uint8_t *spad, uint8_t *lpad);
-
-
-namespace xmrig {
-
-
-template<size_t MEM>
-void cn_explode_scratchpad_gpu(const uint8_t *input, uint8_t *output)
-{
-    constexpr size_t hash_size = 200; // 25x8 bytes
-    alignas(16) uint64_t hash[25];
-
-    for (uint64_t i = 0; i < MEM / 512; i++) {
-        memcpy(hash, input, hash_size);
-        hash[0] ^= i;
-
-        xmrig::keccakf(hash, 24);
-        memcpy(output, hash, 160);
-        output += 160;
-
-        xmrig::keccakf(hash, 24);
-        memcpy(output, hash, 176);
-        output += 176;
-
-        xmrig::keccakf(hash, 24);
-        memcpy(output, hash, 176);
-        output += 176;
-    }
-}
-
-
-template<Algorithm::Id ALGO, bool SOFT_AES>
-inline void cryptonight_single_hash_gpu(const uint8_t *__restrict__ input, size_t size, uint8_t *__restrict__ output, cryptonight_ctx **__restrict__ ctx, uint64_t)
-{
-    constexpr CnAlgo<ALGO> props;
-
-    keccak(input, size, ctx[0]->state);
-    cn_explode_scratchpad_gpu<props.memory()>(ctx[0]->state, ctx[0]->memory);
-
-#   ifdef _MSC_VER
-    _control87(RC_NEAR, MCW_RC);
-#   else
-    fesetround(FE_TONEAREST);
-#   endif
-
-    if (xmrig::Cpu::info()->hasAVX2()) {
-        cn_gpu_inner_avx<props.iterations(), props.mask()>(ctx[0]->state, ctx[0]->memory);
-    } else {
-        cn_gpu_inner_ssse3<props.iterations(), props.mask()>(ctx[0]->state, ctx[0]->memory);
-    }
-
-    cn_implode_scratchpad<ALGO, SOFT_AES>(reinterpret_cast<const __m128i *>(ctx[0]->memory), reinterpret_cast<__m128i *>(ctx[0]->state));
-    keccakf(reinterpret_cast<uint64_t*>(ctx[0]->state), 24);
-    memcpy(output, ctx[0]->state, 32);
-}
-
-
-} /* namespace xmrig */
-#endif
-
-
-#ifdef XMRIG_FEATURE_ASM
-extern "C" void cnv2_mainloop_ivybridge_asm(cryptonight_ctx **ctx);
-extern "C" void cnv2_mainloop_ryzen_asm(cryptonight_ctx **ctx);
-extern "C" void cnv2_mainloop_bulldozer_asm(cryptonight_ctx **ctx);
-extern "C" void cnv2_double_mainloop_sandybridge_asm(cryptonight_ctx **ctx);
-extern "C" void cnv2_rwz_mainloop_asm(cryptonight_ctx **ctx);
-extern "C" void cnv2_rwz_double_mainloop_asm(cryptonight_ctx **ctx);
-
-
-namespace xmrig {
-
-
-typedef void (*cn_mainloop_fun)(cryptonight_ctx **ctx);
-
-
-extern cn_mainloop_fun cn_half_mainloop_ivybridge_asm;
-extern cn_mainloop_fun cn_half_mainloop_ryzen_asm;
-extern cn_mainloop_fun cn_half_mainloop_bulldozer_asm;
-extern cn_mainloop_fun cn_half_double_mainloop_sandybridge_asm;
-
-extern cn_mainloop_fun cn_trtl_mainloop_ivybridge_asm;
-extern cn_mainloop_fun cn_trtl_mainloop_ryzen_asm;
-extern cn_mainloop_fun cn_trtl_mainloop_bulldozer_asm;
-extern cn_mainloop_fun cn_trtl_double_mainloop_sandybridge_asm;
-
-extern cn_mainloop_fun cn_zls_mainloop_ivybridge_asm;
-extern cn_mainloop_fun cn_zls_mainloop_ryzen_asm;
-extern cn_mainloop_fun cn_zls_mainloop_bulldozer_asm;
-extern cn_mainloop_fun cn_zls_double_mainloop_sandybridge_asm;
-
-extern cn_mainloop_fun cn_double_mainloop_ivybridge_asm;
-extern cn_mainloop_fun cn_double_mainloop_ryzen_asm;
-extern cn_mainloop_fun cn_double_mainloop_bulldozer_asm;
-extern cn_mainloop_fun cn_double_double_mainloop_sandybridge_asm;
-
-
-} // namespace xmrig
-
-
-void v4_compile_code(const V4_Instruction* code, int code_size, void* machine_code, xmrig::Assembly ASM);
-void v4_compile_code_double(const V4_Instruction* code, int code_size, void* machine_code, xmrig::Assembly ASM);
-
-
-template<xmrig::Algorithm::Id ALGO>
-void cn_r_compile_code(const V4_Instruction* code, int code_size, void* machine_code, xmrig::Assembly ASM)
-{
-    v4_compile_code(code, code_size, machine_code, ASM);
-}
-
-
-template<xmrig::Algorithm::Id ALGO>
-void cn_r_compile_code_double(const V4_Instruction* code, int code_size, void* machine_code, xmrig::Assembly ASM)
-{
-    v4_compile_code_double(code, code_size, machine_code, ASM);
-}
-
-
-namespace xmrig {
-
-
-template<Algorithm::Id ALGO, Assembly::Id ASM>
-inline void cryptonight_single_hash_asm(const uint8_t *__restrict__ input, size_t size, uint8_t *__restrict__ output, cryptonight_ctx **__restrict__ ctx, uint64_t height)
-{
-    constexpr CnAlgo<ALGO> props;
-
-    if (props.isR() && !ctx[0]->generated_code_data.match(ALGO, height)) {
-        V4_Instruction code[256];
-        const int code_size = v4_random_math_init<ALGO>(code, height);
-        cn_r_compile_code<ALGO>(code, code_size, reinterpret_cast<void*>(ctx[0]->generated_code), ASM);
-
-        ctx[0]->generated_code_data = { ALGO, height };
-    }
-
-    keccak(input, size, ctx[0]->state);
-    cn_explode_scratchpad<ALGO, false>(reinterpret_cast<const __m128i*>(ctx[0]->state), reinterpret_cast<__m128i*>(ctx[0]->memory));
-
-    if (ALGO == Algorithm::CN_2) {
-        if (ASM == Assembly::INTEL) {
-            cnv2_mainloop_ivybridge_asm(ctx);
-        }
-        else if (ASM == Assembly::RYZEN) {
-            cnv2_mainloop_ryzen_asm(ctx);
-        }
-        else {
-            cnv2_mainloop_bulldozer_asm(ctx);
-        }
-    }
-    else if (ALGO == Algorithm::CN_HALF) {
-        if (ASM == Assembly::INTEL) {
-            cn_half_mainloop_ivybridge_asm(ctx);
-        }
-        else if (ASM == Assembly::RYZEN) {
-            cn_half_mainloop_ryzen_asm(ctx);
-        }
-        else {
-            cn_half_mainloop_bulldozer_asm(ctx);
-        }
-    }
-#   ifdef XMRIG_ALGO_CN_PICO
-    else if (ALGO == Algorithm::CN_PICO_0) {
-        if (ASM == Assembly::INTEL) {
-            cn_trtl_mainloop_ivybridge_asm(ctx);
-        }
-        else if (ASM == Assembly::RYZEN) {
-            cn_trtl_mainloop_ryzen_asm(ctx);
-        }
-        else {
-            cn_trtl_mainloop_bulldozer_asm(ctx);
-        }
-    }
-#   endif
-    else if (ALGO == Algorithm::CN_RWZ) {
-        cnv2_rwz_mainloop_asm(ctx);
-    }
-    else if (ALGO == Algorithm::CN_ZLS) {
-        if (ASM == Assembly::INTEL) {
-            cn_zls_mainloop_ivybridge_asm(ctx);
-        }
-        else if (ASM == Assembly::RYZEN) {
-            cn_zls_mainloop_ryzen_asm(ctx);
-        }
-        else {
-            cn_zls_mainloop_bulldozer_asm(ctx);
-        }
-    }
-    else if (ALGO == Algorithm::CN_DOUBLE) {
-        if (ASM == Assembly::INTEL) {
-            cn_double_mainloop_ivybridge_asm(ctx);
-        }
-        else if (ASM == Assembly::RYZEN) {
-            cn_double_mainloop_ryzen_asm(ctx);
-        }
-        else {
-            cn_double_mainloop_bulldozer_asm(ctx);
-        }
-    }
-    else if (props.isR()) {
-        ctx[0]->generated_code(ctx);
-    }
-
-    cn_implode_scratchpad<ALGO, false>(reinterpret_cast<const __m128i*>(ctx[0]->memory), reinterpret_cast<__m128i*>(ctx[0]->state));
-    keccakf(reinterpret_cast<uint64_t*>(ctx[0]->state), 24);
-    extra_hashes[ctx[0]->state[0] & 3](ctx[0]->state, 200, output);
-}
-
-
-template<Algorithm::Id ALGO, Assembly::Id ASM>
-inline void cryptonight_double_hash_asm(const uint8_t *__restrict__ input, size_t size, uint8_t *__restrict__ output, cryptonight_ctx **__restrict__ ctx, uint64_t height)
-{
-    constexpr CnAlgo<ALGO> props;
-
-    if (props.isR() && !ctx[0]->generated_code_data.match(ALGO, height)) {
-        V4_Instruction code[256];
-        const int code_size = v4_random_math_init<ALGO>(code, height);
-        cn_r_compile_code_double<ALGO>(code, code_size, reinterpret_cast<void*>(ctx[0]->generated_code), ASM);
-
-        ctx[0]->generated_code_data = { ALGO, height };
-    }
-
-    keccak(input,        size, ctx[0]->state);
-    keccak(input + size, size, ctx[1]->state);
-
-    cn_explode_scratchpad<ALGO, false>(reinterpret_cast<const __m128i*>(ctx[0]->state), reinterpret_cast<__m128i*>(ctx[0]->memory));
-    cn_explode_scratchpad<ALGO, false>(reinterpret_cast<const __m128i*>(ctx[1]->state), reinterpret_cast<__m128i*>(ctx[1]->memory));
-
-    if (ALGO == Algorithm::CN_2) {
-        cnv2_double_mainloop_sandybridge_asm(ctx);
-    }
-    else if (ALGO == Algorithm::CN_HALF) {
-        cn_half_double_mainloop_sandybridge_asm(ctx);
-    }
-#   ifdef XMRIG_ALGO_CN_PICO
-    else if (ALGO == Algorithm::CN_PICO_0) {
-        cn_trtl_double_mainloop_sandybridge_asm(ctx);
-    }
-#   endif
-    else if (ALGO == Algorithm::CN_RWZ) {
-        cnv2_rwz_double_mainloop_asm(ctx);
-    }
-    else if (ALGO == Algorithm::CN_ZLS) {
-        cn_zls_double_mainloop_sandybridge_asm(ctx);
-    }
-    else if (ALGO == Algorithm::CN_DOUBLE) {
-        cn_double_double_mainloop_sandybridge_asm(ctx);
-    }
-    else if (props.isR()) {
-        ctx[0]->generated_code(ctx);
-    }
-
-    cn_implode_scratchpad<ALGO, false>(reinterpret_cast<const __m128i*>(ctx[0]->memory), reinterpret_cast<__m128i*>(ctx[0]->state));
-    cn_implode_scratchpad<ALGO, false>(reinterpret_cast<const __m128i*>(ctx[1]->memory), reinterpret_cast<__m128i*>(ctx[1]->state));
-
-    keccakf(reinterpret_cast<uint64_t*>(ctx[0]->state), 24);
-    keccakf(reinterpret_cast<uint64_t*>(ctx[1]->state), 24);
-
-    extra_hashes[ctx[0]->state[0] & 3](ctx[0]->state, 200, output);
-    extra_hashes[ctx[1]->state[0] & 3](ctx[1]->state, 200, output + 32);
-}
-
-
-} /* namespace xmrig */
-#endif
-
-
 namespace xmrig {
 
 
-template<Algorithm::Id ALGO, bool SOFT_AES>
-inline void cryptonight_double_hash(const uint8_t *__restrict__ input, size_t size, uint8_t *__restrict__ output, cryptonight_ctx **__restrict__ ctx, uint64_t height)
+template<bool SOFT_AES>
+inline void cryptonight_double_hash(const uint8_t *__restrict__ input, size_t size, uint8_t *__restrict__ output, cryptonight_ctx **__restrict__ ctx, uint64_t height, uint64_t extra_iters)
 {
-    constexpr CnAlgo<ALGO> props;
+    constexpr CnAlgo props;
     constexpr size_t MASK        = props.mask();
-    constexpr Algorithm::Id BASE = props.base();
-
-#   ifdef XMRIG_ALGO_CN_HEAVY
-    constexpr bool IS_CN_HEAVY_TUBE = ALGO == Algorithm::CN_HEAVY_TUBE;
-#   else
-    constexpr bool IS_CN_HEAVY_TUBE = false;
-#   endif
 
-    if (BASE == Algorithm::CN_1 && size < 43) {
-        memset(output, 0, 64);
-        return;
-    }
+    uint32_t iters = (props.iterations() + extra_iters) >> 1;
 
     keccak(input,        size, ctx[0]->state);
     keccak(input + size, size, ctx[1]->state);
@@ -1002,16 +555,12 @@ inline void cryptonight_double_hash(const uint8_t *__restrict__ input, size_t si
     uint64_t *h0 = reinterpret_cast<uint64_t*>(ctx[0]->state);
     uint64_t *h1 = reinterpret_cast<uint64_t*>(ctx[1]->state);
 
-    VARIANT1_INIT(0);
-    VARIANT1_INIT(1);
     VARIANT2_INIT(0);
     VARIANT2_INIT(1);
     VARIANT2_SET_ROUNDING_MODE();
-    VARIANT4_RANDOM_MATH_INIT(0);
-    VARIANT4_RANDOM_MATH_INIT(1);
 
-    cn_explode_scratchpad<ALGO, SOFT_AES>(reinterpret_cast<const __m128i *>(h0), reinterpret_cast<__m128i *>(l0));
-    cn_explode_scratchpad<ALGO, SOFT_AES>(reinterpret_cast<const __m128i *>(h1), reinterpret_cast<__m128i *>(l1));
+    cn_explode_scratchpad<SOFT_AES>(reinterpret_cast<const __m128i *>(h0), reinterpret_cast<__m128i *>(l0));
+    cn_explode_scratchpad<SOFT_AES>(reinterpret_cast<const __m128i *>(h1), reinterpret_cast<__m128i *>(l1));
 
     uint64_t al0 = h0[0] ^ h0[4];
     uint64_t al1 = h1[0] ^ h1[4];
@@ -1026,20 +575,16 @@ inline void cryptonight_double_hash(const uint8_t *__restrict__ input, size_t si
     uint64_t idx0 = al0;
     uint64_t idx1 = al1;
 
-    for (size_t i = 0; i < props.iterations(); i++) {
+    for (size_t i = 0; i < iters; i++) {
         __m128i cx0, cx1;
-        if (IS_CN_HEAVY_TUBE || !SOFT_AES) {
+        if (!SOFT_AES) {
             cx0 = _mm_load_si128(reinterpret_cast<const __m128i *>(&l0[idx0 & MASK]));
             cx1 = _mm_load_si128(reinterpret_cast<const __m128i *>(&l1[idx1 & MASK]));
         }
 
         const __m128i ax0 = _mm_set_epi64x(ah0, al0);
         const __m128i ax1 = _mm_set_epi64x(ah1, al1);
-        if (IS_CN_HEAVY_TUBE) {
-            cx0 = aes_round_tweak_div(cx0, ax0);
-            cx1 = aes_round_tweak_div(cx1, ax1);
-        }
-        else if (SOFT_AES) {
+        if (SOFT_AES) {
             cx0 = soft_aesenc(&l0[idx0 & MASK], ax0, reinterpret_cast<const uint32_t*>(saes_table));
             cx1 = soft_aesenc(&l1[idx1 & MASK], ax1, reinterpret_cast<const uint32_t*>(saes_table));
         }
@@ -1048,13 +593,8 @@ inline void cryptonight_double_hash(const uint8_t *__restrict__ input, size_t si
             cx1 = _mm_aesenc_si128(cx1, ax1);
         }
 
-        if (BASE == Algorithm::CN_1 || BASE == Algorithm::CN_2) {
-            cryptonight_monero_tweak<ALGO>((uint64_t*)&l0[idx0 & MASK], l0, idx0 & MASK, ax0, bx00, bx01, cx0);
-            cryptonight_monero_tweak<ALGO>((uint64_t*)&l1[idx1 & MASK], l1, idx1 & MASK, ax1, bx10, bx11, cx1);
-        } else {
-            _mm_store_si128((__m128i *) &l0[idx0 & MASK], _mm_xor_si128(bx00, cx0));
-            _mm_store_si128((__m128i *) &l1[idx1 & MASK], _mm_xor_si128(bx10, cx1));
-        }
+        cryptonight_monero_tweak((uint64_t*)&l0[idx0 & MASK], l0, idx0 & MASK, ax0, bx00, bx01, cx0);
+        cryptonight_monero_tweak((uint64_t*)&l1[idx1 & MASK], l1, idx1 & MASK, ax1, bx10, bx11, cx1);
 
         idx0 = _mm_cvtsi128_si64(cx0);
         idx1 = _mm_cvtsi128_si64(cx1);
@@ -1063,130 +603,50 @@ inline void cryptonight_double_hash(const uint8_t *__restrict__ input, size_t si
         cl = ((uint64_t*) &l0[idx0 & MASK])[0];
         ch = ((uint64_t*) &l0[idx0 & MASK])[1];
 
-        if (BASE == Algorithm::CN_2) {
-            if (props.isR()) {
-                VARIANT4_RANDOM_MATH(0, al0, ah0, cl, bx00, bx01);
-                if (ALGO == Algorithm::CN_R) {
-                    al0 ^= r0[2] | ((uint64_t)(r0[3]) << 32);
-                    ah0 ^= r0[0] | ((uint64_t)(r0[1]) << 32);
-                }
-            } else {
-                VARIANT2_INTEGER_MATH(0, cl, cx0);
-            }
-        }
+        VARIANT2_INTEGER_MATH(0, cl, cx0);
 
         lo = __umul128(idx0, cl, &hi);
 
-        if (BASE == Algorithm::CN_2) {
-            if (ALGO == Algorithm::CN_R) {
-                VARIANT2_SHUFFLE(l0, idx0 & MASK, ax0, bx00, bx01, cx0, 0);
-            } else {
-                VARIANT2_SHUFFLE2(l0, idx0 & MASK, ax0, bx00, bx01, hi, lo, (ALGO == Algorithm::CN_RWZ ? 1 : 0));
-            }
-        }
+        VARIANT2_SHUFFLE2(l0, idx0 & MASK, ax0, bx00, bx01, hi, lo, 0);
 
         al0 += hi;
         ah0 += lo;
 
         ((uint64_t*)&l0[idx0 & MASK])[0] = al0;
-
-        if (IS_CN_HEAVY_TUBE || ALGO == Algorithm::CN_RTO) {
-            ((uint64_t*) &l0[idx0 & MASK])[1] = ah0 ^ tweak1_2_0 ^ al0;
-        } else if (BASE == Algorithm::CN_1) {
-            ((uint64_t*) &l0[idx0 & MASK])[1] = ah0 ^ tweak1_2_0;
-        } else {
-            ((uint64_t*) &l0[idx0 & MASK])[1] = ah0;
-        }
+        ((uint64_t*) &l0[idx0 & MASK])[1] = ah0;
 
         al0 ^= cl;
         ah0 ^= ch;
         idx0 = al0;
 
-#       ifdef XMRIG_ALGO_CN_HEAVY
-        if (props.isHeavy()) {
-            int64_t n = ((int64_t*)&l0[idx0 & MASK])[0];
-            int32_t d = ((int32_t*)&l0[idx0 & MASK])[2];
-            int64_t q = n / (d | 0x5);
-
-            ((int64_t*)&l0[idx0 & MASK])[0] = n ^ q;
-
-            if (ALGO == Algorithm::CN_HEAVY_XHV) {
-                d = ~d;
-            }
-
-            idx0 = d ^ q;
-        }
-#       endif
-
         cl = ((uint64_t*) &l1[idx1 & MASK])[0];
         ch = ((uint64_t*) &l1[idx1 & MASK])[1];
 
-        if (BASE == Algorithm::CN_2) {
-            if (props.isR()) {
-                VARIANT4_RANDOM_MATH(1, al1, ah1, cl, bx10, bx11);
-                if (ALGO == Algorithm::CN_R) {
-                    al1 ^= r1[2] | ((uint64_t)(r1[3]) << 32);
-                    ah1 ^= r1[0] | ((uint64_t)(r1[1]) << 32);
-                }
-            } else {
-                VARIANT2_INTEGER_MATH(1, cl, cx1);
-            }
-        }
+        VARIANT2_INTEGER_MATH(1, cl, cx1);
 
         lo = __umul128(idx1, cl, &hi);
 
-        if (BASE == Algorithm::CN_2) {
-            if (ALGO == Algorithm::CN_R) {
-                VARIANT2_SHUFFLE(l1, idx1 & MASK, ax1, bx10, bx11, cx1, 0);
-            } else {
-                VARIANT2_SHUFFLE2(l1, idx1 & MASK, ax1, bx10, bx11, hi, lo, (ALGO == Algorithm::CN_RWZ ? 1 : 0));
-            }
-        }
+        VARIANT2_SHUFFLE2(l1, idx1 & MASK, ax1, bx10, bx11, hi, lo, 0);
 
         al1 += hi;
         ah1 += lo;
 
         ((uint64_t*)&l1[idx1 & MASK])[0] = al1;
-
-        if (IS_CN_HEAVY_TUBE || ALGO == Algorithm::CN_RTO) {
-            ((uint64_t*)&l1[idx1 & MASK])[1] = ah1 ^ tweak1_2_1 ^ al1;
-        } else if (BASE == Algorithm::CN_1) {
-            ((uint64_t*)&l1[idx1 & MASK])[1] = ah1 ^ tweak1_2_1;
-        } else {
-            ((uint64_t*)&l1[idx1 & MASK])[1] = ah1;
-        }
+        ((uint64_t*)&l1[idx1 & MASK])[1] = ah1;
 
         al1 ^= cl;
         ah1 ^= ch;
         idx1 = al1;
 
-#       ifdef XMRIG_ALGO_CN_HEAVY
-        if (props.isHeavy()) {
-            int64_t n = ((int64_t*)&l1[idx1 & MASK])[0];
-            int32_t d = ((int32_t*)&l1[idx1 & MASK])[2];
-            int64_t q = n / (d | 0x5);
-
-            ((int64_t*)&l1[idx1 & MASK])[0] = n ^ q;
-
-            if (ALGO == Algorithm::CN_HEAVY_XHV) {
-                d = ~d;
-            }
-
-            idx1 = d ^ q;
-        }
-#       endif
-
-        if (BASE == Algorithm::CN_2) {
-            bx01 = bx00;
-            bx11 = bx10;
-        }
+        bx01 = bx00;
+        bx11 = bx10;
 
         bx00 = cx0;
         bx10 = cx1;
     }
 
-    cn_implode_scratchpad<ALGO, SOFT_AES>(reinterpret_cast<const __m128i *>(l0), reinterpret_cast<__m128i *>(h0));
-    cn_implode_scratchpad<ALGO, SOFT_AES>(reinterpret_cast<const __m128i *>(l1), reinterpret_cast<__m128i *>(h1));
+    cn_implode_scratchpad<SOFT_AES>(reinterpret_cast<const __m128i *>(l0), reinterpret_cast<__m128i *>(h0));
+    cn_implode_scratchpad<SOFT_AES>(reinterpret_cast<const __m128i *>(l1), reinterpret_cast<__m128i *>(h1));
 
     keccakf(h0, 24);
     keccakf(h1, 24);
@@ -1202,20 +662,12 @@ inline void cryptonight_double_hash(const uint8_t *__restrict__ input, size_t si
 
 
 #define CN_STEP2(a, b0, b1, c, l, ptr, idx)                                             \
-    if (IS_CN_HEAVY_TUBE) {                                                             \
-        c = aes_round_tweak_div(c, a);                                                  \
-    }                                                                                   \
-    else if (SOFT_AES) {                                                                \
+    if (SOFT_AES) {                                                                \
         c = soft_aesenc(&c, a, (const uint32_t*)saes_table);                            \
     } else {                                                                            \
         c = _mm_aesenc_si128(c, a);                                                     \
     }                                                                                   \
-                                                                                        \
-    if (BASE == Algorithm::CN_1 || BASE == Algorithm::CN_2) {                           \
-        cryptonight_monero_tweak<ALGO>((uint64_t*)ptr, l, idx & MASK, a, b0, b1, c);    \
-    } else {                                                                            \
-        _mm_store_si128(ptr, _mm_xor_si128(b0, c));                                     \
-    }
+    cryptonight_monero_tweak((uint64_t*)ptr, l, idx & MASK, a, b0, b1, c);
 
 
 #define CN_STEP3(part, a, b0, b1, c, l, ptr, idx)     \
@@ -1226,104 +678,41 @@ inline void cryptonight_double_hash(const uint8_t *__restrict__ input, size_t si
 
 
 #define CN_STEP4(part, a, b0, b1, c, l, mc, ptr, idx)                                                       \
-    uint64_t al##part, ah##part;                                                                            \
-    if (BASE == Algorithm::CN_2) {                                                                          \
-        if (props.isR()) {                                                                                  \
-            al##part = _mm_cvtsi128_si64(a);                                                                \
-            ah##part = _mm_cvtsi128_si64(_mm_srli_si128(a, 8));                                             \
-            VARIANT4_RANDOM_MATH(part, al##part, ah##part, cl##part, b0, b1);                               \
-            if (ALGO == Algorithm::CN_R) {                                                                  \
-                al##part ^= r##part[2] | ((uint64_t)(r##part[3]) << 32);                                    \
-                ah##part ^= r##part[0] | ((uint64_t)(r##part[1]) << 32);                                    \
-            }                                                                                               \
-        } else {                                                                                            \
-            VARIANT2_INTEGER_MATH(part, cl##part, c);                                                       \
-        }                                                                                                   \
-    }                                                                                                       \
+    VARIANT2_INTEGER_MATH(part, cl##part, c);                                                           \
     lo = __umul128(idx, cl##part, &hi);                                                                     \
-    if (BASE == Algorithm::CN_2) {                                                                          \
-        if (ALGO == Algorithm::CN_R) {                                                                      \
-            VARIANT2_SHUFFLE(l, idx & MASK, a, b0, b1, c, 0);                                               \
-        } else {                                                                                            \
-            VARIANT2_SHUFFLE2(l, idx & MASK, a, b0, b1, hi, lo, (ALGO == Algorithm::CN_RWZ ? 1 : 0));       \
-        }                                                                                                   \
-    }                                                                                                       \
-    if (ALGO == Algorithm::CN_R) {                                                                          \
-        a = _mm_set_epi64x(ah##part, al##part);                                                             \
-    }                                                                                                       \
+    VARIANT2_SHUFFLE2(l, idx & MASK, a, b0, b1, hi, lo, 0);           \
     a = _mm_add_epi64(a, _mm_set_epi64x(lo, hi));                                                           \
                                                                                                             \
-    if (BASE == Algorithm::CN_1) {                                                                          \
-        _mm_store_si128(ptr, _mm_xor_si128(a, mc));                                                         \
-                                                                                                            \
-        if (IS_CN_HEAVY_TUBE || ALGO == Algorithm::CN_RTO) {                                                \
-            ((uint64_t*)ptr)[1] ^= ((uint64_t*)ptr)[0];                                                     \
-        }                                                                                                   \
-    } else {                                                                                                \
-        _mm_store_si128(ptr, a);                                                                            \
-    }                                                                                                       \
+    _mm_store_si128(ptr, a);                                                                            \
                                                                                                             \
     a = _mm_xor_si128(a, _mm_set_epi64x(ch##part, cl##part));                                               \
     idx = _mm_cvtsi128_si64(a);                                                                             \
-    if (props.isHeavy()) {                                                                                  \
-        int64_t n = ((int64_t*)&l[idx & MASK])[0];                                                          \
-        int32_t d = ((int32_t*)&l[idx & MASK])[2];                                                          \
-        int64_t q = n / (d | 0x5);                                                                          \
-        ((int64_t*)&l[idx & MASK])[0] = n ^ q;                                                              \
-        if (IS_CN_HEAVY_XHV) {                                                                              \
-            d = ~d;                                                                                         \
-        }                                                                                                   \
-                                                                                                            \
-        idx = d ^ q;                                                                                        \
-    }                                                                                                       \
-    if (BASE == Algorithm::CN_2) {                                                                          \
-        b1 = b0;                                                                                            \
-    }                                                                                                       \
+    b1 = b0;                                                                                            \
     b0 = c;
 
 
 #define CONST_INIT(ctx, n)                                                                       \
-    __m128i mc##n;                                                                               \
     __m128i division_result_xmm_##n;                                                             \
     __m128i sqrt_result_xmm_##n;                                                                 \
-    if (BASE == Algorithm::CN_1) {                                                               \
-        mc##n = _mm_set_epi64x(*reinterpret_cast<const uint64_t*>(input + n * size + 35) ^       \
-                               *(reinterpret_cast<const uint64_t*>((ctx)->state) + 24), 0);      \
-    }                                                                                            \
-    if (BASE == Algorithm::CN_2) {                                                               \
-        division_result_xmm_##n = _mm_cvtsi64_si128(h##n[12]);                                   \
-        sqrt_result_xmm_##n = _mm_cvtsi64_si128(h##n[13]);                                       \
-    }                                                                                            \
+    division_result_xmm_##n = _mm_cvtsi64_si128(h##n[12]);                                   \
+    sqrt_result_xmm_##n = _mm_cvtsi64_si128(h##n[13]);                                       \
     __m128i ax##n = _mm_set_epi64x(h##n[1] ^ h##n[5], h##n[0] ^ h##n[4]);                        \
     __m128i bx##n##0 = _mm_set_epi64x(h##n[3] ^ h##n[7], h##n[2] ^ h##n[6]);                     \
     __m128i bx##n##1 = _mm_set_epi64x(h##n[9] ^ h##n[11], h##n[8] ^ h##n[10]);                   \
-    __m128i cx##n = _mm_setzero_si128();                                                         \
-    VARIANT4_RANDOM_MATH_INIT(n);
+    __m128i cx##n = _mm_setzero_si128();
 
 
-template<Algorithm::Id ALGO, bool SOFT_AES>
-inline void cryptonight_triple_hash(const uint8_t *__restrict__ input, size_t size, uint8_t *__restrict__ output, cryptonight_ctx **__restrict__ ctx, uint64_t height)
+template<bool SOFT_AES>
+inline void cryptonight_triple_hash(const uint8_t *__restrict__ input, size_t size, uint8_t *__restrict__ output, cryptonight_ctx **__restrict__ ctx, uint64_t height, uint64_t extra_iters)
 {
-    constexpr CnAlgo<ALGO> props;
+    constexpr CnAlgo props;
     constexpr size_t MASK        = props.mask();
-    constexpr Algorithm::Id BASE = props.base();
 
-#   ifdef XMRIG_ALGO_CN_HEAVY
-    constexpr bool IS_CN_HEAVY_TUBE = ALGO == Algorithm::CN_HEAVY_TUBE;
-    constexpr bool IS_CN_HEAVY_XHV  = ALGO == Algorithm::CN_HEAVY_XHV;
-#   else
-    constexpr bool IS_CN_HEAVY_TUBE = false;
-    constexpr bool IS_CN_HEAVY_XHV  = false;
-#   endif
-
-    if (BASE == Algorithm::CN_1 && size < 43) {
-        memset(output, 0, 32 * 3);
-        return;
-    }
+    uint32_t iters = (props.iterations() + extra_iters) >> 1;
 
     for (size_t i = 0; i < 3; i++) {
         keccak(input + size * i, size, ctx[i]->state);
-        cn_explode_scratchpad<ALGO, SOFT_AES>(reinterpret_cast<const __m128i*>(ctx[i]->state), reinterpret_cast<__m128i*>(ctx[i]->memory));
+        cn_explode_scratchpad<SOFT_AES>(reinterpret_cast<const __m128i*>(ctx[i]->state), reinterpret_cast<__m128i*>(ctx[i]->memory));
     }
 
     uint8_t* l0  = ctx[0]->memory;
@@ -1343,7 +732,7 @@ inline void cryptonight_triple_hash(const uint8_t *__restrict__ input, size_t si
     idx1 = _mm_cvtsi128_si64(ax1);
     idx2 = _mm_cvtsi128_si64(ax2);
 
-    for (size_t i = 0; i < props.iterations(); i++) {
+    for (size_t i = 0; i < iters; i++) {
         uint64_t hi, lo;
         __m128i *ptr0, *ptr1, *ptr2;
 
@@ -1365,36 +754,24 @@ inline void cryptonight_triple_hash(const uint8_t *__restrict__ input, size_t si
     }
 
     for (size_t i = 0; i < 3; i++) {
-        cn_implode_scratchpad<ALGO, SOFT_AES>(reinterpret_cast<const __m128i*>(ctx[i]->memory), reinterpret_cast<__m128i*>(ctx[i]->state));
+        cn_implode_scratchpad<SOFT_AES>(reinterpret_cast<const __m128i*>(ctx[i]->memory), reinterpret_cast<__m128i*>(ctx[i]->state));
         keccakf(reinterpret_cast<uint64_t*>(ctx[i]->state), 24);
         extra_hashes[ctx[i]->state[0] & 3](ctx[i]->state, 200, output + 32 * i);
     }
 }
 
 
-template<Algorithm::Id ALGO, bool SOFT_AES>
-inline void cryptonight_quad_hash(const uint8_t *__restrict__ input, size_t size, uint8_t *__restrict__ output, cryptonight_ctx **__restrict__ ctx, uint64_t height)
+template<bool SOFT_AES>
+inline void cryptonight_quad_hash(const uint8_t *__restrict__ input, size_t size, uint8_t *__restrict__ output, cryptonight_ctx **__restrict__ ctx, uint64_t height, uint64_t extra_iters)
 {
-    constexpr CnAlgo<ALGO> props;
+    constexpr CnAlgo props;
     constexpr size_t MASK        = props.mask();
-    constexpr Algorithm::Id BASE = props.base();
-
-#   ifdef XMRIG_ALGO_CN_HEAVY
-    constexpr bool IS_CN_HEAVY_TUBE = ALGO == Algorithm::CN_HEAVY_TUBE;
-    constexpr bool IS_CN_HEAVY_XHV  = ALGO == Algorithm::CN_HEAVY_XHV;
-#   else
-    constexpr bool IS_CN_HEAVY_TUBE = false;
-    constexpr bool IS_CN_HEAVY_XHV  = false;
-#   endif
 
-    if (BASE == Algorithm::CN_1 && size < 43) {
-        memset(output, 0, 32 * 4);
-        return;
-    }
+    uint32_t iters = (props.iterations() + extra_iters) >> 1;
 
     for (size_t i = 0; i < 4; i++) {
         keccak(input + size * i, size, ctx[i]->state);
-        cn_explode_scratchpad<ALGO, SOFT_AES>(reinterpret_cast<const __m128i*>(ctx[i]->state), reinterpret_cast<__m128i*>(ctx[i]->memory));
+        cn_explode_scratchpad<SOFT_AES>(reinterpret_cast<const __m128i*>(ctx[i]->state), reinterpret_cast<__m128i*>(ctx[i]->memory));
     }
 
     uint8_t* l0  = ctx[0]->memory;
@@ -1418,7 +795,7 @@ inline void cryptonight_quad_hash(const uint8_t *__restrict__ input, size_t size
     idx2 = _mm_cvtsi128_si64(ax2);
     idx3 = _mm_cvtsi128_si64(ax3);
 
-    for (size_t i = 0; i < props.iterations(); i++) {
+    for (size_t i = 0; i < iters; i++) {
         uint64_t hi, lo;
         __m128i *ptr0, *ptr1, *ptr2, *ptr3;
 
@@ -1444,36 +821,24 @@ inline void cryptonight_quad_hash(const uint8_t *__restrict__ input, size_t size
     }
 
     for (size_t i = 0; i < 4; i++) {
-        cn_implode_scratchpad<ALGO, SOFT_AES>(reinterpret_cast<const __m128i*>(ctx[i]->memory), reinterpret_cast<__m128i*>(ctx[i]->state));
+        cn_implode_scratchpad<SOFT_AES>(reinterpret_cast<const __m128i*>(ctx[i]->memory), reinterpret_cast<__m128i*>(ctx[i]->state));
         keccakf(reinterpret_cast<uint64_t*>(ctx[i]->state), 24);
         extra_hashes[ctx[i]->state[0] & 3](ctx[i]->state, 200, output + 32 * i);
     }
 }
 
 
-template<Algorithm::Id ALGO, bool SOFT_AES>
-inline void cryptonight_penta_hash(const uint8_t *__restrict__ input, size_t size, uint8_t *__restrict__ output, cryptonight_ctx **__restrict__ ctx, uint64_t height)
+template<bool SOFT_AES>
+inline void cryptonight_penta_hash(const uint8_t *__restrict__ input, size_t size, uint8_t *__restrict__ output, cryptonight_ctx **__restrict__ ctx, uint64_t height, uint64_t extra_iters)
 {
-    constexpr CnAlgo<ALGO> props;
+    constexpr CnAlgo props;
     constexpr size_t MASK        = props.mask();
-    constexpr Algorithm::Id BASE = props.base();
 
-#   ifdef XMRIG_ALGO_CN_HEAVY
-    constexpr bool IS_CN_HEAVY_TUBE = ALGO == Algorithm::CN_HEAVY_TUBE;
-    constexpr bool IS_CN_HEAVY_XHV  = ALGO == Algorithm::CN_HEAVY_XHV;
-#   else
-    constexpr bool IS_CN_HEAVY_TUBE = false;
-    constexpr bool IS_CN_HEAVY_XHV  = false;
-#   endif
-
-    if (BASE == Algorithm::CN_1 && size < 43) {
-        memset(output, 0, 32 * 5);
-        return;
-    }
+    uint32_t iters = (props.iterations() + extra_iters) >> 1;
 
     for (size_t i = 0; i < 5; i++) {
         keccak(input + size * i, size, ctx[i]->state);
-        cn_explode_scratchpad<ALGO, SOFT_AES>(reinterpret_cast<const __m128i*>(ctx[i]->state), reinterpret_cast<__m128i*>(ctx[i]->memory));
+        cn_explode_scratchpad<SOFT_AES>(reinterpret_cast<const __m128i*>(ctx[i]->state), reinterpret_cast<__m128i*>(ctx[i]->memory));
     }
 
     uint8_t* l0  = ctx[0]->memory;
@@ -1501,7 +866,7 @@ inline void cryptonight_penta_hash(const uint8_t *__restrict__ input, size_t siz
     idx3 = _mm_cvtsi128_si64(ax3);
     idx4 = _mm_cvtsi128_si64(ax4);
 
-    for (size_t i = 0; i < props.iterations(); i++) {
+    for (size_t i = 0; i < iters; i++) {
         uint64_t hi, lo;
         __m128i *ptr0, *ptr1, *ptr2, *ptr3, *ptr4;
 
@@ -1531,7 +896,7 @@ inline void cryptonight_penta_hash(const uint8_t *__restrict__ input, size_t siz
     }
 
     for (size_t i = 0; i < 5; i++) {
-        cn_implode_scratchpad<ALGO, SOFT_AES>(reinterpret_cast<const __m128i*>(ctx[i]->memory), reinterpret_cast<__m128i*>(ctx[i]->state));
+        cn_implode_scratchpad<SOFT_AES>(reinterpret_cast<const __m128i*>(ctx[i]->memory), reinterpret_cast<__m128i*>(ctx[i]->state));
         keccakf(reinterpret_cast<uint64_t*>(ctx[i]->state), 24);
         extra_hashes[ctx[i]->state[0] & 3](ctx[i]->state, 200, output + 32 * i);
     }
diff --git a/src/crypto/cn/soft_aes.h b/src/crypto/cn/soft_aes.h
index fca31d1..2b9b294 100644
--- a/src/crypto/cn/soft_aes.h
+++ b/src/crypto/cn/soft_aes.h
@@ -27,9 +27,7 @@
 #pragma once
 
 
-#if defined(XMRIG_ARM)
-#   include "crypto/cn/SSE2NEON.h"
-#elif defined(__GNUC__)
+#if defined(__GNUC__)
 #   include <x86intrin.h>
 #else
 #   include <intrin.h>
diff --git a/src/crypto/common/Algorithm.cpp b/src/crypto/common/Algorithm.cpp
index bf04911..66bd31a 100644
--- a/src/crypto/common/Algorithm.cpp
+++ b/src/crypto/common/Algorithm.cpp
@@ -41,275 +41,20 @@
 #   define strcasecmp  _stricmp
 #endif
 
-
-namespace xmrig {
-
-
-struct AlgoName
-{
-    const char *name;
-    const char *shortName;
-    const Algorithm::Id id;
-};
-
-
-static AlgoName const algorithm_names[] = {
-    { "cryptonight/0",             "cn/0",             Algorithm::CN_0            },
-    { "cryptonight",               "cn",               Algorithm::CN_0            },
-    { "cryptonight/1",             "cn/1",             Algorithm::CN_1            },
-    { "cryptonight-monerov7",      nullptr,            Algorithm::CN_1            },
-    { "cryptonight_v7",            nullptr,            Algorithm::CN_1            },
-    { "cryptonight/2",             "cn/2",             Algorithm::CN_2            },
-    { "cryptonight-monerov8",      nullptr,            Algorithm::CN_2            },
-    { "cryptonight_v8",            nullptr,            Algorithm::CN_2            },
-    { "cryptonight/r",             "cn/r",             Algorithm::CN_R            },
-    { "cryptonight_r",             nullptr,            Algorithm::CN_R            },
-    { "cryptonight/fast",          "cn/fast",          Algorithm::CN_FAST         },
-    { "cryptonight/msr",           "cn/msr",           Algorithm::CN_FAST         },
-    { "cryptonight/half",          "cn/half",          Algorithm::CN_HALF         },
-    { "cryptonight/xao",           "cn/xao",           Algorithm::CN_XAO          },
-    { "cryptonight_alloy",         nullptr,            Algorithm::CN_XAO          },
-    { "cryptonight/rto",           "cn/rto",           Algorithm::CN_RTO          },
-    { "cryptonight/rwz",           "cn/rwz",           Algorithm::CN_RWZ          },
-    { "cryptonight/zls",           "cn/zls",           Algorithm::CN_ZLS          },
-    { "cryptonight/double",        "cn/double",        Algorithm::CN_DOUBLE       },
-#   ifdef XMRIG_ALGO_CN_GPU
-    { "cryptonight/gpu",           "cn/gpu",           Algorithm::CN_GPU          },
-    { "cryptonight_gpu",           nullptr,            Algorithm::CN_GPU          },
-#   endif
-#   ifdef XMRIG_ALGO_CN_LITE
-    { "cryptonight-lite/0",        "cn-lite/0",        Algorithm::CN_LITE_0       },
-    { "cryptonight-lite/1",        "cn-lite/1",        Algorithm::CN_LITE_1       },
-    { "cryptonight-lite",          "cn-lite",          Algorithm::CN_LITE_1       },
-    { "cryptonight-light",         "cn-light",         Algorithm::CN_LITE_1       },
-    { "cryptonight_lite",          nullptr,            Algorithm::CN_LITE_1       },
-    { "cryptonight-aeonv7",        nullptr,            Algorithm::CN_LITE_1       },
-    { "cryptonight_lite_v7",       nullptr,            Algorithm::CN_LITE_1       },
-#   endif
-#   ifdef XMRIG_ALGO_CN_HEAVY
-    { "cryptonight-heavy/0",       "cn-heavy/0",       Algorithm::CN_HEAVY_0      },
-    { "cryptonight-heavy",         "cn-heavy",         Algorithm::CN_HEAVY_0      },
-    { "cryptonight_heavy",         nullptr,            Algorithm::CN_HEAVY_0      },
-    { "cryptonight-heavy/xhv",     "cn-heavy/xhv",     Algorithm::CN_HEAVY_XHV    },
-    { "cryptonight_haven",         nullptr,            Algorithm::CN_HEAVY_XHV    },
-    { "cryptonight-heavy/tube",    "cn-heavy/tube",    Algorithm::CN_HEAVY_TUBE   },
-    { "cryptonight-bittube2",      nullptr,            Algorithm::CN_HEAVY_TUBE   },
-#   endif
-#   ifdef XMRIG_ALGO_CN_PICO
-    { "cryptonight-pico",          "cn-pico",          Algorithm::CN_PICO_0       },
-    { "cryptonight-pico/trtl",     "cn-pico/trtl",     Algorithm::CN_PICO_0       },
-    { "cryptonight-turtle",        "cn-trtl",          Algorithm::CN_PICO_0       },
-    { "cryptonight-ultralite",     "cn-ultralite",     Algorithm::CN_PICO_0       },
-    { "cryptonight_turtle",        "cn_turtle",        Algorithm::CN_PICO_0       },
-#   endif
-#   ifdef XMRIG_ALGO_RANDOMX
-    { "randomx/0",                 "rx/0",             Algorithm::RX_0            },
-    { "randomx/test",              "rx/test",          Algorithm::RX_0            },
-    { "RandomX",                   "rx",               Algorithm::RX_0            },
-    { "randomx/wow",               "rx/wow",           Algorithm::RX_WOW          },
-    { "RandomWOW",                 nullptr,            Algorithm::RX_WOW          },
-    { "randomx/loki",              "rx/loki",          Algorithm::RX_LOKI         },
-    { "RandomXL",                  nullptr,            Algorithm::RX_LOKI         },
-    { "randomx/arq",               "rx/arq",           Algorithm::RX_ARQ          },
-    { "RandomARQ",                 nullptr,            Algorithm::RX_ARQ          },
-#   endif
-#   ifdef XMRIG_ALGO_ARGON2
-    { "argon2/chukwa",             nullptr,            Algorithm::AR2_CHUKWA      },
-    { "chukwa",                    nullptr,            Algorithm::AR2_CHUKWA      },
-    { "argon2/wrkz",               nullptr,            Algorithm::AR2_WRKZ        },
-#   endif
-};
-
-
-} /* namespace xmrig */
-
-
 rapidjson::Value xmrig::Algorithm::toJSON() const
 {
     using namespace rapidjson;
-
-    return isValid() ? Value(StringRef(shortName())) : Value(kNullType);
-}
-
-
-size_t xmrig::Algorithm::l2() const
-{
-#   ifdef XMRIG_ALGO_RANDOMX
-    switch (m_id) {
-    case RX_0:
-    case RX_LOKI:
-        return 0x40000;
-
-    case RX_WOW:
-        return 0x20000;
-
-    case RX_ARQ:
-        return 0x10000;
-
-    default:
-        break;
-    }
-#   endif
-
-    return 0;
+    return Value(StringRef("cn/blur"));
 }
 
-
 size_t xmrig::Algorithm::l3() const
 {
-    constexpr size_t oneMiB = 0x100000;
-
-    const Family f = family();
-    assert(f != UNKNOWN);
-
-    if (f < RANDOM_X) {
-        return CnAlgo<>::memory(m_id);
-    }
-
-#   ifdef XMRIG_ALGO_RANDOMX
-    if (f == RANDOM_X) {
-        switch (m_id) {
-        case RX_0:
-        case RX_LOKI:
-            return oneMiB * 2;
-
-        case RX_WOW:
-            return oneMiB;
-
-        case RX_ARQ:
-            return oneMiB / 4;
-
-        default:
-            break;
-        }
-    }
-#   endif
-
-#   ifdef XMRIG_ALGO_ARGON2
-    if (f == ARGON2) {
-        switch (m_id) {
-        case AR2_CHUKWA:
-            return oneMiB / 2;
-
-        case AR2_WRKZ:
-            return oneMiB / 4;
-
-        default:
-            break;
-        }
-    }
-#   endif
-
-    return 0;
+    return CnAlgo::CN_MEMORY;
 }
 
-
 uint32_t xmrig::Algorithm::maxIntensity() const
 {
-#   ifdef XMRIG_ALGO_RANDOMX
-    if (family() == RANDOM_X) {
-        return 1;
-    }
-#   endif
-
-#   ifdef XMRIG_ALGO_ARGON2
-    if (family() == ARGON2) {
-        return 1;
-    }
-#   endif
-
-#   ifdef XMRIG_ALGO_CN_GPU
-    if (m_id == CN_GPU) {
-        return 1;
-    }
-#   endif
-
     return 5;
 }
 
-
-xmrig::Algorithm::Family xmrig::Algorithm::family(Id id)
-{
-    switch (id) {
-    case CN_0:
-    case CN_1:
-    case CN_2:
-    case CN_R:
-    case CN_FAST:
-    case CN_HALF:
-    case CN_XAO:
-    case CN_RTO:
-    case CN_RWZ:
-    case CN_ZLS:
-    case CN_DOUBLE:
-#   ifdef XMRIG_ALGO_CN_GPU
-    case CN_GPU:
-#   endif
-        return CN;
-
-#   ifdef XMRIG_ALGO_CN_LITE
-    case CN_LITE_0:
-    case CN_LITE_1:
-        return CN_LITE;
-#   endif
-
-#   ifdef XMRIG_ALGO_CN_HEAVY
-    case CN_HEAVY_0:
-    case CN_HEAVY_TUBE:
-    case CN_HEAVY_XHV:
-        return CN_HEAVY;
-#   endif
-
-#   ifdef XMRIG_ALGO_CN_PICO
-    case CN_PICO_0:
-        return CN_PICO;
-#   endif
-
-#   ifdef XMRIG_ALGO_RANDOMX
-    case RX_0:
-    case RX_WOW:
-    case RX_LOKI:
-    case RX_ARQ:
-        return RANDOM_X;
-#   endif
-
-#   ifdef XMRIG_ALGO_ARGON2
-    case AR2_CHUKWA:
-    case AR2_WRKZ:
-        return ARGON2;
-#   endif
-
-    default:
-        break;
-    }
-
-    return UNKNOWN;
-}
-
-
-xmrig::Algorithm::Id xmrig::Algorithm::parse(const char *name)
-{
-    if (name == nullptr || strlen(name) < 1) {
-        return INVALID;
-    }
-
-    for (const AlgoName &item : algorithm_names) {
-        if ((strcasecmp(name, item.name) == 0) || (item.shortName != nullptr && strcasecmp(name, item.shortName) == 0)) {
-            return item.id;
-        }
-    }
-
-    return INVALID;
-}
-
-
-const char *xmrig::Algorithm::name(bool shortName) const
-{
-    for (const AlgoName &item : algorithm_names) {
-        if (item.id == m_id) {
-            return (shortName && item.shortName) ? item.shortName : item.name;
-        }
-    }
-
-    return "invalid";
-}
+xmrig::Algorithm::Id xmrig::Algorithm::parse() { return CN_BLUR; }
diff --git a/src/crypto/common/Algorithm.h b/src/crypto/common/Algorithm.h
index 0c6f264..8d3a02c 100644
--- a/src/crypto/common/Algorithm.h
+++ b/src/crypto/common/Algorithm.h
@@ -45,73 +45,32 @@ public:
     //
     enum Id : int {
         INVALID = -1,
-        CN_0,          // "cn/0"             CryptoNight (original).
-        CN_1,          // "cn/1"             CryptoNight variant 1 also known as Monero7 and CryptoNightV7.
-        CN_2,          // "cn/2"             CryptoNight variant 2.
-        CN_R,          // "cn/r"             CryptoNightR (Monero's variant 4).
-        CN_FAST,       // "cn/fast"          CryptoNight variant 1 with half iterations.
-        CN_HALF,       // "cn/half"          CryptoNight variant 2 with half iterations (Masari/Torque).
-        CN_XAO,        // "cn/xao"           CryptoNight variant 0 (modified, Alloy only).
-        CN_RTO,        // "cn/rto"           CryptoNight variant 1 (modified, Arto only).
-        CN_RWZ,        // "cn/rwz"           CryptoNight variant 2 with 3/4 iterations and reversed shuffle operation (Graft).
-        CN_ZLS,        // "cn/zls"           CryptoNight variant 2 with 3/4 iterations (Zelerius).
-        CN_DOUBLE,     // "cn/double"        CryptoNight variant 2 with double iterations (X-CASH).
-        CN_GPU,        // "cn/gpu"           CryptoNight-GPU (Ryo).
-        CN_LITE_0,     // "cn-lite/0"        CryptoNight-Lite variant 0.
-        CN_LITE_1,     // "cn-lite/1"        CryptoNight-Lite variant 1.
-        CN_HEAVY_0,    // "cn-heavy/0"       CryptoNight-Heavy (4 MB).
-        CN_HEAVY_TUBE, // "cn-heavy/tube"    CryptoNight-Heavy (modified, TUBE only).
-        CN_HEAVY_XHV,  // "cn-heavy/xhv"     CryptoNight-Heavy (modified, Haven Protocol only).
-        CN_PICO_0,     // "cn-pico"          CryptoNight Turtle (TRTL)
-        RX_0,          // "rx/0"             RandomX (reference configuration).
-        RX_WOW,        // "rx/wow"           RandomWOW (Wownero).
-        RX_LOKI,       // "rx/loki"          RandomXL (Loki).
-        RX_ARQ,        // "rx/arq"           RandomARQ (Arqma).
-        AR2_CHUKWA,    // "argon2/chukwa"    Argon2id (Chukwa).
-        AR2_WRKZ,      // "argon2/wrkz"      Argon2id (WRKZ)
+		CN_0,
+        CN_1,
+        CN_2,
+        CN_BLUR,
         MAX
     };
 
-    enum Family : int {
-        UNKNOWN,
-        CN,
-        CN_LITE,
-        CN_HEAVY,
-        CN_PICO,
-        RANDOM_X,
-        ARGON2
-    };
-
     inline Algorithm() = default;
-    inline Algorithm(const char *algo) : m_id(parse(algo)) {}
-    inline Algorithm(Id id) : m_id(id)                     {}
-
-    inline bool isCN() const                          { auto f = family(); return f == CN || f == CN_LITE || f == CN_HEAVY || f == CN_PICO; }
-    inline bool isEqual(const Algorithm &other) const { return m_id == other.m_id; }
-    inline bool isValid() const                       { return m_id != INVALID; }
-    inline const char *name() const                   { return name(false); }
-    inline const char *shortName() const              { return name(true); }
-    inline Family family() const                      { return family(m_id); }
+
+    inline const char *name() const                   { return "cn/blur"; }
     inline Id id() const                              { return m_id; }
 
     inline bool operator!=(Algorithm::Id id) const        { return m_id != id; }
-    inline bool operator!=(const Algorithm &other) const  { return !isEqual(other); }
+    inline bool operator!=(const Algorithm &other) const  { return m_id != other.m_id; }
     inline bool operator==(Algorithm::Id id) const        { return m_id == id; }
-    inline bool operator==(const Algorithm &other) const  { return isEqual(other); }
+    inline bool operator==(const Algorithm &other) const  { return m_id == other.m_id; }
     inline operator Algorithm::Id() const                 { return m_id; }
 
     rapidjson::Value toJSON() const;
-    size_t l2() const;
     size_t l3() const;
     uint32_t maxIntensity() const;
 
-    static Family family(Id id);
-    static Id parse(const char *name);
+    static Id parse();
 
 private:
-    const char *name(bool shortName) const;
-
-    Id m_id = INVALID;
+    Id m_id = CN_BLUR;
 };
 
 
diff --git a/src/crypto/common/Nonce.cpp b/src/crypto/common/Nonce.cpp
index 897045c..08d31ee 100644
--- a/src/crypto/common/Nonce.cpp
+++ b/src/crypto/common/Nonce.cpp
@@ -54,19 +54,13 @@ xmrig::Nonce::Nonce()
 }
 
 
-uint32_t xmrig::Nonce::next(uint8_t index, uint32_t nonce, uint32_t reserveCount, bool nicehash)
+uint32_t xmrig::Nonce::next(uint8_t index, uint32_t nonce, uint32_t reserveCount)
 {
     uint32_t next;
 
     std::lock_guard<std::mutex> lock(mutex);
 
-    if (nicehash) {
-        next = (nonce & 0xFF000000) | m_nonces[index];
-    }
-    else {
-        next = m_nonces[index];
-    }
-
+    next = m_nonces[index];
     m_nonces[index] += reserveCount;
 
     return next;
diff --git a/src/crypto/common/Nonce.h b/src/crypto/common/Nonce.h
index 7335663..c66114c 100644
--- a/src/crypto/common/Nonce.h
+++ b/src/crypto/common/Nonce.h
@@ -52,7 +52,7 @@ public:
     static inline void stop(Backend backend)                            { m_sequence[backend] = 0; }
     static inline void touch(Backend backend)                           { m_sequence[backend]++; }
 
-    static uint32_t next(uint8_t index, uint32_t nonce, uint32_t reserveCount, bool nicehash);
+    static uint32_t next(uint8_t index, uint32_t nonce, uint32_t reserveCount);
     static void reset(uint8_t index);
     static void stop();
     static void touch();
diff --git a/src/crypto/common/portable/mm_malloc.h b/src/crypto/common/portable/mm_malloc.h
index 34ca7d4..1ff77be 100644
--- a/src/crypto/common/portable/mm_malloc.h
+++ b/src/crypto/common/portable/mm_malloc.h
@@ -25,47 +25,10 @@
 #ifndef XMRIG_MM_MALLOC_PORTABLE_H
 #define XMRIG_MM_MALLOC_PORTABLE_H
 
-
-#if defined(XMRIG_ARM) && !defined(__clang__)
-#include <stdlib.h>
-
-
-#ifndef __cplusplus
-extern
-#else
-extern "C"
-#endif
-int posix_memalign(void **__memptr, size_t __alignment, size_t __size);
-
-
-static __inline__ void *__attribute__((__always_inline__, __malloc__)) _mm_malloc(size_t __size, size_t __align)
-{
-    if (__align == 1) {
-        return malloc(__size);
-    }
-
-    if (!(__align & (__align - 1)) && __align < sizeof(void *)) {
-        __align = sizeof(void *);
-    }
-
-    void *__mallocedMemory;
-    if (posix_memalign(&__mallocedMemory, __align, __size)) {
-        return nullptr;
-    }
-
-    return __mallocedMemory;
-}
-
-
-static __inline__ void __attribute__((__always_inline__)) _mm_free(void *__p)
-{
-    free(__p);
-}
-#elif defined(_WIN32) && !defined(__GNUC__)
+#if defined(_WIN32) && !defined(__GNUC__)
 #   include <malloc.h>
 #else
 #   include <mm_malloc.h>
 #endif
 
-
 #endif /* XMRIG_MM_MALLOC_PORTABLE_H */
diff --git a/src/net/JobResult.h b/src/net/JobResult.h
index a44a639..2404180 100644
--- a/src/net/JobResult.h
+++ b/src/net/JobResult.h
@@ -44,7 +44,6 @@ public:
     JobResult() = delete;
 
     inline JobResult(const Job &job, uint32_t nonce, const uint8_t *result) :
-        algorithm(job.algorithm()),
         clientId(job.clientId()),
         jobId(job.id()),
         backend(job.backend()),
@@ -59,7 +58,6 @@ public:
     inline uint64_t actualDiff() const      { return Job::toDiff(reinterpret_cast<const uint64_t*>(m_result)[3]); }
     inline uint8_t *result()                { return m_result; }
 
-    const Algorithm algorithm;
     const String clientId;
     const String jobId;
     const uint32_t backend;
diff --git a/src/net/JobResults.cpp b/src/net/JobResults.cpp
index e8b4adc..3f00adf 100644
--- a/src/net/JobResults.cpp
+++ b/src/net/JobResults.cpp
@@ -30,14 +30,7 @@
 #include "base/tools/Object.h"
 #include "net/interfaces/IJobResultListener.h"
 #include "net/JobResult.h"
-
-
-#ifdef XMRIG_ALGO_RANDOMX
-#   include "crypto/randomx/randomx.h"
-#   include "crypto/rx/Rx.h"
-#   include "crypto/rx/RxVm.h"
-#endif
-
+#include "backend/common/VarInt.h"
 
 #if defined(XMRIG_FEATURE_OPENCL) || defined(XMRIG_FEATURE_CUDA)
 #   include "base/tools/Baton.h"
@@ -45,6 +38,7 @@
 #   include "crypto/cn/CnHash.h"
 #   include "crypto/cn/CryptoNight.h"
 #   include "crypto/common/VirtualMemory.h"
+#   include "crypto/cn/CnAlgo.h"
 #endif
 
 
@@ -92,6 +86,7 @@ public:
 
 static inline void checkHash(const JobBundle &bundle, std::vector<JobResult> &results, uint32_t nonce, uint8_t hash[32], uint32_t &errors)
 {
+    
     if (*reinterpret_cast<uint64_t*>(hash + 24) < bundle.job.target()) {
         results.emplace_back(bundle.job, nonce, hash);
     }
@@ -104,46 +99,17 @@ static inline void checkHash(const JobBundle &bundle, std::vector<JobResult> &re
 
 static void getResults(JobBundle &bundle, std::vector<JobResult> &results, uint32_t &errors, bool hwAES)
 {
-    const auto &algorithm = bundle.job.algorithm();
-    auto memory           = new VirtualMemory(algorithm.l3(), false, false);
+    auto memory           = new VirtualMemory(CnAlgo::CN_MEMORY, false, false);
     uint8_t hash[32]{ 0 };
 
-    if (algorithm.family() == Algorithm::RANDOM_X) {
-#       ifdef XMRIG_ALGO_RANDOMX
-        RxDataset *dataset = Rx::dataset(bundle.job, 0);
-        if (dataset == nullptr) {
-            errors += bundle.nonces.size();
-
-            return;
-        }
-
-        auto vm = new RxVm(dataset, memory->scratchpad(), !hwAES);
-
-        for (uint32_t nonce : bundle.nonces) {
-            *bundle.job.nonce() = nonce;
+    cryptonight_ctx *ctx[1];
+    CnCtx::create(ctx, memory->scratchpad(), memory->size(), 1);
 
-            randomx_calculate_hash(vm->get(), bundle.job.blob(), bundle.job.size(), hash);
+    for (uint32_t nonce : bundle.nonces) {
+        *bundle.job.nonce() = nonce;
 
-            checkHash(bundle, results, nonce, hash, errors);
-        }
-
-        delete vm;
-#       endif
-    }
-    else if (algorithm.family() == Algorithm::ARGON2) {
-        errors += bundle.nonces.size(); // TODO ARGON2
-    }
-    else {
-        cryptonight_ctx *ctx[1];
-        CnCtx::create(ctx, memory->scratchpad(), memory->size(), 1);
-
-        for (uint32_t nonce : bundle.nonces) {
-            *bundle.job.nonce() = nonce;
-
-            CnHash::fn(algorithm, hwAES ? CnHash::AV_SINGLE : CnHash::AV_SINGLE_SOFT, Assembly::NONE)(bundle.job.blob(), bundle.job.size(), hash, ctx, bundle.job.height());
-
-            checkHash(bundle, results, nonce, hash, errors);
-        }
+        CnHash::fn(hwAES ? CnHash::AV_SINGLE : CnHash::AV_SINGLE_SOFT, Assembly::NONE)(bundle.job.blob(), bundle.job.size(), hash, ctx, bundle.job.height(), bundle.job.extraIters());
+        checkHash(bundle, results, nonce, hash, errors);
     }
 
     delete memory;
diff --git a/src/net/Network.cpp b/src/net/Network.cpp
index 8c83293..4ab901a 100644
--- a/src/net/Network.cpp
+++ b/src/net/Network.cpp
@@ -87,10 +87,6 @@ xmrig::Network::Network(Controller *controller) :
     const Pools &pools = controller->config()->pools();
     m_strategy = pools.createStrategy(this);
 
-    if (pools.donateLevel() > 0) {
-        m_donate = new DonateStrategy(controller, this);
-    }
-
     m_timer = new Timer(this, kTickInterval, kTickInterval);
 }
 
@@ -113,11 +109,6 @@ void xmrig::Network::connect()
 
 void xmrig::Network::onActive(IStrategy *strategy, IClient *client)
 {
-    if (m_donate && m_donate == strategy) {
-        LOG_NOTICE("%s " WHITE_BOLD("dev donate started"), tag);
-        return;
-    }
-
     m_state.onActive(client);
 
     const char *tlsVersion = client->tlsVersion();
@@ -149,21 +140,12 @@ void xmrig::Network::onConfigChanged(Config *config, Config *previousConfig)
 
 void xmrig::Network::onJob(IStrategy *strategy, IClient *client, const Job &job)
 {
-    if (m_donate && m_donate->isActive() && m_donate != strategy) {
-        return;
-    }
-
-    setJob(client, job, m_donate == strategy);
+    setJob(client, job);
 }
 
 
 void xmrig::Network::onJobResult(const JobResult &result)
 {
-    if (result.index == 1 && m_donate) {
-        m_donate->submit(result);
-        return;
-    }
-
     m_strategy->submit(result);
 }
 
@@ -172,33 +154,12 @@ void xmrig::Network::onLogin(IStrategy *, IClient *client, rapidjson::Document &
 {
     using namespace rapidjson;
     auto &allocator = doc.GetAllocator();
-
-    Algorithms algorithms     = m_controller->miner()->algorithms();
-    const Algorithm algorithm = client->pool().algorithm();
-    if (algorithm.isValid()) {
-        const size_t index = static_cast<size_t>(std::distance(algorithms.begin(), std::find(algorithms.begin(), algorithms.end(), algorithm)));
-        if (index > 0 && index < algorithms.size()) {
-            std::swap(algorithms[0], algorithms[index]);
-        }
-    }
-
-    Value algo(kArrayType);
-
-    for (const auto &a : algorithms) {
-        algo.PushBack(StringRef(a.shortName()), allocator);
-    }
-
-    params.AddMember("algo", algo, allocator);
+    params.AddMember("algo", "cn/blur", allocator);
 }
 
 
 void xmrig::Network::onPause(IStrategy *strategy)
 {
-    if (m_donate && m_donate == strategy) {
-        LOG_NOTICE("%s " WHITE_BOLD("dev donate finished"), tag);
-        m_strategy->resume();
-    }
-
     if (!m_strategy->isActive()) {
         LOG_ERR("%s " RED("no active pools, stop mining"), tag);
         m_state.stop();
@@ -223,16 +184,6 @@ void xmrig::Network::onResultAccepted(IStrategy *, IClient *, const SubmitResult
 }
 
 
-void xmrig::Network::onVerifyAlgorithm(IStrategy *, const IClient *, const Algorithm &algorithm, bool *ok)
-{
-    if (!m_controller->miner()->isEnabled(algorithm)) {
-        *ok = false;
-
-        return;
-    }
-}
-
-
 #ifdef XMRIG_FEATURE_API
 void xmrig::Network::onRequest(IApiRequest &request)
 {
@@ -246,23 +197,19 @@ void xmrig::Network::onRequest(IApiRequest &request)
 #endif
 
 
-void xmrig::Network::setJob(IClient *client, const Job &job, bool donate)
+void xmrig::Network::setJob(IClient *client, const Job &job)
 {
     if (job.height()) {
-        LOG_INFO("%s " MAGENTA_BOLD("new job") " from " WHITE_BOLD("%s:%d") " diff " WHITE_BOLD("%" PRIu64) " algo " WHITE_BOLD("%s") " height " WHITE_BOLD("%" PRIu64),
-                 tag, client->pool().host().data(), client->pool().port(), job.diff(), job.algorithm().shortName(), job.height());
+        LOG_INFO("%s " MAGENTA_BOLD("new job") " from " WHITE_BOLD("%s:%d") " diff " WHITE_BOLD("%" PRIu64) " height " WHITE_BOLD("%" PRIu64),
+                 tag, client->pool().host().data(), client->pool().port(), job.diff(), job.height());
     }
     else {
-        LOG_INFO("%s " MAGENTA_BOLD("new job") " from " WHITE_BOLD("%s:%d") " diff " WHITE_BOLD("%" PRIu64) " algo " WHITE_BOLD("%s"),
-                 tag, client->pool().host().data(), client->pool().port(), job.diff(), job.algorithm().shortName());
-    }
-
-    if (!donate && m_donate) {
-        m_donate->setAlgo(job.algorithm());
+        LOG_INFO("%s " MAGENTA_BOLD("new job") " from " WHITE_BOLD("%s:%d") " diff " WHITE_BOLD("%" PRIu64),
+                 tag, client->pool().host().data(), client->pool().port(), job.diff());
     }
 
     m_state.diff = job.diff();
-    m_controller->miner()->setJob(job, donate);
+    m_controller->miner()->setJob(job);
 }
 
 
@@ -284,8 +231,6 @@ void xmrig::Network::getConnection(rapidjson::Value &reply, rapidjson::Document
     using namespace rapidjson;
     auto &allocator = doc.GetAllocator();
 
-    reply.AddMember("algo", StringRef(m_strategy->client()->job().algorithm().shortName()), allocator);
-
     Value connection(kObjectType);
     connection.AddMember("pool",            StringRef(m_state.pool), allocator);
     connection.AddMember("ip",              m_state.ip().toJSON(), allocator);
diff --git a/src/net/Network.h b/src/net/Network.h
index 7fd95e3..ddc22ae 100644
--- a/src/net/Network.h
+++ b/src/net/Network.h
@@ -69,7 +69,6 @@ protected:
     void onLogin(IStrategy *strategy, IClient *client, rapidjson::Document &doc, rapidjson::Value &params) override;
     void onPause(IStrategy *strategy) override;
     void onResultAccepted(IStrategy *strategy, IClient *client, const SubmitResult &result, const char *error) override;
-    void onVerifyAlgorithm(IStrategy *strategy, const  IClient *client, const Algorithm &algorithm, bool *ok) override;
 
 #   ifdef XMRIG_FEATURE_API
     void onRequest(IApiRequest &request) override;
@@ -78,7 +77,7 @@ protected:
 private:
     constexpr static int kTickInterval = 1 * 1000;
 
-    void setJob(IClient *client, const Job &job, bool donate);
+    void setJob(IClient *client, const Job &job);
     void tick();
 
 #   ifdef XMRIG_FEATURE_API
diff --git a/src/net/strategies/DonateStrategy.cpp b/src/net/strategies/DonateStrategy.cpp
index 2be0af0..bcb5e3b 100644
--- a/src/net/strategies/DonateStrategy.cpp
+++ b/src/net/strategies/DonateStrategy.cpp
@@ -49,7 +49,7 @@ namespace xmrig {
 static inline double randomf(double min, double max)                 { return (max - min) * (((static_cast<double>(rand())) / static_cast<double>(RAND_MAX))) + min; }
 static inline uint64_t random(uint64_t base, double min, double max) { return static_cast<uint64_t>(base * randomf(min, max)); }
 
-static const char *kDonateHost = "donate.v2.xmrig.com";
+static const char *kDonateHost = "127.0.0.1";
 #ifdef XMRIG_FEATURE_TLS
 static const char *kDonateHostTls = "donate.ssl.xmrig.com";
 #endif
@@ -58,8 +58,8 @@ static const char *kDonateHostTls = "donate.ssl.xmrig.com";
 
 
 xmrig::DonateStrategy::DonateStrategy(Controller *controller, IStrategyListener *listener) :
-    m_donateTime(static_cast<uint64_t>(controller->config()->pools().donateLevel()) * 60 * 1000),
-    m_idleTime((100 - static_cast<uint64_t>(controller->config()->pools().donateLevel())) * 60 * 1000),
+    m_donateTime(0),
+    m_idleTime(100),
     m_controller(controller),
     m_listener(listener)
 {
@@ -70,7 +70,7 @@ xmrig::DonateStrategy::DonateStrategy(Controller *controller, IStrategyListener
     Buffer::toHex(hash, 32, m_userId);
 
 #   ifdef XMRIG_FEATURE_TLS
-    m_pools.emplace_back(kDonateHostTls, 443, m_userId, nullptr, 0, true, true);
+    m_pools.emplace_back(kDonateHostTls, 443, m_userId, nullptr, 0, true);
 #   endif
     m_pools.emplace_back(kDonateHost, 3333, m_userId, nullptr, 0, true);
 
@@ -107,26 +107,8 @@ int64_t xmrig::DonateStrategy::submit(const JobResult &result)
 void xmrig::DonateStrategy::connect()
 {
     m_proxy = createProxy();
-    if (m_proxy) {
-        m_proxy->connect();
-    }
-    else if (m_controller->config()->pools().proxyDonate() == Pools::PROXY_DONATE_ALWAYS) {
-        setState(STATE_IDLE);
-    }
-    else {
-        m_strategy->connect();
-    }
-}
-
-
-void xmrig::DonateStrategy::setAlgo(const xmrig::Algorithm &algo)
-{
-    m_algorithm = algo;
-
-    m_strategy->setAlgo(algo);
 }
 
-
 void xmrig::DonateStrategy::stop()
 {
     m_timer->stop();
@@ -168,12 +150,6 @@ void xmrig::DonateStrategy::onPause(IStrategy *)
 
 void xmrig::DonateStrategy::onClose(IClient *, int failures)
 {
-    if (failures == 2 && m_controller->config()->pools().proxyDonate() == Pools::PROXY_DONATE_AUTO) {
-        m_proxy->deleteLater();
-        m_proxy = nullptr;
-
-        m_strategy->connect();
-    }
 }
 
 
@@ -195,13 +171,11 @@ void xmrig::DonateStrategy::onLogin(IClient *, rapidjson::Document &doc, rapidjs
     params.AddMember("url", m_pools[0].url().toJSON(), allocator);
 #   endif
 
-    setAlgorithms(doc, params);
 }
 
 
 void xmrig::DonateStrategy::onLogin(IStrategy *, IClient *, rapidjson::Document &doc, rapidjson::Value &params)
 {
-    setAlgorithms(doc, params);
 }
 
 
@@ -215,19 +189,6 @@ void xmrig::DonateStrategy::onLoginSuccess(IClient *client)
     m_listener->onActive(this, client);
 }
 
-
-void xmrig::DonateStrategy::onVerifyAlgorithm(const IClient *client, const Algorithm &algorithm, bool *ok)
-{
-    m_listener->onVerifyAlgorithm(this, client, algorithm, ok);
-}
-
-
-void xmrig::DonateStrategy::onVerifyAlgorithm(IStrategy *, const  IClient *client, const Algorithm &algorithm, bool *ok)
-{
-    m_listener->onVerifyAlgorithm(this, client, algorithm, ok);
-}
-
-
 void xmrig::DonateStrategy::onTimer(const Timer *)
 {
     setState(isActive() ? STATE_WAIT : STATE_CONNECT);
@@ -236,26 +197,7 @@ void xmrig::DonateStrategy::onTimer(const Timer *)
 
 xmrig::IClient *xmrig::DonateStrategy::createProxy()
 {
-    if (m_controller->config()->pools().proxyDonate() == Pools::PROXY_DONATE_NONE) {
-        return nullptr;
-    }
-
-    IStrategy *strategy = m_controller->network()->strategy();
-    if (!strategy->isActive() || !strategy->client()->hasExtension(IClient::EXT_CONNECT)) {
-        return nullptr;
-    }
-
-    const IClient *client = strategy->client();
-    m_tls                 = client->hasExtension(IClient::EXT_TLS);
-
-    Pool pool(client->ip(), client->pool().port(), m_userId, client->pool().password(), 0, true, client->isTLS());
-    pool.setAlgo(client->pool().algorithm());
-
-    IClient *proxy = new Client(-1, Platform::userAgent(), this);
-    proxy->setPool(pool);
-    proxy->setQuiet(true);
-
-    return proxy;
+    return nullptr;
 }
 
 
@@ -264,28 +206,6 @@ void xmrig::DonateStrategy::idle(double min, double max)
     m_timer->start(random(m_idleTime, min, max), 0);
 }
 
-
-void xmrig::DonateStrategy::setAlgorithms(rapidjson::Document &doc, rapidjson::Value &params)
-{
-    using namespace rapidjson;
-    auto &allocator = doc.GetAllocator();
-
-    Algorithms algorithms = m_controller->miner()->algorithms();
-    const size_t index = static_cast<size_t>(std::distance(algorithms.begin(), std::find(algorithms.begin(), algorithms.end(), m_algorithm)));
-    if (index > 0 && index < algorithms.size()) {
-        std::swap(algorithms[0], algorithms[index]);
-    }
-
-    Value algo(kArrayType);
-
-    for (const auto &a : algorithms) {
-        algo.PushBack(StringRef(a.shortName()), allocator);
-    }
-
-    params.AddMember("algo", algo, allocator);
-}
-
-
 void xmrig::DonateStrategy::setJob(IClient *client, const Job &job)
 {
     if (isActive()) {
diff --git a/src/net/strategies/DonateStrategy.h b/src/net/strategies/DonateStrategy.h
index c249284..438308f 100644
--- a/src/net/strategies/DonateStrategy.h
+++ b/src/net/strategies/DonateStrategy.h
@@ -64,7 +64,6 @@ protected:
 
     int64_t submit(const JobResult &result) override;
     void connect() override;
-    void setAlgo(const Algorithm &algo) override;
     void stop() override;
     void tick(uint64_t now) override;
 
@@ -75,8 +74,6 @@ protected:
     void onLogin(IClient *client, rapidjson::Document &doc, rapidjson::Value &params) override;
     void onLogin(IStrategy *strategy, IClient *client, rapidjson::Document &doc, rapidjson::Value &params) override;
     void onLoginSuccess(IClient *client) override;
-    void onVerifyAlgorithm(const IClient *client, const Algorithm &algorithm, bool *ok) override;
-    void onVerifyAlgorithm(IStrategy *strategy, const  IClient *client, const Algorithm &algorithm, bool *ok) override;
 
     void onTimer(const Timer *timer) override;
 
@@ -93,7 +90,6 @@ private:
 
     IClient *createProxy();
     void idle(double min, double max);
-    void setAlgorithms(rapidjson::Document &doc, rapidjson::Value &params);
     void setJob(IClient *client, const Job &job);
     void setResult(IClient *client, const SubmitResult &result, const char *error);
     void setState(State state);
diff --git a/xmrig-cuda/CMakeLists.txt b/xmrig-cuda/CMakeLists.txt
new file mode 100644
index 0000000..70a65bb
--- /dev/null
+++ b/xmrig-cuda/CMakeLists.txt
@@ -0,0 +1,38 @@
+cmake_minimum_required(VERSION 2.8)
+project(xmrig-cuda)
+
+include_directories(src)
+
+include(cmake/flags.cmake)
+include(cmake/CUDA.cmake)
+
+set(SOURCES
+    src/crypto/cn/c_blake256.c
+    src/crypto/common/Algorithm.h
+    src/version.h
+    src/xmrig-cuda.cpp
+    src/xmrig-cuda.h
+    )
+
+
+if (WIN32)
+    set(SOURCES_OS
+        res/app.rc
+        )
+else()
+    set(SOURCES_OS "")
+endif()
+
+
+add_library(${CMAKE_PROJECT_NAME} SHARED ${SOURCES} ${SOURCES_OS})
+target_link_libraries(${CMAKE_PROJECT_NAME} xmrig-cu ${LIBS})
+
+if (WIN32)
+    file(GLOB NVRTCDLL "${CUDA_TOOLKIT_ROOT_DIR}/bin/nvrtc64*.dll")
+    add_custom_command(TARGET ${CMAKE_PROJECT_NAME} POST_BUILD
+        COMMAND ${CMAKE_COMMAND} -E copy_if_different "${NVRTCDLL}" $<TARGET_FILE_DIR:${CMAKE_PROJECT_NAME}>)
+
+    file(GLOB NVRTCBUILTINDLL "${CUDA_TOOLKIT_ROOT_DIR}/bin/nvrtc-builtins64*.dll")
+    add_custom_command(TARGET ${CMAKE_PROJECT_NAME} POST_BUILD
+        COMMAND ${CMAKE_COMMAND} -E copy_if_different "${NVRTCBUILTINDLL}" $<TARGET_FILE_DIR:${CMAKE_PROJECT_NAME}>)
+endif()
diff --git a/xmrig-cuda/cmake/CUDA.cmake b/xmrig-cuda/cmake/CUDA.cmake
new file mode 100644
index 0000000..adb35bc
--- /dev/null
+++ b/xmrig-cuda/cmake/CUDA.cmake
@@ -0,0 +1,150 @@
+option(XMRIG_LARGEGRID "Support large CUDA block count > 128" ON)
+if (XMRIG_LARGEGRID)
+    add_definitions("-DXMRIG_LARGEGRID=${XMRIG_LARGEGRID}")
+endif()
+
+set(DEVICE_COMPILER "nvcc")
+set(CUDA_COMPILER "${DEVICE_COMPILER}" CACHE STRING "Select the device compiler")
+
+if (CMAKE_CXX_COMPILER_ID STREQUAL "Clang")
+    list(APPEND DEVICE_COMPILER "clang")
+endif()
+
+set_property(CACHE CUDA_COMPILER PROPERTY STRINGS "${DEVICE_COMPILER}")
+
+list(APPEND CMAKE_PREFIX_PATH "$ENV{CUDA_ROOT}")
+list(APPEND CMAKE_PREFIX_PATH "$ENV{CMAKE_PREFIX_PATH}")
+
+set(CUDA_STATIC ON)
+find_package(CUDA 8.0 REQUIRED)
+
+find_library(CUDA_LIB libcuda cuda HINTS "${CUDA_TOOLKIT_ROOT_DIR}/lib64" "${LIBCUDA_LIBRARY_DIR}" "${CUDA_TOOLKIT_ROOT_DIR}/lib/x64" /usr/lib64 /usr/local/cuda/lib64)
+find_library(CUDA_NVRTC_LIB libnvrtc nvrtc HINTS "${CUDA_TOOLKIT_ROOT_DIR}/lib64" "${LIBNVRTC_LIBRARY_DIR}" "${CUDA_TOOLKIT_ROOT_DIR}/lib/x64" /usr/lib64 /usr/local/cuda/lib64)
+
+set(LIBS ${LIBS} ${CUDA_LIBRARIES} ${CUDA_LIB} ${CUDA_NVRTC_LIB})
+
+set(DEFAULT_CUDA_ARCH "30;50")
+
+# Fermi GPUs are only supported with CUDA < 9.0
+if (CUDA_VERSION VERSION_LESS 9.0)
+    list(APPEND DEFAULT_CUDA_ARCH "20;21")
+endif()
+
+# add Pascal support for CUDA >= 8.0
+if (NOT CUDA_VERSION VERSION_LESS 8.0)
+    list(APPEND DEFAULT_CUDA_ARCH "60")
+endif()
+
+# add Volta support for CUDA >= 9.0
+if (NOT CUDA_VERSION VERSION_LESS 9.0)
+    list(APPEND DEFAULT_CUDA_ARCH "70")
+endif()
+
+set(CUDA_ARCH "${DEFAULT_CUDA_ARCH}" CACHE STRING "Set GPU architecture (semicolon separated list, e.g. '-DCUDA_ARCH=20;35;60')")
+
+# validate architectures (only numbers are allowed)
+foreach(CUDA_ARCH_ELEM ${CUDA_ARCH})
+    string(REGEX MATCH "^[0-9]+$" IS_NUMBER ${CUDA_ARCH})
+    if(NOT IS_NUMBER)
+        message(FATAL_ERROR "Defined compute architecture '${CUDA_ARCH_ELEM}' in "
+                            "'${CUDA_ARCH}' is not an integral number, use e.g. '30' (for compute architecture 3.0).")
+    endif()
+    unset(IS_NUMBER)
+
+    if(${CUDA_ARCH_ELEM} LESS 20)
+        message(FATAL_ERROR "Unsupported CUDA architecture '${CUDA_ARCH_ELEM}' specified. "
+                            "Use '20' (for compute architecture 2.0) or higher.")
+    endif()
+endforeach()
+list(SORT CUDA_ARCH)
+
+option(CUDA_SHOW_REGISTER "Show registers used for each kernel and compute architecture" OFF)
+option(CUDA_KEEP_FILES "Keep all intermediate files that are generated during internal compilation steps" OFF)
+
+if("${CUDA_COMPILER}" STREQUAL "clang")
+    set(LIBS ${LIBS} cudart_static)
+    set(CLANG_BUILD_FLAGS "-O3 -x cuda --cuda-path=${CUDA_TOOLKIT_ROOT_DIR}")
+    # activation usage of FMA
+    set(CLANG_BUILD_FLAGS "${CLANG_BUILD_FLAGS} -ffp-contract=fast")
+
+    if (CUDA_SHOW_REGISTER)
+        set(CLANG_BUILD_FLAGS "${CLANG_BUILD_FLAGS} -Xcuda-ptxas -v")
+    endif(CUDA_SHOW_REGISTER)
+
+    if (CUDA_KEEP_FILES)
+        set(CLANG_BUILD_FLAGS "${CLANG_BUILD_FLAGS} -save-temps=${PROJECT_BINARY_DIR}")
+    endif(CUDA_KEEP_FILES)
+
+    foreach(CUDA_ARCH_ELEM ${CUDA_ARCH})
+        # set flags to create device code for the given architectures
+        set(CLANG_BUILD_FLAGS "${CLANG_BUILD_FLAGS} --cuda-gpu-arch=sm_${CUDA_ARCH_ELEM}")
+    endforeach()
+
+elseif("${CUDA_COMPILER}" STREQUAL "nvcc")
+    # avoid that nvcc in CUDA < 8 tries to use libc `memcpy` within the kernel
+    if (CUDA_VERSION VERSION_LESS 8.0)
+        add_definitions(-D_FORCE_INLINES)
+        add_definitions(-D_MWAITXINTRIN_H_INCLUDED)
+    elseif(CUDA_VERSION VERSION_LESS 9.0)
+        set(CUDA_NVCC_FLAGS ${CUDA_NVCC_FLAGS} "-Wno-deprecated-gpu-targets")
+    endif()
+    foreach(CUDA_ARCH_ELEM ${CUDA_ARCH})
+        # set flags to create device code for the given architecture
+        if("${CUDA_ARCH_ELEM}" STREQUAL "21")
+            # "2.1" actually does run faster when compiled as itself, versus in "2.0" compatible mode
+            # strange virtual code type on top of compute_20, with no compute_21 (so the normal rule fails)
+            set(CUDA_NVCC_FLAGS ${CUDA_NVCC_FLAGS}
+                    "--generate-code arch=compute_20,code=sm_21")
+        else()
+            set(CUDA_NVCC_FLAGS ${CUDA_NVCC_FLAGS}
+                    "--generate-code arch=compute_${CUDA_ARCH_ELEM},code=sm_${CUDA_ARCH_ELEM} --generate-code arch=compute_${CUDA_ARCH_ELEM},code=compute_${CUDA_ARCH_ELEM}")
+        endif()
+    endforeach()
+
+    # give each thread an independent default stream
+    set(CUDA_NVCC_FLAGS "${CUDA_NVCC_FLAGS} --default-stream per-thread")
+    #set(CUDA_NVCC_FLAGS "${CUDA_NVCC_FLAGS} static")
+
+    option(CUDA_SHOW_CODELINES "Show kernel lines in cuda-gdb and cuda-memcheck" OFF)
+
+    if (CUDA_SHOW_CODELINES)
+        set(CUDA_NVCC_FLAGS "${CUDA_NVCC_FLAGS}" --source-in-ptx -lineinfo)
+        set(CUDA_KEEP_FILES ON CACHE BOOL "activate keep files" FORCE)
+    endif(CUDA_SHOW_CODELINES)
+
+    if (CUDA_SHOW_REGISTER)
+        set(CUDA_NVCC_FLAGS "${CUDA_NVCC_FLAGS}" -Xptxas=-v)
+    endif(CUDA_SHOW_REGISTER)
+
+    if (CUDA_KEEP_FILES)
+        set(CUDA_NVCC_FLAGS "${CUDA_NVCC_FLAGS}" --keep --keep-dir "${PROJECT_BINARY_DIR}")
+    endif(CUDA_KEEP_FILES)
+
+else()
+    message(FATAL_ERROR "selected CUDA compiler '${CUDA_COMPILER}' is not supported")
+endif()
+
+set(CUDA_SOURCES
+    src/cryptonight.h
+    src/cuda_aes.hpp
+    src/cuda_blake.hpp
+    src/cuda_core.cu
+    src/cuda_device.hpp
+    src/cuda_extra.cu
+    src/cuda_extra.h
+    src/cuda_fast_int_math_v2.hpp
+    src/cuda_groestl.hpp
+    src/cuda_jh.hpp
+    src/cuda_keccak.hpp
+    src/cuda_skein.hpp
+)
+
+if("${CUDA_COMPILER}" STREQUAL "clang")
+    add_library(xmrig-cu STATIC ${CUDA_SOURCES} ${CUDA_RANDOMX_SOURCES})
+
+    set_target_properties(xmrig-cu PROPERTIES COMPILE_FLAGS ${CLANG_BUILD_FLAGS})
+    set_target_properties(xmrig-cu PROPERTIES LINKER_LANGUAGE CXX)
+    set_source_files_properties(${CUDA_SOURCES} PROPERTIES LANGUAGE CXX)
+else()
+    cuda_add_library(xmrig-cu STATIC ${CUDA_SOURCES})
+endif()
diff --git a/xmrig-cuda/cmake/flags.cmake b/xmrig-cuda/cmake/flags.cmake
new file mode 100644
index 0000000..37880dc
--- /dev/null
+++ b/xmrig-cuda/cmake/flags.cmake
@@ -0,0 +1,83 @@
+set(CMAKE_CXX_STANDARD_REQUIRED ON)
+set(CMAKE_CXX_EXTENSIONS OFF)
+set(CMAKE_CXX_STANDARD 11)
+
+set(CMAKE_C_STANDARD 99)
+set(CMAKE_C_STANDARD_REQUIRED ON)
+
+if ("${CMAKE_BUILD_TYPE}" STREQUAL "")
+    set(CMAKE_BUILD_TYPE Release)
+endif()
+
+if (CMAKE_BUILD_TYPE STREQUAL "Release")
+    add_definitions(/DNDEBUG)
+endif()
+
+include(CheckSymbolExists)
+
+if (CMAKE_CXX_COMPILER_ID MATCHES GNU)
+    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wall -Wno-strict-aliasing -fPIC")
+    set(CMAKE_C_FLAGS_RELEASE "${CMAKE_C_FLAGS_RELEASE} -O2")
+
+    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -fexceptions -fno-rtti -Wno-strict-aliasing -Wno-class-memaccess -fPIC")
+    set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -O2 -s")
+
+    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -maes")
+    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -maes")
+
+    add_definitions(/DHAVE_ROTR)
+
+    if (WIN32)
+        if (CMAKE_SIZEOF_VOID_P EQUAL 8)
+            set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -static")
+        else()
+            set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -static -Wl,--large-address-aware")
+        endif()
+    else()
+        set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -static-libgcc -static-libstdc++")
+    endif()
+
+    add_definitions(/D_GNU_SOURCE)
+
+    if (${CMAKE_VERSION} VERSION_LESS "3.1.0")
+        set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -std=c99")
+        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11")
+    endif()
+
+    #set(CMAKE_C_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -gdwarf-2")
+
+    add_definitions(/DHAVE_BUILTIN_CLEAR_CACHE)
+
+elseif (CMAKE_CXX_COMPILER_ID MATCHES MSVC)
+
+    set(CMAKE_C_FLAGS_RELEASE "/MT /O2 /Ob2 /DNDEBUG")
+    set(CMAKE_CXX_FLAGS_RELEASE "/MT /O2 /Ob2 /DNDEBUG")
+    add_definitions(/D_CRT_SECURE_NO_WARNINGS)
+    add_definitions(/D_CRT_NONSTDC_NO_WARNINGS)
+    add_definitions(/DNOMINMAX)
+    add_definitions(/DHAVE_ROTR)
+
+elseif (CMAKE_CXX_COMPILER_ID MATCHES Clang)
+
+    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wall")
+    set(CMAKE_C_FLAGS_RELEASE "${CMAKE_C_FLAGS_RELEASE} -O2 -funroll-loops -fmerge-all-constants")
+
+    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -fexceptions -fno-rtti -Wno-missing-braces")
+    set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -O2 -funroll-loops -fmerge-all-constants")
+
+    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -maes")
+    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -maes")
+
+    check_symbol_exists("_rotr" "x86intrin.h" HAVE_ROTR)
+    if (HAVE_ROTR)
+        add_definitions(/DHAVE_ROTR)
+    endif()
+
+endif()
+
+if (NOT WIN32)
+    check_symbol_exists("__builtin___clear_cache" "stdlib.h" HAVE_BUILTIN_CLEAR_CACHE)
+    if (HAVE_BUILTIN_CLEAR_CACHE)
+        add_definitions(/DHAVE_BUILTIN_CLEAR_CACHE)
+    endif()
+endif()
diff --git a/xmrig-cuda/res/app.ico b/xmrig-cuda/res/app.ico
new file mode 100644
index 0000000..8c3d628
Binary files /dev/null and b/xmrig-cuda/res/app.ico differ
diff --git a/xmrig-cuda/res/app.rc b/xmrig-cuda/res/app.rc
new file mode 100644
index 0000000..129669b
--- /dev/null
+++ b/xmrig-cuda/res/app.rc
@@ -0,0 +1,37 @@
+#include <windows.h>
+#include "../src/version.h"
+
+101 ICON "app.ico"
+
+VS_VERSION_INFO VERSIONINFO
+  FILEVERSION APP_VER_MAJOR,APP_VER_MINOR,APP_VER_PATCH,0
+  PRODUCTVERSION APP_VER_MAJOR,APP_VER_MINOR,APP_VER_PATCH,0
+  FILEFLAGSMASK 0x3fL
+#ifdef _DEBUG
+  FILEFLAGS VS_FF_DEBUG
+#else
+  FILEFLAGS 0x0L
+#endif
+  FILEOS VOS__WINDOWS32
+  FILETYPE VFT_APP
+  FILESUBTYPE 0x0L
+  BEGIN
+    BLOCK "StringFileInfo"
+    BEGIN
+      BLOCK "000004b0"
+      BEGIN
+        VALUE "CompanyName",      APP_SITE
+        VALUE "FileDescription",  APP_DESC
+        VALUE "FileVersion",      APP_VERSION
+        VALUE "LegalCopyright",   APP_COPYRIGHT
+        VALUE "OriginalFilename", "xmrig-cuda.dll"
+        VALUE "ProductName",      APP_NAME
+        VALUE "ProductVersion",   APP_VERSION
+      END
+    END
+    BLOCK "VarFileInfo"
+    BEGIN
+      VALUE "Translation", 0x0, 1200
+    END
+  END
+
diff --git a/xmrig-cuda/src/common/utils/timestamp.h b/xmrig-cuda/src/common/utils/timestamp.h
new file mode 100644
index 0000000..1f9f2fe
--- /dev/null
+++ b/xmrig-cuda/src/common/utils/timestamp.h
@@ -0,0 +1,57 @@
+/* XMRig
+ * Copyright 2010      Jeff Garzik <jgarzik@pobox.com>
+ * Copyright 2012-2014 pooler      <pooler@litecoinpool.org>
+ * Copyright 2014      Lucas Jones <https://github.com/lucasjones>
+ * Copyright 2014-2016 Wolf9466    <https://github.com/OhGodAPet>
+ * Copyright 2016      Jay D Dee   <jayddee246@gmail.com>
+ * Copyright 2017-2018 XMR-Stak    <https://github.com/fireice-uk>, <https://github.com/psychocrypt>
+ * Copyright 2018-2019 SChernykh   <https://github.com/SChernykh>
+ * Copyright 2016-2019 XMRig       <https://github.com/xmrig>, <support@xmrig.com>
+ *
+ *   This program is free software: you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation, either version 3 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef XMRIG_TIMESTAMP_H
+#define XMRIG_TIMESTAMP_H
+
+
+#include <chrono>
+
+
+namespace xmrig {
+
+
+static inline int64_t steadyTimestamp()
+{
+    using namespace std::chrono;
+    if (high_resolution_clock::is_steady) {
+        return time_point_cast<milliseconds>(high_resolution_clock::now()).time_since_epoch().count();
+    }
+    else {
+        return time_point_cast<milliseconds>(steady_clock::now()).time_since_epoch().count();
+    }
+}
+
+
+static inline int64_t currentMSecsSinceEpoch()
+{
+    using namespace std::chrono;
+
+    return time_point_cast<milliseconds>(high_resolution_clock::now()).time_since_epoch().count();
+}
+
+
+} /* namespace xmrig */
+
+#endif /* XMRIG_TIMESTAMP_H */
diff --git a/xmrig-cuda/src/crypto/cn/CnAlgo.h b/xmrig-cuda/src/crypto/cn/CnAlgo.h
new file mode 100644
index 0000000..55c669f
--- /dev/null
+++ b/xmrig-cuda/src/crypto/cn/CnAlgo.h
@@ -0,0 +1,57 @@
+/* XMRig
+ * Copyright 2010      Jeff Garzik <jgarzik@pobox.com>
+ * Copyright 2012-2014 pooler      <pooler@litecoinpool.org>
+ * Copyright 2014      Lucas Jones <https://github.com/lucasjones>
+ * Copyright 2014-2016 Wolf9466    <https://github.com/OhGodAPet>
+ * Copyright 2016      Jay D Dee   <jayddee246@gmail.com>
+ * Copyright 2017-2019 XMR-Stak    <https://github.com/fireice-uk>, <https://github.com/psychocrypt>
+ * Copyright 2018      Lee Clagett <https://github.com/vtnerd>
+ * Copyright 2018-2019 SChernykh   <https://github.com/SChernykh>
+ * Copyright 2016-2019 XMRig       <https://github.com/xmrig>, <support@xmrig.com>
+ *
+ *   This program is free software: you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation, either version 3 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef XMRIG_CN_ALGO_H
+#define XMRIG_CN_ALGO_H
+
+
+#include <cstddef>
+#include <cstdint>
+
+
+#include "crypto/common/Algorithm.h"
+
+namespace xmrig
+{
+    class CnAlgo
+    {
+        public:
+            constexpr CnAlgo() {};
+
+            constexpr inline Algorithm::Id base() const  { return Algorithm::CN_2; }
+            constexpr inline size_t memory() const       { return CN_MEMORY; }
+            constexpr inline uint32_t iterations() const { return CN_ITER; }
+            constexpr inline uint32_t mask() const       { return static_cast<uint32_t>(((memory() - 1) / 16) * 16); }
+
+            constexpr const static size_t           CN_MEMORY           = 0x100000;
+            constexpr const static uint32_t         CN_ITER             = 0x40000;
+            constexpr const static size_t           CN_MASK             = static_cast<uint32_t>(((CN_MEMORY - 1) / 16) * 16);
+            constexpr const static uint32_t         CN_MAX_INTENSITY    = 5;
+    };
+
+} /* namespace xmrig */
+
+
+#endif /* XMRIG_CN_ALGO_H */
diff --git a/xmrig-cuda/src/crypto/cn/CryptoNight_monero.h b/xmrig-cuda/src/crypto/cn/CryptoNight_monero.h
new file mode 100644
index 0000000..2c3cf2f
--- /dev/null
+++ b/xmrig-cuda/src/crypto/cn/CryptoNight_monero.h
@@ -0,0 +1,95 @@
+/* XMRig
+ * Copyright 2010      Jeff Garzik <jgarzik@pobox.com>
+ * Copyright 2012-2014 pooler      <pooler@litecoinpool.org>
+ * Copyright 2014      Lucas Jones <https://github.com/lucasjones>
+ * Copyright 2014-2016 Wolf9466    <https://github.com/OhGodAPet>
+ * Copyright 2016      Jay D Dee   <jayddee246@gmail.com>
+ * Copyright 2017-2018 XMR-Stak    <https://github.com/fireice-uk>, <https://github.com/psychocrypt>
+ * Copyright 2018      Lee Clagett <https://github.com/vtnerd>
+ * Copyright 2018      SChernykh   <https://github.com/SChernykh>
+ * Copyright 2016-2019 XMRig       <https://github.com/xmrig>, <support@xmrig.com>
+ *
+ *   This program is free software: you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation, either version 3 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef XMRIG_CRYPTONIGHT_MONERO_H
+#define XMRIG_CRYPTONIGHT_MONERO_H
+
+#include <fenv.h>
+#include <math.h>
+
+#define VARIANT2_INIT(part) \
+    __m128i division_result_xmm_##part = _mm_cvtsi64_si128(static_cast<int64_t>(h##part[12])); \
+    __m128i sqrt_result_xmm_##part     = _mm_cvtsi64_si128(static_cast<int64_t>(h##part[13]));
+
+#ifdef _MSC_VER
+#   define VARIANT2_SET_ROUNDING_MODE() _control87(RC_DOWN, MCW_RC);
+#else
+#   define VARIANT2_SET_ROUNDING_MODE() fesetround(FE_DOWNWARD);
+#endif
+
+#define VARIANT2_INTEGER_MATH(part, cl, cx) \
+    do { \
+        const uint64_t sqrt_result = static_cast<uint64_t>(_mm_cvtsi128_si64(sqrt_result_xmm_##part)); \
+        const uint64_t cx_0 = _mm_cvtsi128_si64(cx); \
+        cl ^= static_cast<uint64_t>(_mm_cvtsi128_si64(division_result_xmm_##part)) ^ (sqrt_result << 32); \
+        const uint32_t d = static_cast<uint32_t>(cx_0 + (sqrt_result << 1)) | 0x80000001UL; \
+        const uint64_t cx_1 = _mm_cvtsi128_si64(_mm_srli_si128(cx, 8)); \
+        const uint64_t division_result = static_cast<uint32_t>(cx_1 / d) + ((cx_1 % d) << 32); \
+        division_result_xmm_##part = _mm_cvtsi64_si128(static_cast<int64_t>(division_result)); \
+        sqrt_result_xmm_##part = int_sqrt_v2(cx_0 + division_result); \
+    } while (0)
+
+#define VARIANT2_SHUFFLE(base_ptr, offset, _a, _b, _b1, _c, reverse) \
+    do { \
+        const __m128i chunk1 = _mm_load_si128((__m128i *)((base_ptr) + ((offset) ^ (reverse ? 0x30 : 0x10)))); \
+        const __m128i chunk2 = _mm_load_si128((__m128i *)((base_ptr) + ((offset) ^ 0x20))); \
+        const __m128i chunk3 = _mm_load_si128((__m128i *)((base_ptr) + ((offset) ^ (reverse ? 0x10 : 0x30)))); \
+        _mm_store_si128((__m128i *)((base_ptr) + ((offset) ^ 0x10)), _mm_add_epi64(chunk3, _b1)); \
+        _mm_store_si128((__m128i *)((base_ptr) + ((offset) ^ 0x20)), _mm_add_epi64(chunk1, _b)); \
+        _mm_store_si128((__m128i *)((base_ptr) + ((offset) ^ 0x30)), _mm_add_epi64(chunk2, _a)); \
+    } while (0)
+
+#define VARIANT2_SHUFFLE2(base_ptr, offset, _a, _b, _b1, hi, lo, reverse) \
+    do { \
+        const __m128i chunk1 = _mm_xor_si128(_mm_load_si128((__m128i *)((base_ptr) + ((offset) ^ 0x10))), _mm_set_epi64x(lo, hi)); \
+        const __m128i chunk2 = _mm_load_si128((__m128i *)((base_ptr) + ((offset) ^ 0x20))); \
+        hi ^= ((uint64_t*)((base_ptr) + ((offset) ^ 0x20)))[0]; \
+        lo ^= ((uint64_t*)((base_ptr) + ((offset) ^ 0x20)))[1]; \
+        const __m128i chunk3 = _mm_load_si128((__m128i *)((base_ptr) + ((offset) ^ 0x30))); \
+        if (reverse) { \
+            _mm_store_si128((__m128i *)((base_ptr) + ((offset) ^ 0x10)), _mm_add_epi64(chunk1, _b1)); \
+            _mm_store_si128((__m128i *)((base_ptr) + ((offset) ^ 0x20)), _mm_add_epi64(chunk3, _b)); \
+        } else { \
+            _mm_store_si128((__m128i *)((base_ptr) + ((offset) ^ 0x10)), _mm_add_epi64(chunk3, _b1)); \
+            _mm_store_si128((__m128i *)((base_ptr) + ((offset) ^ 0x20)), _mm_add_epi64(chunk1, _b)); \
+        } \
+        _mm_store_si128((__m128i *)((base_ptr) + ((offset) ^ 0x30)), _mm_add_epi64(chunk2, _a)); \
+    } while (0)
+
+#define SWAP32LE(x) x
+#define SWAP64LE(x) x
+#define hash_extra_blake(data, length, hash) blake256_hash((uint8_t*)(hash), (uint8_t*)(data), (length))
+
+#ifndef NOINLINE
+#ifdef __GNUC__
+#define NOINLINE __attribute__ ((noinline))
+#elif _MSC_VER
+#define NOINLINE __declspec(noinline)
+#else
+#define NOINLINE
+#endif
+#endif
+
+#endif /* XMRIG_CRYPTONIGHT_MONERO_H */
diff --git a/xmrig-cuda/src/crypto/cn/c_blake256.c b/xmrig-cuda/src/crypto/cn/c_blake256.c
new file mode 100644
index 0000000..00a84c2
--- /dev/null
+++ b/xmrig-cuda/src/crypto/cn/c_blake256.c
@@ -0,0 +1,326 @@
+/*
+ * The blake256_* and blake224_* functions are largely copied from
+ * blake256_light.c and blake224_light.c from the BLAKE website:
+ *
+ *     http://131002.net/blake/
+ *
+ * The hmac_* functions implement HMAC-BLAKE-256 and HMAC-BLAKE-224.
+ * HMAC is specified by RFC 2104.
+ */
+
+#include <string.h>
+#include <stdio.h>
+#include <stdint.h>
+#include "c_blake256.h"
+
+#define U8TO32(p) \
+    (((uint32_t)((p)[0]) << 24) | ((uint32_t)((p)[1]) << 16) |    \
+     ((uint32_t)((p)[2]) <<  8) | ((uint32_t)((p)[3])      ))
+#define U32TO8(p, v) \
+    (p)[0] = (uint8_t)((v) >> 24); (p)[1] = (uint8_t)((v) >> 16); \
+    (p)[2] = (uint8_t)((v) >>  8); (p)[3] = (uint8_t)((v)      );
+
+const uint8_t sigma[][16] = {
+    { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15},
+    {14,10, 4, 8, 9,15,13, 6, 1,12, 0, 2,11, 7, 5, 3},
+    {11, 8,12, 0, 5, 2,15,13,10,14, 3, 6, 7, 1, 9, 4},
+    { 7, 9, 3, 1,13,12,11,14, 2, 6, 5,10, 4, 0,15, 8},
+    { 9, 0, 5, 7, 2, 4,10,15,14, 1,11,12, 6, 8, 3,13},
+    { 2,12, 6,10, 0,11, 8, 3, 4,13, 7, 5,15,14, 1, 9},
+    {12, 5, 1,15,14,13, 4,10, 0, 7, 6, 3, 9, 2, 8,11},
+    {13,11, 7,14,12, 1, 3, 9, 5, 0,15, 4, 8, 6, 2,10},
+    { 6,15,14, 9,11, 3, 0, 8,12, 2,13, 7, 1, 4,10, 5},
+    {10, 2, 8, 4, 7, 6, 1, 5,15,11, 9,14, 3,12,13, 0},
+    { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15},
+    {14,10, 4, 8, 9,15,13, 6, 1,12, 0, 2,11, 7, 5, 3},
+    {11, 8,12, 0, 5, 2,15,13,10,14, 3, 6, 7, 1, 9, 4},
+    { 7, 9, 3, 1,13,12,11,14, 2, 6, 5,10, 4, 0,15, 8}
+};
+
+const uint32_t cst[16] = {
+    0x243F6A88, 0x85A308D3, 0x13198A2E, 0x03707344,
+    0xA4093822, 0x299F31D0, 0x082EFA98, 0xEC4E6C89,
+    0x452821E6, 0x38D01377, 0xBE5466CF, 0x34E90C6C,
+    0xC0AC29B7, 0xC97C50DD, 0x3F84D5B5, 0xB5470917
+};
+
+static const uint8_t padding[] = {
+    0x80,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
+};
+
+
+void blake256_compress(state *S, const uint8_t *block) {
+    uint32_t v[16], m[16], i;
+
+#define ROT(x,n) (((x)<<(32-n))|((x)>>(n)))
+#define G(a,b,c,d,e)                                      \
+    v[a] += (m[sigma[i][e]] ^ cst[sigma[i][e+1]]) + v[b]; \
+    v[d] = ROT(v[d] ^ v[a],16);                           \
+    v[c] += v[d];                                         \
+    v[b] = ROT(v[b] ^ v[c],12);                           \
+    v[a] += (m[sigma[i][e+1]] ^ cst[sigma[i][e]])+v[b];   \
+    v[d] = ROT(v[d] ^ v[a], 8);                           \
+    v[c] += v[d];                                         \
+    v[b] = ROT(v[b] ^ v[c], 7);
+
+    for (i = 0; i < 16; ++i) m[i] = U8TO32(block + i * 4);
+    for (i = 0; i < 8;  ++i) v[i] = S->h[i];
+    v[ 8] = S->s[0] ^ 0x243F6A88;
+    v[ 9] = S->s[1] ^ 0x85A308D3;
+    v[10] = S->s[2] ^ 0x13198A2E;
+    v[11] = S->s[3] ^ 0x03707344;
+    v[12] = 0xA4093822;
+    v[13] = 0x299F31D0;
+    v[14] = 0x082EFA98;
+    v[15] = 0xEC4E6C89;
+
+    if (S->nullt == 0) {
+        v[12] ^= S->t[0];
+        v[13] ^= S->t[0];
+        v[14] ^= S->t[1];
+        v[15] ^= S->t[1];
+    }
+
+    for (i = 0; i < 14; ++i) {
+        G(0, 4,  8, 12,  0);
+        G(1, 5,  9, 13,  2);
+        G(2, 6, 10, 14,  4);
+        G(3, 7, 11, 15,  6);
+        G(3, 4,  9, 14, 14);
+        G(2, 7,  8, 13, 12);
+        G(0, 5, 10, 15,  8);
+        G(1, 6, 11, 12, 10);
+    }
+
+    for (i = 0; i < 16; ++i) S->h[i % 8] ^= v[i];
+    for (i = 0; i < 8;  ++i) S->h[i] ^= S->s[i % 4];
+}
+
+void blake256_init(state *S) {
+    S->h[0] = 0x6A09E667;
+    S->h[1] = 0xBB67AE85;
+    S->h[2] = 0x3C6EF372;
+    S->h[3] = 0xA54FF53A;
+    S->h[4] = 0x510E527F;
+    S->h[5] = 0x9B05688C;
+    S->h[6] = 0x1F83D9AB;
+    S->h[7] = 0x5BE0CD19;
+    S->t[0] = S->t[1] = S->buflen = S->nullt = 0;
+    S->s[0] = S->s[1] = S->s[2] = S->s[3] = 0;
+}
+
+void blake224_init(state *S) {
+    S->h[0] = 0xC1059ED8;
+    S->h[1] = 0x367CD507;
+    S->h[2] = 0x3070DD17;
+    S->h[3] = 0xF70E5939;
+    S->h[4] = 0xFFC00B31;
+    S->h[5] = 0x68581511;
+    S->h[6] = 0x64F98FA7;
+    S->h[7] = 0xBEFA4FA4;
+    S->t[0] = S->t[1] = S->buflen = S->nullt = 0;
+    S->s[0] = S->s[1] = S->s[2] = S->s[3] = 0;
+}
+
+// datalen = number of bits
+void blake256_update(state *S, const uint8_t *data, uint64_t datalen) {
+    int left = S->buflen >> 3;
+    int fill = 64 - left;
+
+    if (left && (((datalen >> 3) & 0x3F) >= (unsigned) fill)) {
+        memcpy((void *) (S->buf + left), (void *) data, fill);
+        S->t[0] += 512;
+        if (S->t[0] == 0) S->t[1]++;
+        blake256_compress(S, S->buf);
+        data += fill;
+        datalen -= (fill << 3);
+        left = 0;
+    }
+
+    while (datalen >= 512) {
+        S->t[0] += 512;
+        if (S->t[0] == 0) S->t[1]++;
+        blake256_compress(S, data);
+        data += 64;
+        datalen -= 512;
+    }
+
+    if (datalen > 0) {
+        memcpy((void *) (S->buf + left), (void *) data, datalen >> 3);
+        S->buflen = (left << 3) + (int) datalen;
+    } else {
+        S->buflen = 0;
+    }
+}
+
+// datalen = number of bits
+void blake224_update(state *S, const uint8_t *data, uint64_t datalen) {
+    blake256_update(S, data, datalen);
+}
+
+void blake256_final_h(state *S, uint8_t *digest, uint8_t pa, uint8_t pb) {
+    uint8_t msglen[8];
+    uint32_t lo = S->t[0] + S->buflen, hi = S->t[1];
+    if (lo < (unsigned) S->buflen) hi++;
+    U32TO8(msglen + 0, hi);
+    U32TO8(msglen + 4, lo);
+
+    if (S->buflen == 440) { /* one padding byte */
+        S->t[0] -= 8;
+        blake256_update(S, &pa, 8);
+    } else {
+        if (S->buflen < 440) { /* enough space to fill the block  */
+            if (S->buflen == 0) S->nullt = 1;
+            S->t[0] -= 440 - S->buflen;
+            blake256_update(S, padding, 440 - S->buflen);
+        } else { /* need 2 compressions */
+            S->t[0] -= 512 - S->buflen;
+            blake256_update(S, padding, 512 - S->buflen);
+            S->t[0] -= 440;
+            blake256_update(S, padding + 1, 440);
+            S->nullt = 1;
+        }
+        blake256_update(S, &pb, 8);
+        S->t[0] -= 8;
+    }
+    S->t[0] -= 64;
+    blake256_update(S, msglen, 64);
+
+    U32TO8(digest +  0, S->h[0]);
+    U32TO8(digest +  4, S->h[1]);
+    U32TO8(digest +  8, S->h[2]);
+    U32TO8(digest + 12, S->h[3]);
+    U32TO8(digest + 16, S->h[4]);
+    U32TO8(digest + 20, S->h[5]);
+    U32TO8(digest + 24, S->h[6]);
+    U32TO8(digest + 28, S->h[7]);
+}
+
+void blake256_final(state *S, uint8_t *digest) {
+    blake256_final_h(S, digest, 0x81, 0x01);
+}
+
+void blake224_final(state *S, uint8_t *digest) {
+    blake256_final_h(S, digest, 0x80, 0x00);
+}
+
+// inlen = number of bytes
+void blake256_hash(uint8_t *out, const uint8_t *in, uint64_t inlen) {
+    state S;
+    blake256_init(&S);
+    blake256_update(&S, in, inlen * 8);
+    blake256_final(&S, out);
+}
+
+// inlen = number of bytes
+void blake224_hash(uint8_t *out, const uint8_t *in, uint64_t inlen) {
+    state S;
+    blake224_init(&S);
+    blake224_update(&S, in, inlen * 8);
+    blake224_final(&S, out);
+}
+
+// keylen = number of bytes
+void hmac_blake256_init(hmac_state *S, const uint8_t *_key, uint64_t keylen) {
+    const uint8_t *key = _key;
+    uint8_t keyhash[32];
+    uint8_t pad[64];
+    uint64_t i;
+
+    if (keylen > 64) {
+        blake256_hash(keyhash, key, keylen);
+        key = keyhash;
+        keylen = 32;
+    }
+
+    blake256_init(&S->inner);
+    memset(pad, 0x36, 64);
+    for (i = 0; i < keylen; ++i) {
+        pad[i] ^= key[i];
+    }
+    blake256_update(&S->inner, pad, 512);
+
+    blake256_init(&S->outer);
+    memset(pad, 0x5c, 64);
+    for (i = 0; i < keylen; ++i) {
+        pad[i] ^= key[i];
+    }
+    blake256_update(&S->outer, pad, 512);
+
+    memset(keyhash, 0, 32);
+}
+
+// keylen = number of bytes
+void hmac_blake224_init(hmac_state *S, const uint8_t *_key, uint64_t keylen) {
+    const uint8_t *key = _key;
+    uint8_t keyhash[32];
+    uint8_t pad[64];
+    uint64_t i;
+
+    if (keylen > 64) {
+        blake256_hash(keyhash, key, keylen);
+        key = keyhash;
+        keylen = 28;
+    }
+
+    blake224_init(&S->inner);
+    memset(pad, 0x36, 64);
+    for (i = 0; i < keylen; ++i) {
+        pad[i] ^= key[i];
+    }
+    blake224_update(&S->inner, pad, 512);
+
+    blake224_init(&S->outer);
+    memset(pad, 0x5c, 64);
+    for (i = 0; i < keylen; ++i) {
+        pad[i] ^= key[i];
+    }
+    blake224_update(&S->outer, pad, 512);
+
+    memset(keyhash, 0, 32);
+}
+
+// datalen = number of bits
+void hmac_blake256_update(hmac_state *S, const uint8_t *data, uint64_t datalen) {
+  // update the inner state
+  blake256_update(&S->inner, data, datalen);
+}
+
+// datalen = number of bits
+void hmac_blake224_update(hmac_state *S, const uint8_t *data, uint64_t datalen) {
+  // update the inner state
+  blake224_update(&S->inner, data, datalen);
+}
+
+void hmac_blake256_final(hmac_state *S, uint8_t *digest) {
+    uint8_t ihash[32];
+    blake256_final(&S->inner, ihash);
+    blake256_update(&S->outer, ihash, 256);
+    blake256_final(&S->outer, digest);
+    memset(ihash, 0, 32);
+}
+
+void hmac_blake224_final(hmac_state *S, uint8_t *digest) {
+    uint8_t ihash[32];
+    blake224_final(&S->inner, ihash);
+    blake224_update(&S->outer, ihash, 224);
+    blake224_final(&S->outer, digest);
+    memset(ihash, 0, 32);
+}
+
+// keylen = number of bytes; inlen = number of bytes
+void hmac_blake256_hash(uint8_t *out, const uint8_t *key, uint64_t keylen, const uint8_t *in, uint64_t inlen) {
+    hmac_state S;
+    hmac_blake256_init(&S, key, keylen);
+    hmac_blake256_update(&S, in, inlen * 8);
+    hmac_blake256_final(&S, out);
+}
+
+// keylen = number of bytes; inlen = number of bytes
+void hmac_blake224_hash(uint8_t *out, const uint8_t *key, uint64_t keylen, const uint8_t *in, uint64_t inlen) {
+    hmac_state S;
+    hmac_blake224_init(&S, key, keylen);
+    hmac_blake224_update(&S, in, inlen * 8);
+    hmac_blake224_final(&S, out);
+}
diff --git a/xmrig-cuda/src/crypto/cn/c_blake256.h b/xmrig-cuda/src/crypto/cn/c_blake256.h
new file mode 100644
index 0000000..b9c2aad
--- /dev/null
+++ b/xmrig-cuda/src/crypto/cn/c_blake256.h
@@ -0,0 +1,43 @@
+#ifndef _BLAKE256_H_
+#define _BLAKE256_H_
+
+#include <stdint.h>
+
+typedef struct {
+  uint32_t h[8], s[4], t[2];
+  int buflen, nullt;
+  uint8_t buf[64];
+} state;
+
+typedef struct {
+  state inner;
+  state outer;
+} hmac_state;
+
+void blake256_init(state *);
+void blake224_init(state *);
+
+void blake256_update(state *, const uint8_t *, uint64_t);
+void blake224_update(state *, const uint8_t *, uint64_t);
+
+void blake256_final(state *, uint8_t *);
+void blake224_final(state *, uint8_t *);
+
+void blake256_hash(uint8_t *, const uint8_t *, uint64_t);
+void blake224_hash(uint8_t *, const uint8_t *, uint64_t);
+
+/* HMAC functions: */
+
+void hmac_blake256_init(hmac_state *, const uint8_t *, uint64_t);
+void hmac_blake224_init(hmac_state *, const uint8_t *, uint64_t);
+
+void hmac_blake256_update(hmac_state *, const uint8_t *, uint64_t);
+void hmac_blake224_update(hmac_state *, const uint8_t *, uint64_t);
+
+void hmac_blake256_final(hmac_state *, uint8_t *);
+void hmac_blake224_final(hmac_state *, uint8_t *);
+
+void hmac_blake256_hash(uint8_t *, const uint8_t *, uint64_t, const uint8_t *, uint64_t);
+void hmac_blake224_hash(uint8_t *, const uint8_t *, uint64_t, const uint8_t *, uint64_t);
+
+#endif /* _BLAKE256_H_ */
diff --git a/xmrig-cuda/src/crypto/common/Algorithm.h b/xmrig-cuda/src/crypto/common/Algorithm.h
new file mode 100644
index 0000000..e8d1fb3
--- /dev/null
+++ b/xmrig-cuda/src/crypto/common/Algorithm.h
@@ -0,0 +1,75 @@
+/* XMRig
+ * Copyright 2010      Jeff Garzik <jgarzik@pobox.com>
+ * Copyright 2012-2014 pooler      <pooler@litecoinpool.org>
+ * Copyright 2014      Lucas Jones <https://github.com/lucasjones>
+ * Copyright 2014-2016 Wolf9466    <https://github.com/OhGodAPet>
+ * Copyright 2016      Jay D Dee   <jayddee246@gmail.com>
+ * Copyright 2017-2018 XMR-Stak    <https://github.com/fireice-uk>, <https://github.com/psychocrypt>
+ * Copyright 2018      Lee Clagett <https://github.com/vtnerd>
+ * Copyright 2018-2019 SChernykh   <https://github.com/SChernykh>
+ * Copyright 2016-2019 XMRig       <https://github.com/xmrig>, <support@xmrig.com>
+ *
+ *   This program is free software: you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation, either version 3 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef XMRIG_ALGORITHM_H
+#define XMRIG_ALGORITHM_H
+
+
+#include <cstddef>
+#include <vector>
+
+
+namespace xmrig {
+
+
+class Algorithm
+{
+public:
+    enum Id : int {
+        INVALID = -1,
+		CN_0,
+        CN_1,
+        CN_2,
+        CN_BLUR,
+        MAX
+    };
+
+    inline Algorithm() = default;
+
+    inline const char *name() const                   { return "cn/blur"; }
+    inline Id id() const                              { return m_id; }
+
+    inline bool operator!=(Algorithm::Id id) const        { return m_id != id; }
+    inline bool operator!=(const Algorithm &other) const  { return m_id != other.m_id; }
+    inline bool operator==(Algorithm::Id id) const        { return m_id == id; }
+    inline bool operator==(const Algorithm &other) const  { return m_id == other.m_id; }
+    inline operator Algorithm::Id() const                 { return m_id; }
+
+    size_t l3() const
+    {
+        constexpr size_t oneMiB = 0x100000;
+        return oneMiB;
+    }
+
+private:
+    Id m_id = CN_BLUR;
+
+};
+
+
+} /* namespace xmrig */
+
+
+#endif /* XMRIG_ALGORITHM_H */
diff --git a/xmrig-cuda/src/cryptonight.h b/xmrig-cuda/src/cryptonight.h
new file mode 100644
index 0000000..ccc4f29
--- /dev/null
+++ b/xmrig-cuda/src/cryptonight.h
@@ -0,0 +1,85 @@
+/* XMRig
+ * Copyright 2010      Jeff Garzik <jgarzik@pobox.com>
+ * Copyright 2012-2014 pooler      <pooler@litecoinpool.org>
+ * Copyright 2014      Lucas Jones <https://github.com/lucasjones>
+ * Copyright 2014-2016 Wolf9466    <https://github.com/OhGodAPet>
+ * Copyright 2016      Jay D Dee   <jayddee246@gmail.com>
+ * Copyright 2017-2018 XMR-Stak    <https://github.com/fireice-uk>, <https://github.com/psychocrypt>
+ * Copyright 2018      Lee Clagett <https://github.com/vtnerd>
+ * Copyright 2018-2019 SChernykh   <https://github.com/SChernykh>
+ * Copyright 2019      Spudz76     <https://github.com/Spudz76>
+ * Copyright 2016-2019 XMRig       <https://github.com/xmrig>, <support@xmrig.com>
+ *
+ *   This program is free software: you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation, either version 3 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+
+#pragma once
+
+#include <cstdint>
+#include <cuda.h>
+
+
+struct nvid_ctx {
+    CUdevice cuDevice                   = 0;
+    CUcontext cuContext                 = nullptr;
+    CUmodule module                     = nullptr;
+    CUfunction kernel                   = nullptr;
+    uint64_t kernel_height              = 0;
+
+    int device_id                       = 0;
+    const char *device_name             = nullptr;
+    int device_arch[2]                  { 0,};
+    int device_mpcount                  = 0;
+    int device_blocks                   = 0;
+    int device_threads                  = 0;
+    int device_bfactor                  = 0;
+    int device_bsleep                   = 0;
+    int device_clockRate                = 0;
+    int device_memoryClockRate          = 0;
+    size_t device_memoryTotal           = 0;
+    size_t device_memoryFree            = 0;
+    int device_pciBusID                 = 0;
+    int device_pciDeviceID              = 0;
+    int device_pciDomainID              = 0;
+    uint32_t syncMode                   = 3;
+    bool ready                          = false;
+
+    uint32_t *d_input                   = nullptr;
+    uint32_t inputlen                   = 0;
+    uint32_t *d_result_count            = nullptr;
+    uint32_t *d_result_nonce            = nullptr;
+    uint32_t *d_long_state              = nullptr;
+    uint64_t d_scratchpads_size         = 0;
+    uint32_t *d_ctx_state               = nullptr;
+    uint32_t *d_ctx_state2              = nullptr;
+    uint32_t *d_ctx_a                   = nullptr;
+    uint32_t *d_ctx_b                   = nullptr;
+    uint32_t *d_ctx_key1                = nullptr;
+    uint32_t *d_ctx_key2                = nullptr;
+    uint32_t *d_ctx_text                = nullptr;
+
+    uint64_t extra_iters                = 0;
+};
+
+
+int cuda_get_devicecount();
+int cuda_get_runtime_version();
+int cuda_get_driver_version();
+int cuda_get_deviceinfo(nvid_ctx *ctx);
+int cryptonight_gpu_init(nvid_ctx *ctx);
+void cryptonight_extra_cpu_set_data(nvid_ctx *ctx, const void *data, size_t len);
+void cryptonight_extra_cpu_prepare(nvid_ctx *ctx, uint32_t startNonce);
+void cryptonight_gpu_hash(nvid_ctx *ctx, uint64_t height, uint32_t startNonce);
+void cryptonight_extra_cpu_final(nvid_ctx *ctx, uint32_t startNonce, uint64_t target, uint32_t *rescount, uint32_t *resnonce);
diff --git a/xmrig-cuda/src/cuda_aes.hpp b/xmrig-cuda/src/cuda_aes.hpp
new file mode 100644
index 0000000..e478600
--- /dev/null
+++ b/xmrig-cuda/src/cuda_aes.hpp
@@ -0,0 +1,305 @@
+
+#pragma once
+
+#include <stdint.h>
+
+#define N_COLS          4
+#define WPOLY           0x011b
+
+static __constant__ uint32_t d_t_fn[1024] =
+{
+	0xa56363c6U, 0x847c7cf8U, 0x997777eeU, 0x8d7b7bf6U,
+	0x0df2f2ffU, 0xbd6b6bd6U, 0xb16f6fdeU, 0x54c5c591U,
+	0x50303060U, 0x03010102U, 0xa96767ceU, 0x7d2b2b56U,
+	0x19fefee7U, 0x62d7d7b5U, 0xe6abab4dU, 0x9a7676ecU,
+	0x45caca8fU, 0x9d82821fU, 0x40c9c989U, 0x877d7dfaU,
+	0x15fafaefU, 0xeb5959b2U, 0xc947478eU, 0x0bf0f0fbU,
+	0xecadad41U, 0x67d4d4b3U, 0xfda2a25fU, 0xeaafaf45U,
+	0xbf9c9c23U, 0xf7a4a453U, 0x967272e4U, 0x5bc0c09bU,
+	0xc2b7b775U, 0x1cfdfde1U, 0xae93933dU, 0x6a26264cU,
+	0x5a36366cU, 0x413f3f7eU, 0x02f7f7f5U, 0x4fcccc83U,
+	0x5c343468U, 0xf4a5a551U, 0x34e5e5d1U, 0x08f1f1f9U,
+	0x937171e2U, 0x73d8d8abU, 0x53313162U, 0x3f15152aU,
+	0x0c040408U, 0x52c7c795U, 0x65232346U, 0x5ec3c39dU,
+	0x28181830U, 0xa1969637U, 0x0f05050aU, 0xb59a9a2fU,
+	0x0907070eU, 0x36121224U, 0x9b80801bU, 0x3de2e2dfU,
+	0x26ebebcdU, 0x6927274eU, 0xcdb2b27fU, 0x9f7575eaU,
+	0x1b090912U, 0x9e83831dU, 0x742c2c58U, 0x2e1a1a34U,
+	0x2d1b1b36U, 0xb26e6edcU, 0xee5a5ab4U, 0xfba0a05bU,
+	0xf65252a4U, 0x4d3b3b76U, 0x61d6d6b7U, 0xceb3b37dU,
+	0x7b292952U, 0x3ee3e3ddU, 0x712f2f5eU, 0x97848413U,
+	0xf55353a6U, 0x68d1d1b9U, 0x00000000U, 0x2cededc1U,
+	0x60202040U, 0x1ffcfce3U, 0xc8b1b179U, 0xed5b5bb6U,
+	0xbe6a6ad4U, 0x46cbcb8dU, 0xd9bebe67U, 0x4b393972U,
+	0xde4a4a94U, 0xd44c4c98U, 0xe85858b0U, 0x4acfcf85U,
+	0x6bd0d0bbU, 0x2aefefc5U, 0xe5aaaa4fU, 0x16fbfbedU,
+	0xc5434386U, 0xd74d4d9aU, 0x55333366U, 0x94858511U,
+	0xcf45458aU, 0x10f9f9e9U, 0x06020204U, 0x817f7ffeU,
+	0xf05050a0U, 0x443c3c78U, 0xba9f9f25U, 0xe3a8a84bU,
+	0xf35151a2U, 0xfea3a35dU, 0xc0404080U, 0x8a8f8f05U,
+	0xad92923fU, 0xbc9d9d21U, 0x48383870U, 0x04f5f5f1U,
+	0xdfbcbc63U, 0xc1b6b677U, 0x75dadaafU, 0x63212142U,
+	0x30101020U, 0x1affffe5U, 0x0ef3f3fdU, 0x6dd2d2bfU,
+	0x4ccdcd81U, 0x140c0c18U, 0x35131326U, 0x2fececc3U,
+	0xe15f5fbeU, 0xa2979735U, 0xcc444488U, 0x3917172eU,
+	0x57c4c493U, 0xf2a7a755U, 0x827e7efcU, 0x473d3d7aU,
+	0xac6464c8U, 0xe75d5dbaU, 0x2b191932U, 0x957373e6U,
+	0xa06060c0U, 0x98818119U, 0xd14f4f9eU, 0x7fdcdca3U,
+	0x66222244U, 0x7e2a2a54U, 0xab90903bU, 0x8388880bU,
+	0xca46468cU, 0x29eeeec7U, 0xd3b8b86bU, 0x3c141428U,
+	0x79dedea7U, 0xe25e5ebcU, 0x1d0b0b16U, 0x76dbdbadU,
+	0x3be0e0dbU, 0x56323264U, 0x4e3a3a74U, 0x1e0a0a14U,
+	0xdb494992U, 0x0a06060cU, 0x6c242448U, 0xe45c5cb8U,
+	0x5dc2c29fU, 0x6ed3d3bdU, 0xefacac43U, 0xa66262c4U,
+	0xa8919139U, 0xa4959531U, 0x37e4e4d3U, 0x8b7979f2U,
+	0x32e7e7d5U, 0x43c8c88bU, 0x5937376eU, 0xb76d6ddaU,
+	0x8c8d8d01U, 0x64d5d5b1U, 0xd24e4e9cU, 0xe0a9a949U,
+	0xb46c6cd8U, 0xfa5656acU, 0x07f4f4f3U, 0x25eaeacfU,
+	0xaf6565caU, 0x8e7a7af4U, 0xe9aeae47U, 0x18080810U,
+	0xd5baba6fU, 0x887878f0U, 0x6f25254aU, 0x722e2e5cU,
+	0x241c1c38U, 0xf1a6a657U, 0xc7b4b473U, 0x51c6c697U,
+	0x23e8e8cbU, 0x7cdddda1U, 0x9c7474e8U, 0x211f1f3eU,
+	0xdd4b4b96U, 0xdcbdbd61U, 0x868b8b0dU, 0x858a8a0fU,
+	0x907070e0U, 0x423e3e7cU, 0xc4b5b571U, 0xaa6666ccU,
+	0xd8484890U, 0x05030306U, 0x01f6f6f7U, 0x120e0e1cU,
+	0xa36161c2U, 0x5f35356aU, 0xf95757aeU, 0xd0b9b969U,
+	0x91868617U, 0x58c1c199U, 0x271d1d3aU, 0xb99e9e27U,
+	0x38e1e1d9U, 0x13f8f8ebU, 0xb398982bU, 0x33111122U,
+	0xbb6969d2U, 0x70d9d9a9U, 0x898e8e07U, 0xa7949433U,
+	0xb69b9b2dU, 0x221e1e3cU, 0x92878715U, 0x20e9e9c9U,
+	0x49cece87U, 0xff5555aaU, 0x78282850U, 0x7adfdfa5U,
+	0x8f8c8c03U, 0xf8a1a159U, 0x80898909U, 0x170d0d1aU,
+	0xdabfbf65U, 0x31e6e6d7U, 0xc6424284U, 0xb86868d0U,
+	0xc3414182U, 0xb0999929U, 0x772d2d5aU, 0x110f0f1eU,
+	0xcbb0b07bU, 0xfc5454a8U, 0xd6bbbb6dU, 0x3a16162cU,
+	0x6363c6a5U, 0x7c7cf884U, 0x7777ee99U, 0x7b7bf68dU,
+	0xf2f2ff0dU, 0x6b6bd6bdU, 0x6f6fdeb1U, 0xc5c59154U,
+	0x30306050U, 0x01010203U, 0x6767cea9U, 0x2b2b567dU,
+	0xfefee719U, 0xd7d7b562U, 0xabab4de6U, 0x7676ec9aU,
+	0xcaca8f45U, 0x82821f9dU, 0xc9c98940U, 0x7d7dfa87U,
+	0xfafaef15U, 0x5959b2ebU, 0x47478ec9U, 0xf0f0fb0bU,
+	0xadad41ecU, 0xd4d4b367U, 0xa2a25ffdU, 0xafaf45eaU,
+	0x9c9c23bfU, 0xa4a453f7U, 0x7272e496U, 0xc0c09b5bU,
+	0xb7b775c2U, 0xfdfde11cU, 0x93933daeU, 0x26264c6aU,
+	0x36366c5aU, 0x3f3f7e41U, 0xf7f7f502U, 0xcccc834fU,
+	0x3434685cU, 0xa5a551f4U, 0xe5e5d134U, 0xf1f1f908U,
+	0x7171e293U, 0xd8d8ab73U, 0x31316253U, 0x15152a3fU,
+	0x0404080cU, 0xc7c79552U, 0x23234665U, 0xc3c39d5eU,
+	0x18183028U, 0x969637a1U, 0x05050a0fU, 0x9a9a2fb5U,
+	0x07070e09U, 0x12122436U, 0x80801b9bU, 0xe2e2df3dU,
+	0xebebcd26U, 0x27274e69U, 0xb2b27fcdU, 0x7575ea9fU,
+	0x0909121bU, 0x83831d9eU, 0x2c2c5874U, 0x1a1a342eU,
+	0x1b1b362dU, 0x6e6edcb2U, 0x5a5ab4eeU, 0xa0a05bfbU,
+	0x5252a4f6U, 0x3b3b764dU, 0xd6d6b761U, 0xb3b37dceU,
+	0x2929527bU, 0xe3e3dd3eU, 0x2f2f5e71U, 0x84841397U,
+	0x5353a6f5U, 0xd1d1b968U, 0x00000000U, 0xededc12cU,
+	0x20204060U, 0xfcfce31fU, 0xb1b179c8U, 0x5b5bb6edU,
+	0x6a6ad4beU, 0xcbcb8d46U, 0xbebe67d9U, 0x3939724bU,
+	0x4a4a94deU, 0x4c4c98d4U, 0x5858b0e8U, 0xcfcf854aU,
+	0xd0d0bb6bU, 0xefefc52aU, 0xaaaa4fe5U, 0xfbfbed16U,
+	0x434386c5U, 0x4d4d9ad7U, 0x33336655U, 0x85851194U,
+	0x45458acfU, 0xf9f9e910U, 0x02020406U, 0x7f7ffe81U,
+	0x5050a0f0U, 0x3c3c7844U, 0x9f9f25baU, 0xa8a84be3U,
+	0x5151a2f3U, 0xa3a35dfeU, 0x404080c0U, 0x8f8f058aU,
+	0x92923fadU, 0x9d9d21bcU, 0x38387048U, 0xf5f5f104U,
+	0xbcbc63dfU, 0xb6b677c1U, 0xdadaaf75U, 0x21214263U,
+	0x10102030U, 0xffffe51aU, 0xf3f3fd0eU, 0xd2d2bf6dU,
+	0xcdcd814cU, 0x0c0c1814U, 0x13132635U, 0xececc32fU,
+	0x5f5fbee1U, 0x979735a2U, 0x444488ccU, 0x17172e39U,
+	0xc4c49357U, 0xa7a755f2U, 0x7e7efc82U, 0x3d3d7a47U,
+	0x6464c8acU, 0x5d5dbae7U, 0x1919322bU, 0x7373e695U,
+	0x6060c0a0U, 0x81811998U, 0x4f4f9ed1U, 0xdcdca37fU,
+	0x22224466U, 0x2a2a547eU, 0x90903babU, 0x88880b83U,
+	0x46468ccaU, 0xeeeec729U, 0xb8b86bd3U, 0x1414283cU,
+	0xdedea779U, 0x5e5ebce2U, 0x0b0b161dU, 0xdbdbad76U,
+	0xe0e0db3bU, 0x32326456U, 0x3a3a744eU, 0x0a0a141eU,
+	0x494992dbU, 0x06060c0aU, 0x2424486cU, 0x5c5cb8e4U,
+	0xc2c29f5dU, 0xd3d3bd6eU, 0xacac43efU, 0x6262c4a6U,
+	0x919139a8U, 0x959531a4U, 0xe4e4d337U, 0x7979f28bU,
+	0xe7e7d532U, 0xc8c88b43U, 0x37376e59U, 0x6d6ddab7U,
+	0x8d8d018cU, 0xd5d5b164U, 0x4e4e9cd2U, 0xa9a949e0U,
+	0x6c6cd8b4U, 0x5656acfaU, 0xf4f4f307U, 0xeaeacf25U,
+	0x6565caafU, 0x7a7af48eU, 0xaeae47e9U, 0x08081018U,
+	0xbaba6fd5U, 0x7878f088U, 0x25254a6fU, 0x2e2e5c72U,
+	0x1c1c3824U, 0xa6a657f1U, 0xb4b473c7U, 0xc6c69751U,
+	0xe8e8cb23U, 0xdddda17cU, 0x7474e89cU, 0x1f1f3e21U,
+	0x4b4b96ddU, 0xbdbd61dcU, 0x8b8b0d86U, 0x8a8a0f85U,
+	0x7070e090U, 0x3e3e7c42U, 0xb5b571c4U, 0x6666ccaaU,
+	0x484890d8U, 0x03030605U, 0xf6f6f701U, 0x0e0e1c12U,
+	0x6161c2a3U, 0x35356a5fU, 0x5757aef9U, 0xb9b969d0U,
+	0x86861791U, 0xc1c19958U, 0x1d1d3a27U, 0x9e9e27b9U,
+	0xe1e1d938U, 0xf8f8eb13U, 0x98982bb3U, 0x11112233U,
+	0x6969d2bbU, 0xd9d9a970U, 0x8e8e0789U, 0x949433a7U,
+	0x9b9b2db6U, 0x1e1e3c22U, 0x87871592U, 0xe9e9c920U,
+	0xcece8749U, 0x5555aaffU, 0x28285078U, 0xdfdfa57aU,
+	0x8c8c038fU, 0xa1a159f8U, 0x89890980U, 0x0d0d1a17U,
+	0xbfbf65daU, 0xe6e6d731U, 0x424284c6U, 0x6868d0b8U,
+	0x414182c3U, 0x999929b0U, 0x2d2d5a77U, 0x0f0f1e11U,
+	0xb0b07bcbU, 0x5454a8fcU, 0xbbbb6dd6U, 0x16162c3aU,
+	0x63c6a563U, 0x7cf8847cU, 0x77ee9977U, 0x7bf68d7bU,
+	0xf2ff0df2U, 0x6bd6bd6bU, 0x6fdeb16fU, 0xc59154c5U,
+	0x30605030U, 0x01020301U, 0x67cea967U, 0x2b567d2bU,
+	0xfee719feU, 0xd7b562d7U, 0xab4de6abU, 0x76ec9a76U,
+	0xca8f45caU, 0x821f9d82U, 0xc98940c9U, 0x7dfa877dU,
+	0xfaef15faU, 0x59b2eb59U, 0x478ec947U, 0xf0fb0bf0U,
+	0xad41ecadU, 0xd4b367d4U, 0xa25ffda2U, 0xaf45eaafU,
+	0x9c23bf9cU, 0xa453f7a4U, 0x72e49672U, 0xc09b5bc0U,
+	0xb775c2b7U, 0xfde11cfdU, 0x933dae93U, 0x264c6a26U,
+	0x366c5a36U, 0x3f7e413fU, 0xf7f502f7U, 0xcc834fccU,
+	0x34685c34U, 0xa551f4a5U, 0xe5d134e5U, 0xf1f908f1U,
+	0x71e29371U, 0xd8ab73d8U, 0x31625331U, 0x152a3f15U,
+	0x04080c04U, 0xc79552c7U, 0x23466523U, 0xc39d5ec3U,
+	0x18302818U, 0x9637a196U, 0x050a0f05U, 0x9a2fb59aU,
+	0x070e0907U, 0x12243612U, 0x801b9b80U, 0xe2df3de2U,
+	0xebcd26ebU, 0x274e6927U, 0xb27fcdb2U, 0x75ea9f75U,
+	0x09121b09U, 0x831d9e83U, 0x2c58742cU, 0x1a342e1aU,
+	0x1b362d1bU, 0x6edcb26eU, 0x5ab4ee5aU, 0xa05bfba0U,
+	0x52a4f652U, 0x3b764d3bU, 0xd6b761d6U, 0xb37dceb3U,
+	0x29527b29U, 0xe3dd3ee3U, 0x2f5e712fU, 0x84139784U,
+	0x53a6f553U, 0xd1b968d1U, 0x00000000U, 0xedc12cedU,
+	0x20406020U, 0xfce31ffcU, 0xb179c8b1U, 0x5bb6ed5bU,
+	0x6ad4be6aU, 0xcb8d46cbU, 0xbe67d9beU, 0x39724b39U,
+	0x4a94de4aU, 0x4c98d44cU, 0x58b0e858U, 0xcf854acfU,
+	0xd0bb6bd0U, 0xefc52aefU, 0xaa4fe5aaU, 0xfbed16fbU,
+	0x4386c543U, 0x4d9ad74dU, 0x33665533U, 0x85119485U,
+	0x458acf45U, 0xf9e910f9U, 0x02040602U, 0x7ffe817fU,
+	0x50a0f050U, 0x3c78443cU, 0x9f25ba9fU, 0xa84be3a8U,
+	0x51a2f351U, 0xa35dfea3U, 0x4080c040U, 0x8f058a8fU,
+	0x923fad92U, 0x9d21bc9dU, 0x38704838U, 0xf5f104f5U,
+	0xbc63dfbcU, 0xb677c1b6U, 0xdaaf75daU, 0x21426321U,
+	0x10203010U, 0xffe51affU, 0xf3fd0ef3U, 0xd2bf6dd2U,
+	0xcd814ccdU, 0x0c18140cU, 0x13263513U, 0xecc32fecU,
+	0x5fbee15fU, 0x9735a297U, 0x4488cc44U, 0x172e3917U,
+	0xc49357c4U, 0xa755f2a7U, 0x7efc827eU, 0x3d7a473dU,
+	0x64c8ac64U, 0x5dbae75dU, 0x19322b19U, 0x73e69573U,
+	0x60c0a060U, 0x81199881U, 0x4f9ed14fU, 0xdca37fdcU,
+	0x22446622U, 0x2a547e2aU, 0x903bab90U, 0x880b8388U,
+	0x468cca46U, 0xeec729eeU, 0xb86bd3b8U, 0x14283c14U,
+	0xdea779deU, 0x5ebce25eU, 0x0b161d0bU, 0xdbad76dbU,
+	0xe0db3be0U, 0x32645632U, 0x3a744e3aU, 0x0a141e0aU,
+	0x4992db49U, 0x060c0a06U, 0x24486c24U, 0x5cb8e45cU,
+	0xc29f5dc2U, 0xd3bd6ed3U, 0xac43efacU, 0x62c4a662U,
+	0x9139a891U, 0x9531a495U, 0xe4d337e4U, 0x79f28b79U,
+	0xe7d532e7U, 0xc88b43c8U, 0x376e5937U, 0x6ddab76dU,
+	0x8d018c8dU, 0xd5b164d5U, 0x4e9cd24eU, 0xa949e0a9U,
+	0x6cd8b46cU, 0x56acfa56U, 0xf4f307f4U, 0xeacf25eaU,
+	0x65caaf65U, 0x7af48e7aU, 0xae47e9aeU, 0x08101808U,
+	0xba6fd5baU, 0x78f08878U, 0x254a6f25U, 0x2e5c722eU,
+	0x1c38241cU, 0xa657f1a6U, 0xb473c7b4U, 0xc69751c6U,
+	0xe8cb23e8U, 0xdda17cddU, 0x74e89c74U, 0x1f3e211fU,
+	0x4b96dd4bU, 0xbd61dcbdU, 0x8b0d868bU, 0x8a0f858aU,
+	0x70e09070U, 0x3e7c423eU, 0xb571c4b5U, 0x66ccaa66U,
+	0x4890d848U, 0x03060503U, 0xf6f701f6U, 0x0e1c120eU,
+	0x61c2a361U, 0x356a5f35U, 0x57aef957U, 0xb969d0b9U,
+	0x86179186U, 0xc19958c1U, 0x1d3a271dU, 0x9e27b99eU,
+	0xe1d938e1U, 0xf8eb13f8U, 0x982bb398U, 0x11223311U,
+	0x69d2bb69U, 0xd9a970d9U, 0x8e07898eU, 0x9433a794U,
+	0x9b2db69bU, 0x1e3c221eU, 0x87159287U, 0xe9c920e9U,
+	0xce8749ceU, 0x55aaff55U, 0x28507828U, 0xdfa57adfU,
+	0x8c038f8cU, 0xa159f8a1U, 0x89098089U, 0x0d1a170dU,
+	0xbf65dabfU, 0xe6d731e6U, 0x4284c642U, 0x68d0b868U,
+	0x4182c341U, 0x9929b099U, 0x2d5a772dU, 0x0f1e110fU,
+	0xb07bcbb0U, 0x54a8fc54U, 0xbb6dd6bbU, 0x162c3a16U,
+	0xc6a56363U, 0xf8847c7cU, 0xee997777U, 0xf68d7b7bU,
+	0xff0df2f2U, 0xd6bd6b6bU, 0xdeb16f6fU, 0x9154c5c5U,
+	0x60503030U, 0x02030101U, 0xcea96767U, 0x567d2b2bU,
+	0xe719fefeU, 0xb562d7d7U, 0x4de6ababU, 0xec9a7676U,
+	0x8f45cacaU, 0x1f9d8282U, 0x8940c9c9U, 0xfa877d7dU,
+	0xef15fafaU, 0xb2eb5959U, 0x8ec94747U, 0xfb0bf0f0U,
+	0x41ecadadU, 0xb367d4d4U, 0x5ffda2a2U, 0x45eaafafU,
+	0x23bf9c9cU, 0x53f7a4a4U, 0xe4967272U, 0x9b5bc0c0U,
+	0x75c2b7b7U, 0xe11cfdfdU, 0x3dae9393U, 0x4c6a2626U,
+	0x6c5a3636U, 0x7e413f3fU, 0xf502f7f7U, 0x834fccccU,
+	0x685c3434U, 0x51f4a5a5U, 0xd134e5e5U, 0xf908f1f1U,
+	0xe2937171U, 0xab73d8d8U, 0x62533131U, 0x2a3f1515U,
+	0x080c0404U, 0x9552c7c7U, 0x46652323U, 0x9d5ec3c3U,
+	0x30281818U, 0x37a19696U, 0x0a0f0505U, 0x2fb59a9aU,
+	0x0e090707U, 0x24361212U, 0x1b9b8080U, 0xdf3de2e2U,
+	0xcd26ebebU, 0x4e692727U, 0x7fcdb2b2U, 0xea9f7575U,
+	0x121b0909U, 0x1d9e8383U, 0x58742c2cU, 0x342e1a1aU,
+	0x362d1b1bU, 0xdcb26e6eU, 0xb4ee5a5aU, 0x5bfba0a0U,
+	0xa4f65252U, 0x764d3b3bU, 0xb761d6d6U, 0x7dceb3b3U,
+	0x527b2929U, 0xdd3ee3e3U, 0x5e712f2fU, 0x13978484U,
+	0xa6f55353U, 0xb968d1d1U, 0x00000000U, 0xc12cededU,
+	0x40602020U, 0xe31ffcfcU, 0x79c8b1b1U, 0xb6ed5b5bU,
+	0xd4be6a6aU, 0x8d46cbcbU, 0x67d9bebeU, 0x724b3939U,
+	0x94de4a4aU, 0x98d44c4cU, 0xb0e85858U, 0x854acfcfU,
+	0xbb6bd0d0U, 0xc52aefefU, 0x4fe5aaaaU, 0xed16fbfbU,
+	0x86c54343U, 0x9ad74d4dU, 0x66553333U, 0x11948585U,
+	0x8acf4545U, 0xe910f9f9U, 0x04060202U, 0xfe817f7fU,
+	0xa0f05050U, 0x78443c3cU, 0x25ba9f9fU, 0x4be3a8a8U,
+	0xa2f35151U, 0x5dfea3a3U, 0x80c04040U, 0x058a8f8fU,
+	0x3fad9292U, 0x21bc9d9dU, 0x70483838U, 0xf104f5f5U,
+	0x63dfbcbcU, 0x77c1b6b6U, 0xaf75dadaU, 0x42632121U,
+	0x20301010U, 0xe51affffU, 0xfd0ef3f3U, 0xbf6dd2d2U,
+	0x814ccdcdU, 0x18140c0cU, 0x26351313U, 0xc32fececU,
+	0xbee15f5fU, 0x35a29797U, 0x88cc4444U, 0x2e391717U,
+	0x9357c4c4U, 0x55f2a7a7U, 0xfc827e7eU, 0x7a473d3dU,
+	0xc8ac6464U, 0xbae75d5dU, 0x322b1919U, 0xe6957373U,
+	0xc0a06060U, 0x19988181U, 0x9ed14f4fU, 0xa37fdcdcU,
+	0x44662222U, 0x547e2a2aU, 0x3bab9090U, 0x0b838888U,
+	0x8cca4646U, 0xc729eeeeU, 0x6bd3b8b8U, 0x283c1414U,
+	0xa779dedeU, 0xbce25e5eU, 0x161d0b0bU, 0xad76dbdbU,
+	0xdb3be0e0U, 0x64563232U, 0x744e3a3aU, 0x141e0a0aU,
+	0x92db4949U, 0x0c0a0606U, 0x486c2424U, 0xb8e45c5cU,
+	0x9f5dc2c2U, 0xbd6ed3d3U, 0x43efacacU, 0xc4a66262U,
+	0x39a89191U, 0x31a49595U, 0xd337e4e4U, 0xf28b7979U,
+	0xd532e7e7U, 0x8b43c8c8U, 0x6e593737U, 0xdab76d6dU,
+	0x018c8d8dU, 0xb164d5d5U, 0x9cd24e4eU, 0x49e0a9a9U,
+	0xd8b46c6cU, 0xacfa5656U, 0xf307f4f4U, 0xcf25eaeaU,
+	0xcaaf6565U, 0xf48e7a7aU, 0x47e9aeaeU, 0x10180808U,
+	0x6fd5babaU, 0xf0887878U, 0x4a6f2525U, 0x5c722e2eU,
+	0x38241c1cU, 0x57f1a6a6U, 0x73c7b4b4U, 0x9751c6c6U,
+	0xcb23e8e8U, 0xa17cddddU, 0xe89c7474U, 0x3e211f1fU,
+	0x96dd4b4bU, 0x61dcbdbdU, 0x0d868b8bU, 0x0f858a8aU,
+	0xe0907070U, 0x7c423e3eU, 0x71c4b5b5U, 0xccaa6666U,
+	0x90d84848U, 0x06050303U, 0xf701f6f6U, 0x1c120e0eU,
+	0xc2a36161U, 0x6a5f3535U, 0xaef95757U, 0x69d0b9b9U,
+	0x17918686U, 0x9958c1c1U, 0x3a271d1dU, 0x27b99e9eU,
+	0xd938e1e1U, 0xeb13f8f8U, 0x2bb39898U, 0x22331111U,
+	0xd2bb6969U, 0xa970d9d9U, 0x07898e8eU, 0x33a79494U,
+	0x2db69b9bU, 0x3c221e1eU, 0x15928787U, 0xc920e9e9U,
+	0x8749ceceU, 0xaaff5555U, 0x50782828U, 0xa57adfdfU,
+	0x038f8c8cU, 0x59f8a1a1U, 0x09808989U, 0x1a170d0dU,
+	0x65dabfbfU, 0xd731e6e6U, 0x84c64242U, 0xd0b86868U,
+	0x82c34141U, 0x29b09999U, 0x5a772d2dU, 0x1e110f0fU,
+	0x7bcbb0b0U, 0xa8fc5454U, 0x6dd6bbbbU, 0x2c3a1616U
+};
+
+#define t_fn0(x) (sharedMemory[      (x)])
+#define t_fn1(x) (sharedMemory[256 + (x)])
+#define t_fn2(x) (sharedMemory[512 + (x)])
+#define t_fn3(x) (sharedMemory[768 + (x)])
+
+
+#define round(dummy,y,x,k) \
+	y[0] = (k)[0]  ^ (t_fn0(x[0] & 0xff) ^ t_fn1((x[1] >> 8) & 0xff) ^ t_fn2((x[2] >> 16) & 0xff) ^ t_fn3((x[3] >> 24))); \
+	y[1] = (k)[1]  ^ (t_fn0(x[1] & 0xff) ^ t_fn1((x[2] >> 8) & 0xff) ^ t_fn2((x[3] >> 16) & 0xff) ^ t_fn3((x[0] >> 24))); \
+	y[2] = (k)[2]  ^ (t_fn0(x[2] & 0xff) ^ t_fn1((x[3] >> 8) & 0xff) ^ t_fn2((x[0] >> 16) & 0xff) ^ t_fn3((x[1] >> 24))); \
+	y[3] = (k)[3]  ^ (t_fn0(x[3] & 0xff) ^ t_fn1((x[0] >> 8) & 0xff) ^ t_fn2((x[1] >> 16) & 0xff) ^ t_fn3((x[2] >> 24) ));
+
+__device__ __forceinline__ static void cn_aes_single_round(uint32_t * __restrict__ sharedMemory, const uint32_t * __restrict__ in, uint32_t * __restrict__ out, const uint32_t * __restrict__ expandedKey)
+{
+	round(sharedMemory, out, in, expandedKey);
+}
+
+__device__ __forceinline__ static void cn_aes_pseudo_round_mut(const uint32_t * __restrict__ sharedMemory, uint32_t * __restrict__ val, const uint32_t * __restrict__ expandedKey)
+{
+	uint32_t b1[4];
+	round(sharedMemory, b1, val, expandedKey);
+	round(sharedMemory, val, b1, expandedKey + 1 * N_COLS);
+	round(sharedMemory, b1, val, expandedKey + 2 * N_COLS);
+	round(sharedMemory, val, b1, expandedKey + 3 * N_COLS);
+	round(sharedMemory, b1, val, expandedKey + 4 * N_COLS);
+	round(sharedMemory, val, b1, expandedKey + 5 * N_COLS);
+	round(sharedMemory, b1, val, expandedKey + 6 * N_COLS);
+	round(sharedMemory, val, b1, expandedKey + 7 * N_COLS);
+	round(sharedMemory, b1, val, expandedKey + 8 * N_COLS);
+	round(sharedMemory, val, b1, expandedKey + 9 * N_COLS);
+}
+
+__device__ __forceinline__ static void cn_aes_gpu_init(uint32_t *sharedMemory)
+{
+	for(int i = threadIdx.x; i < 1024; i += blockDim.x)
+		sharedMemory[i] = d_t_fn[i];
+}
diff --git a/xmrig-cuda/src/cuda_blake.hpp b/xmrig-cuda/src/cuda_blake.hpp
new file mode 100644
index 0000000..6fb2d3d
--- /dev/null
+++ b/xmrig-cuda/src/cuda_blake.hpp
@@ -0,0 +1,194 @@
+#pragma once
+
+typedef struct {
+	uint32_t h[8], s[4], t[2];
+	uint32_t buflen;
+	int nullt;
+	uint8_t buf[64];
+} blake_state;
+
+#define U8TO32(p) \
+	(((uint32_t)((p)[0]) << 24) | ((uint32_t)((p)[1]) << 16) | \
+	((uint32_t)((p)[2]) <<  8) | ((uint32_t)((p)[3])      ))
+
+#define U32TO8(p, v) \
+	(p)[0] = (uint8_t)((v) >> 24); (p)[1] = (uint8_t)((v) >> 16); \
+	(p)[2] = (uint8_t)((v) >>  8); (p)[3] = (uint8_t)((v)      );
+
+#define BLAKE_ROT(x,n) ROTR32(x, n)
+#define BLAKE_G(a,b,c,d,e) \
+	v[a] += (m[d_blake_sigma[i][e]] ^ d_blake_cst[d_blake_sigma[i][e+1]]) + v[b]; \
+	v[d] = BLAKE_ROT(v[d] ^ v[a],16); \
+	v[c] += v[d];                     \
+	v[b] = BLAKE_ROT(v[b] ^ v[c],12); \
+	v[a] += (m[d_blake_sigma[i][e+1]] ^ d_blake_cst[d_blake_sigma[i][e]])+v[b]; \
+	v[d] = BLAKE_ROT(v[d] ^ v[a], 8); \
+	v[c] += v[d];                     \
+	v[b] = BLAKE_ROT(v[b] ^ v[c], 7);
+
+__constant__ uint8_t d_blake_sigma[14][16] =
+{
+	{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15},
+	{14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3},
+	{11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4},
+	{7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8},
+	{9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13},
+	{2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9},
+	{12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11},
+	{13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10},
+	{6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5},
+	{10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0},
+	{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15},
+	{14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3},
+	{11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4},
+	{7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8}
+};
+__constant__ uint32_t d_blake_cst[16]
+= {
+	0x243F6A88, 0x85A308D3, 0x13198A2E, 0x03707344,
+	0xA4093822, 0x299F31D0, 0x082EFA98, 0xEC4E6C89,
+	0x452821E6, 0x38D01377, 0xBE5466CF, 0x34E90C6C,
+	0xC0AC29B7, 0xC97C50DD, 0x3F84D5B5, 0xB5470917
+};
+
+__device__ void cn_blake_compress(blake_state *S, const uint8_t *block)
+{
+	uint32_t v[16], m[16], i;
+
+	for (i = 0; i < 16; ++i) m[i] = U8TO32(block + i * 4);
+	for (i = 0; i < 8;  ++i) v[i] = S->h[i];
+	v[ 8] = S->s[0] ^ 0x243F6A88;
+	v[ 9] = S->s[1] ^ 0x85A308D3;
+	v[10] = S->s[2] ^ 0x13198A2E;
+	v[11] = S->s[3] ^ 0x03707344;
+	v[12] = 0xA4093822;
+	v[13] = 0x299F31D0;
+	v[14] = 0x082EFA98;
+	v[15] = 0xEC4E6C89;
+
+	if (S->nullt == 0)
+	{
+		v[12] ^= S->t[0];
+		v[13] ^= S->t[0];
+		v[14] ^= S->t[1];
+		v[15] ^= S->t[1];
+	}
+
+	for (i = 0; i < 14; ++i)
+	{
+		BLAKE_G(0, 4,  8, 12,  0);
+		BLAKE_G(1, 5,  9, 13,  2);
+		BLAKE_G(2, 6, 10, 14,  4);
+		BLAKE_G(3, 7, 11, 15,  6);
+		BLAKE_G(3, 4,  9, 14, 14);
+		BLAKE_G(2, 7,  8, 13, 12);
+		BLAKE_G(0, 5, 10, 15,  8);
+		BLAKE_G(1, 6, 11, 12, 10);
+	}
+
+	for (i = 0; i < 16; ++i) S->h[i % 8] ^= v[i];
+	for (i = 0; i < 8;  ++i) S->h[i] ^= S->s[i % 4];
+}
+
+__device__ void cn_blake_update(blake_state *S, const uint8_t *data, uint64_t datalen)
+{
+	uint32_t left = S->buflen >> 3;
+	uint32_t fill = 64 - left;
+
+	if (left && (((datalen >> 3) & 0x3F) >= fill))
+	{
+		memcpy((void *) (S->buf + left), (void *) data, fill);
+		S->t[0] += 512;
+		if (S->t[0] == 0) S->t[1]++;
+		cn_blake_compress(S, S->buf);
+		data += fill;
+		datalen -= (fill << 3);
+		left = 0;
+	}
+
+	while (datalen >= 512) 
+	{
+		S->t[0] += 512;
+		if (S->t[0] == 0) S->t[1]++;
+		cn_blake_compress(S, data);
+		data += 64;
+		datalen -= 512;
+	}
+
+	if (datalen > 0) 
+	{
+		memcpy((void *) (S->buf + left), (void *) data, datalen >> 3);
+		S->buflen = (left << 3) + datalen;
+	}
+	else 
+	{
+		S->buflen = 0;
+	}
+}
+
+__device__ void cn_blake_final(blake_state *S, uint8_t *digest)
+{
+	const uint8_t padding[] = 
+	{
+		0x80,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
+	};
+
+	uint8_t pa = 0x81, pb = 0x01;
+	uint8_t msglen[8];
+	uint32_t lo = S->t[0] + S->buflen, hi = S->t[1];
+	if (lo < (unsigned) S->buflen) hi++;
+	U32TO8(msglen + 0, hi);
+	U32TO8(msglen + 4, lo);
+
+	if (S->buflen == 440) 
+	{
+		S->t[0] -= 8;
+		cn_blake_update(S, &pa, 8);
+	} 
+	else 
+	{
+		if (S->buflen < 440) 
+		{
+			if (S->buflen == 0) S->nullt = 1;
+			S->t[0] -= 440 - S->buflen;
+			cn_blake_update(S, padding, 440 - S->buflen);
+		}
+		else 
+		{
+			S->t[0] -= 512 - S->buflen;
+			cn_blake_update(S, padding, 512 - S->buflen);
+			S->t[0] -= 440;
+			cn_blake_update(S, padding + 1, 440);
+			S->nullt = 1;
+		}
+		cn_blake_update(S, &pb, 8);
+		S->t[0] -= 8;
+	}
+	S->t[0] -= 64;
+	cn_blake_update(S, msglen, 64);
+
+	U32TO8(digest +  0, S->h[0]);
+	U32TO8(digest +  4, S->h[1]);
+	U32TO8(digest +  8, S->h[2]);
+	U32TO8(digest + 12, S->h[3]);
+	U32TO8(digest + 16, S->h[4]);
+	U32TO8(digest + 20, S->h[5]);
+	U32TO8(digest + 24, S->h[6]);
+	U32TO8(digest + 28, S->h[7]);
+}
+
+__device__ void cn_blake(const uint8_t *in, uint64_t inlen, uint8_t *out)
+{
+	blake_state bs;
+	blake_state *S = (blake_state *)&bs;
+
+	S->h[0] = 0x6A09E667; S->h[1] = 0xBB67AE85; S->h[2] = 0x3C6EF372;
+	S->h[3] = 0xA54FF53A; S->h[4] = 0x510E527F; S->h[5] = 0x9B05688C;
+	S->h[6] = 0x1F83D9AB; S->h[7] = 0x5BE0CD19;
+	S->t[0] = S->t[1] = S->buflen = S->nullt = 0;
+	S->s[0] = S->s[1] = S->s[2] = S->s[3] = 0;
+
+	cn_blake_update(S, in, inlen * 8);
+	cn_blake_final(S, out);
+}
diff --git a/xmrig-cuda/src/cuda_core.cu b/xmrig-cuda/src/cuda_core.cu
new file mode 100644
index 0000000..7653f4f
--- /dev/null
+++ b/xmrig-cuda/src/cuda_core.cu
@@ -0,0 +1,570 @@
+/* XMRig
+* Copyright 2010      Jeff Garzik <jgarzik@pobox.com>
+* Copyright 2012-2014 pooler      <pooler@litecoinpool.org>
+* Copyright 2014      Lucas Jones <https://github.com/lucasjones>
+* Copyright 2014-2016 Wolf9466    <https://github.com/OhGodAPet>
+* Copyright 2016      Jay D Dee   <jayddee246@gmail.com>
+* Copyright 2017-2018 XMR-Stak    <https://github.com/fireice-uk>, <https://github.com/psychocrypt>
+* Copyright 2018      Lee Clagett <https://github.com/vtnerd>
+* Copyright 2016-2018 XMRig       <https://github.com/xmrig>, <support@xmrig.com>
+*
+*   This program is free software: you can redistribute it and/or modify
+*   it under the terms of the GNU General Public License as published by
+*   the Free Software Foundation, either version 3 of the License, or
+*   (at your option) any later version.
+*
+*   This program is distributed in the hope that it will be useful,
+*   but WITHOUT ANY WARRANTY; without even the implied warranty of
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*   GNU General Public License for more details.
+*
+*   You should have received a copy of the GNU General Public License
+*   along with this program. If not, see <http://www.gnu.org/licenses/>.
+*/
+
+
+#include <stdio.h>
+#include <stdint.h>
+#include <string.h>
+#include <cuda.h>
+#include <cuda_runtime.h>
+#include "common/utils/timestamp.h"
+#include "crypto/cn/CnAlgo.h"
+
+#ifdef _WIN32
+#include <Windows.h>
+static void compat_usleep(int waitTime)
+{
+    if (waitTime > 0) {
+        if (waitTime > 100) {
+            // use a waitable timer for larger intervals > 0.1ms
+
+            HANDLE timer;
+            LARGE_INTEGER ft;
+
+            ft.QuadPart = -10ll * int64_t(waitTime); // Convert to 100 nanosecond interval, negative value indicates relative time
+
+            timer = CreateWaitableTimer(nullptr, TRUE, nullptr);
+            SetWaitableTimer(timer, &ft, 0, nullptr, nullptr, 0);
+            WaitForSingleObject(timer, INFINITE);
+            CloseHandle(timer);
+        } else {
+            // use a polling loop for short intervals <= 0.1ms
+
+            LARGE_INTEGER perfCnt, start, now;
+            int64_t elapsed;
+
+            QueryPerformanceFrequency(&perfCnt);
+            QueryPerformanceCounter(&start);
+            do {
+                SwitchToThread();
+                QueryPerformanceCounter(&now);
+                elapsed = static_cast<int64_t>(((now.QuadPart - start.QuadPart) / static_cast<float>(perfCnt.QuadPart) * 1000 * 1000));
+            } while (elapsed < static_cast<int64_t>(waitTime));
+        }
+    }
+}
+#else
+#include <unistd.h>
+static inline void compat_usleep(int waitTime)
+{
+    usleep(static_cast<uint64_t>(waitTime));
+}
+#endif
+
+#include "cryptonight.h"
+#include "cuda_extra.h"
+#include "cuda_aes.hpp"
+#include "cuda_device.hpp"
+#include "cuda_fast_int_math_v2.hpp"
+#include "cuda_fast_div_heavy.hpp"
+
+#if defined(__x86_64__) || defined(_M_AMD64) || defined(__LP64__)
+#   define _ASM_PTR_ "l"
+#else
+#   define _ASM_PTR_ "r"
+#endif
+
+/* sm_2X is limited to 2GB due to the small TLB
+ * therefore we never use 64bit indices
+ */
+#if defined(XMRIG_LARGEGRID) && (__CUDA_ARCH__ >= 300)
+typedef uint64_t IndexType;
+#else
+typedef int IndexType;
+#endif
+
+template< typename T >
+__device__ __forceinline__ T loadGlobal64( T * const addr )
+{
+#   if (__CUDA_ARCH__ < 700)
+    T x;
+    asm volatile( "ld.global.cg.u64 %0, [%1];" : "=l"( x ) : _ASM_PTR_(addr));
+    return x;
+#   else
+    return *addr;
+#   endif
+}
+
+template< typename T >
+__device__ __forceinline__ T loadGlobal32( T * const addr )
+{
+#   if (__CUDA_ARCH__ < 700)
+    T x;
+    asm volatile( "ld.global.cg.u32 %0, [%1];" : "=r"( x ) : _ASM_PTR_(addr));
+    return x;
+#   else
+    return *addr;
+#   endif
+}
+
+template< typename T >
+__device__ __forceinline__ void storeGlobal32( T* addr, T const & val )
+{
+#   if (__CUDA_ARCH__ < 700)
+    asm volatile( "st.global.cg.u32 [%0], %1;" : : _ASM_PTR_(addr), "r"( val ) );
+#   else
+    *addr = val;
+#   endif
+}
+
+template< typename T >
+__device__ __forceinline__ void storeGlobal64( T* addr, T const & val )
+{
+#   if (__CUDA_ARCH__ < 700)
+    asm volatile("st.global.cg.u64 [%0], %1;" : : _ASM_PTR_(addr), "l"(val));
+#   else
+    *addr = val;
+#   endif
+}
+
+template<size_t ITERATIONS, uint32_t MEM>
+__global__ void cryptonight_core_gpu_phase1( int threads, int bfactor, int partidx, uint32_t * __restrict__ long_state, uint32_t * __restrict__ ctx_state2, uint32_t * __restrict__ ctx_key1 )
+{
+    __shared__ uint32_t sharedMemory[1024];
+
+    cn_aes_gpu_init( sharedMemory );
+    __syncthreads( );
+
+    const int thread = ( blockDim.x * blockIdx.x + threadIdx.x ) >> 3;
+    const int sub = ( threadIdx.x & 7 ) << 2;
+
+    const int batchsize = MEM >> bfactor;
+    const int start = partidx * batchsize;
+    const int end = start + batchsize;
+
+    if ( thread >= threads )
+        return;
+
+    uint32_t key[40], text[4];
+
+    MEMCPY8( key, ctx_key1 + thread * 40, 20 );
+
+    if (partidx == 0) {
+        // first round
+        MEMCPY8( text, ctx_state2 + thread * 50 + sub + 16, 2 );
+    }
+    else {
+        // load previous text data
+        MEMCPY8( text, &long_state[( (uint64_t) thread * MEM) + sub + start - 32], 2 );
+    }
+
+    __syncthreads( );
+    for (int i = start; i < end; i += 32) {
+        cn_aes_pseudo_round_mut( sharedMemory, text, key );
+        MEMCPY8(&long_state[((uint64_t) thread * MEM) + (sub + i)], text, 2);
+    }
+}
+
+/** avoid warning `unused parameter` */
+template< typename T >
+__forceinline__ __device__ void unusedVar( const T& )
+{
+}
+
+/** shuffle data for
+ *
+ * - this method can be used with all compute architectures
+ * - for <sm_30 shared memory is needed
+ *
+ * group_n - must be a power of 2!
+ *
+ * @param ptr pointer to shared memory, size must be `threadIdx.x * sizeof(uint32_t)`
+ *            value can be NULL for compute architecture >=sm_30
+ * @param sub thread number within the group, range [0:group_n]
+ * @param value value to share with other threads within the group
+ * @param src thread number within the group from where the data is read, range [0:group_n]
+ */
+template<size_t group_n>
+__forceinline__ __device__ uint32_t shuffle(volatile uint32_t* ptr,const uint32_t sub,const int val,const uint32_t src)
+{
+#   if ( __CUDA_ARCH__ < 300 )
+    ptr[sub] = val;
+    return ptr[src & (group_n-1)];
+#   else
+    unusedVar( ptr );
+    unusedVar( sub );
+#   if (__CUDACC_VER_MAJOR__ >= 9)
+    return __shfl_sync(__activemask(), val, src, group_n);
+#   else
+    return __shfl( val, src, group_n );
+#   endif
+#   endif
+}
+
+
+template<size_t group_n>
+__forceinline__ __device__ uint64_t shuffle64(volatile uint32_t* ptr,const uint32_t sub,const int val,const uint32_t src, const uint32_t src2)
+{
+    uint64_t tmp;
+    ((uint32_t*)&tmp)[0] = shuffle<group_n>(ptr, sub, val, src);
+    ((uint32_t*)&tmp)[1] = shuffle<group_n>(ptr, sub, val, src2);
+    return tmp;
+}
+
+struct u64 : public uint2
+{
+
+    __forceinline__ __device__ u64(){}
+
+    __forceinline__ __device__ u64( const uint32_t x0, const uint32_t x1)
+    {
+        uint2::x = x0;
+        uint2::y = x1;
+    }
+
+    __forceinline__ __device__ operator uint64_t() const
+    {
+        return *((uint64_t*)this);
+    }
+
+    __forceinline__ __device__ u64( const uint64_t x0)
+    {
+        ((uint64_t*)&this->x)[0] = x0;
+    }
+
+    __forceinline__ __device__ u64 operator^=(const u64& other)
+    {
+        uint2::x ^= other.x;
+        uint2::y ^= other.y;
+
+        return *this;
+    }
+
+    __forceinline__ __device__ u64 operator+(const u64& other) const
+    {
+        u64 tmp;
+        ((uint64_t*)&tmp.x)[0] = ((uint64_t*)&(this->x))[0] + ((uint64_t*)&(other.x))[0];
+
+        return tmp;
+    }
+
+    __forceinline__ __device__ u64 operator+=(const uint64_t& other)
+    {
+        return ((uint64_t*)&this->x)[0] += other;
+    }
+
+    __forceinline__ __device__ void print(int i) const
+    {
+        if(i<2)
+            printf("gpu: %lu\n", ((uint64_t*)&this->x)[0]);
+    }
+};
+
+/** cryptonight with two threads per hash
+ */
+template<size_t ITERATIONS, uint32_t MEM, uint32_t MASK, xmrig::Algorithm::Id ALGO>
+#ifdef XMRIG_THREADS
+__launch_bounds__( XMRIG_THREADS * 2 )
+#endif
+__global__ void cryptonight_core_gpu_phase2_double(
+        int threads,
+        int bfactor,
+        int partidx,
+        uint32_t *d_long_state,
+        uint32_t *d_ctx_a,
+        uint32_t *d_ctx_b,
+        uint32_t * d_ctx_state,
+        uint32_t startNonce,
+        uint32_t * __restrict__ d_input,
+        uint64_t extra_iters
+        )
+{
+    using namespace xmrig;
+
+    __shared__ uint32_t sharedMemory[1024];
+
+    cn_aes_gpu_init( sharedMemory );
+
+#   if( __CUDA_ARCH__ < 300 )
+    extern __shared__ uint64_t externShared[];
+    // 8 x 64bit values
+    volatile uint64_t* myChunks = (volatile uint64_t*)(externShared + (threadIdx.x >> 1) * 8);
+    volatile uint32_t* sPtr = (volatile uint32_t*)(externShared + (blockDim.x >> 1) * 8)  + (threadIdx.x & 0xFFFFFFFE);
+#   else
+    extern __shared__ uint64_t chunkMem[];
+    volatile uint32_t* sPtr = NULL;
+    // 8 x 64bit values
+    volatile uint64_t* myChunks = (volatile uint64_t*)(chunkMem + (threadIdx.x >> 1) * 8);
+#   endif
+
+    __syncthreads( );
+
+    const uint64_t tid    = (blockDim.x * blockIdx.x + threadIdx.x);
+    const uint32_t thread = tid >> 1;
+    const uint32_t sub    = tid & 1;
+
+    if (thread >= threads) {
+        return;
+    }
+
+    uint8_t *l0              = (uint8_t*)&d_long_state[(IndexType) thread * MEM];
+    uint64_t ax0             = ((uint64_t*)(d_ctx_a + thread * 4))[sub];
+    uint32_t idx0            = shuffle<2>(sPtr, sub, static_cast<uint32_t>(ax0), 0);
+    uint64_t bx0             = ((uint64_t*)(d_ctx_b + thread * 16))[sub];
+    uint64_t bx1             = ((uint64_t*)(d_ctx_b + thread * 16 + 4))[sub];
+    uint64_t division_result = ((uint64_t*)(d_ctx_b + thread * 16 + 4 * 2))[0];
+    uint32_t sqrt_result     = (d_ctx_b + thread * 16 + 4 * 2 + 2)[0];
+
+    const int batchsize      = (((ITERATIONS + extra_iters) >> 1) * 2) >> ( 1 + bfactor );
+    const int start          = partidx * batchsize;
+    const int end            = start + batchsize;
+
+    uint64_t* ptr0;
+    for (int i = start; i < end; ++i) {
+        ptr0 = (uint64_t *)&l0[idx0 & (MASK - 0x30)];
+
+        ((ulonglong4*)myChunks)[sub] = ((ulonglong4*)ptr0)[sub];
+
+        uint32_t idx1 = (idx0 & 0x30) >> 3;
+        const u64 cx  = myChunks[ idx1 + sub ];
+        const u64 cx2 = myChunks[ idx1 + ((sub + 1) & 1) ];
+
+        u64 cx_aes = ax0 ^ u64(
+            t_fn0( cx.x & 0xff ) ^ t_fn1( (cx.y >> 8) & 0xff ) ^ t_fn2( (cx2.x >> 16) & 0xff ) ^ t_fn3( (cx2.y >> 24 ) ),
+            t_fn0( cx.y & 0xff ) ^ t_fn1( (cx2.x >> 8) & 0xff ) ^ t_fn2( (cx2.y >> 16) & 0xff ) ^ t_fn3( (cx.x >> 24 ) )
+        );
+
+        {
+            const uint64_t chunk1 = myChunks[idx1 ^ 2 + sub];
+            const uint64_t chunk2 = myChunks[idx1 ^ 4 + sub];
+            const uint64_t chunk3 = myChunks[idx1 ^ 6 + sub];
+
+#           if (__CUDACC_VER_MAJOR__ >= 9)
+            __syncwarp();
+#           else
+            __syncthreads();
+#           endif
+
+            myChunks[idx1 ^ 2 + sub] = chunk3 + bx1;
+            myChunks[idx1 ^ 4 + sub] = chunk1 + bx0;
+            myChunks[idx1 ^ 6 + sub] = chunk2 + ax0;
+        }
+
+        myChunks[idx1 + sub] = cx_aes ^ bx0;
+
+        ((ulonglong4*)ptr0)[sub] = ((ulonglong4*)myChunks)[sub];
+
+        idx0 = shuffle<2>(sPtr, sub, cx_aes.x, 0);
+        idx1 = (idx0 & 0x30) >> 3;
+        ptr0 = (uint64_t *)&l0[idx0 & MASK & (MASK - 0x30)];
+
+        ((ulonglong4*)myChunks)[sub] = ((ulonglong4*)ptr0)[sub];
+
+        uint64_t cx_mul;
+        ((uint32_t*)&cx_mul)[0] = shuffle<2>(sPtr, sub, cx_aes.x , 0);
+        ((uint32_t*)&cx_mul)[1] = shuffle<2>(sPtr, sub, cx_aes.y , 0);
+
+        if (sub == 1) {
+            // Use division and square root results from the _previous_ iteration to hide the latency
+            ((uint32_t*)&division_result)[1] ^= sqrt_result;
+            ((uint64_t*)myChunks)[idx1]      ^= division_result;
+
+            const uint32_t dd = (static_cast<uint32_t>(cx_mul) + (sqrt_result << 1)) | 0x80000001UL;
+            division_result = fast_div_v2(cx_aes, dd);
+
+            // Use division_result as an input for the square root to prevent parallel implementation in hardware
+            sqrt_result = fast_sqrt_v2(cx_mul + division_result);
+        }
+
+#       if (__CUDACC_VER_MAJOR__ >= 9)
+        __syncwarp();
+#       else
+        __syncthreads( );
+#       endif
+
+        uint64_t c = ((uint64_t*)myChunks)[idx1 + sub];
+
+        {
+            uint64_t cl = ((uint64_t*)myChunks)[idx1];
+            // sub 0 -> hi, sub 1 -> lo
+            uint64_t res = sub == 0 ? __umul64hi( cx_mul, cl ) : cx_mul * cl;
+
+            const uint64_t chunk1 = myChunks[ idx1 ^ 2 + sub ] ^ res;
+            uint64_t chunk2       = myChunks[ idx1 ^ 4 + sub ];
+            res ^= ((uint64_t*)&chunk2)[0];
+            const uint64_t chunk3 = myChunks[ idx1 ^ 6 + sub ];
+
+#           if (__CUDACC_VER_MAJOR__ >= 9)
+            __syncwarp();
+#           else
+            __syncthreads( );
+#           endif
+
+            myChunks[idx1 ^ 2 + sub] = chunk3 + bx1;
+            myChunks[idx1 ^ 4 + sub] = chunk1 + bx0;
+            myChunks[idx1 ^ 6 + sub] = chunk2 + ax0;
+
+            ax0 += res;
+        }
+
+        bx1 = bx0;
+        bx0 = cx_aes;
+
+        myChunks[idx1 + sub] = ax0;
+
+        ((ulonglong4*)ptr0)[sub] = ((ulonglong4*)myChunks)[sub];
+
+        ax0 ^= c;
+        idx0 = shuffle<2>(sPtr, sub, static_cast<uint32_t>(ax0), 0);
+    }
+
+    if (bfactor > 0) {
+        ((uint64_t*)(d_ctx_a + thread * 4))[sub]      = ax0;
+        ((uint64_t*)(d_ctx_b + thread * 16))[sub]     = bx0;
+        ((uint64_t*)(d_ctx_b + thread * 16 + 4))[sub] = bx1;
+
+        if (sub == 1) {
+            // must be valid only for `sub == 1`
+            ((uint64_t*)(d_ctx_b + thread * 16 + 4 * 2))[0] = division_result;
+            (d_ctx_b + thread * 16 + 4 * 2 + 2)[0]          = sqrt_result;
+        }
+    }
+}
+
+template<size_t ITERATIONS, uint32_t MEM, xmrig::Algorithm::Id ALGO>
+__global__ void cryptonight_core_gpu_phase3( int threads, int bfactor, int partidx, const uint32_t * __restrict__ long_state, uint32_t * __restrict__ d_ctx_state, uint32_t * __restrict__ d_ctx_key2 )
+{
+    using namespace xmrig;
+
+    __shared__ uint32_t sharedMemory[1024];
+
+    cn_aes_gpu_init( sharedMemory );
+    __syncthreads( );
+
+    int thread = ( blockDim.x * blockIdx.x + threadIdx.x ) >> 3;
+    int subv = ( threadIdx.x & 7 );
+    int sub = subv << 2;
+
+    const int batchsize = MEM >> bfactor;
+    const int start = (partidx % (1 << bfactor)) * batchsize;
+    const int end = start + batchsize;
+
+    if ( thread >= threads )
+        return;
+
+    uint32_t key[40], text[4];
+    MEMCPY8( key, d_ctx_key2 + thread * 40, 20 );
+    MEMCPY8( text, d_ctx_state + thread * 50 + sub + 16, 2 );
+
+    __syncthreads( );
+
+    for (int i = start; i < end; i += 32) {
+#pragma unroll
+        for (int j = 0; j < 4; ++j) {
+            text[j] ^= long_state[((IndexType) thread * MEM) + ( sub + i + j)];
+        }
+
+        cn_aes_pseudo_round_mut( sharedMemory, text, key );
+    }
+
+    MEMCPY8( d_ctx_state + thread * 50 + sub + 16, text, 2 );
+}
+
+template<xmrig::Algorithm::Id ALGO>
+void cryptonight_core_gpu_hash(nvid_ctx* ctx, uint32_t nonce)
+{
+    using namespace xmrig;
+
+    constexpr size_t MASK         = CnAlgo::CN_MASK;
+    constexpr size_t ITERATIONS   = CnAlgo::CN_ITER;
+    constexpr size_t MEM          = CnAlgo::CN_MEMORY / 4;
+
+    dim3 grid(ctx->device_blocks);
+    dim3 block(ctx->device_threads);
+    dim3 block2(ctx->device_threads << 1);
+    dim3 block4(ctx->device_threads << 2);
+    dim3 block8(ctx->device_threads << 3);
+
+    int partcount = 1 << ctx->device_bfactor;
+
+    /* bfactor for phase 1 and 3
+     *
+     * phase 1 and 3 consume less time than phase 2, therefore we begin with the
+     * kernel splitting if the user defined a `bfactor >= 5`
+     */
+    int bfactorOneThree = ctx->device_bfactor - 4;
+    if (bfactorOneThree < 0) {
+        bfactorOneThree = 0;
+    }
+
+    const int partcountOneThree = 1 << bfactorOneThree;
+    for (int i = 0; i < partcountOneThree; i++) {
+        CUDA_CHECK_KERNEL(ctx->device_id, cryptonight_core_gpu_phase1<ITERATIONS, MEM><<< grid, block8 >>>( ctx->device_blocks*ctx->device_threads,
+            bfactorOneThree, i,
+            ctx->d_long_state,
+            ctx->d_ctx_state,
+            ctx->d_ctx_key1));
+
+        if (partcount > 1 && ctx->device_bsleep > 0) {
+            compat_usleep(ctx->device_bsleep);
+        }
+    }
+
+    if (partcount > 1 && ctx->device_bsleep > 0) {
+        compat_usleep(ctx->device_bsleep);
+    }
+
+    for (int i = 0; i < partcount; i++) {
+        CUDA_CHECK_KERNEL(ctx->device_id, cryptonight_core_gpu_phase2_double<ITERATIONS, MEM, MASK, ALGO><<<
+            grid,
+            block2,
+            sizeof(uint64_t) * block.x * 8 + block.x * sizeof(uint32_t) * static_cast<int>(ctx->device_arch[0] < 3)
+        >>>(
+            ctx->device_blocks * ctx->device_threads,
+            ctx->device_bfactor,
+            i,
+            ctx->d_long_state,
+            ctx->d_ctx_a,
+            ctx->d_ctx_b,
+            ctx->d_ctx_state,
+            nonce,
+            ctx->d_input,
+            ctx->extra_iters
+            )
+        );
+
+        if (partcount > 1 && ctx->device_bsleep > 0) {
+            compat_usleep(ctx->device_bsleep);
+        }
+    }
+
+    const int roundsPhase3 = partcountOneThree;
+    for (int i = 0; i < roundsPhase3; i++) {
+        CUDA_CHECK_KERNEL(ctx->device_id, cryptonight_core_gpu_phase3<ITERATIONS, MEM, ALGO><<<
+            grid,
+            block8,
+            block8.x * sizeof(uint32_t) * static_cast< int >( ctx->device_arch[0] < 3 )
+        >>>( ctx->device_blocks*ctx->device_threads,
+            bfactorOneThree, i,
+            ctx->d_long_state,
+            ctx->d_ctx_state, ctx->d_ctx_key2));
+    }
+}
+
+void cryptonight_gpu_hash(nvid_ctx *ctx, uint64_t height, uint32_t startNonce)
+{
+    using namespace xmrig;
+
+    cryptonight_core_gpu_hash<Algorithm::CN_BLUR>(ctx, startNonce);
+}
diff --git a/xmrig-cuda/src/cuda_device.hpp b/xmrig-cuda/src/cuda_device.hpp
new file mode 100644
index 0000000..afa1ac7
--- /dev/null
+++ b/xmrig-cuda/src/cuda_device.hpp
@@ -0,0 +1,42 @@
+#pragma once
+
+#include <cuda_runtime.h>
+#include <stdexcept>
+#include <iostream>
+#include <string>
+
+
+#define CUDA_THROW(error) throw std::runtime_error(std::string("<") + __FUNCTION__ + ">:" + std::to_string(__LINE__) + " \"" + (error) + "\"")
+
+
+/** execute and check a CUDA api command
+*
+* @param id gpu id (thread id)
+* @param ... CUDA api command
+*/
+#define CUDA_CHECK(id, ...) {                                                                             \
+    cudaError_t error = __VA_ARGS__;                                                                      \
+    if (error != cudaSuccess){                                                                            \
+        CUDA_THROW(cudaGetErrorString(error));                                                            \
+    }                                                                                                     \
+}                                                                                                         \
+( (void) 0 )
+
+/** execute and check a CUDA kernel
+*
+* @param id gpu id (thread id)
+* @param ... CUDA kernel call
+*/
+#define CUDA_CHECK_KERNEL(id, ...)      \
+    __VA_ARGS__;                        \
+    CUDA_CHECK(id, cudaGetLastError())
+
+#define CU_CHECK(id, ...) {                                                                             \
+    CUresult result = __VA_ARGS__;                                                                      \
+    if(result != CUDA_SUCCESS){                                                                         \
+        const char* s;                                                                                  \
+        cuGetErrorString(result, &s);                                                                   \
+        CUDA_THROW(s ? s : "unknown error");                                                            \
+    }                                                                                                   \
+}                                                                                                       \
+( (void) 0 )
diff --git a/xmrig-cuda/src/cuda_extra.cu b/xmrig-cuda/src/cuda_extra.cu
new file mode 100644
index 0000000..3a3c50c
--- /dev/null
+++ b/xmrig-cuda/src/cuda_extra.cu
@@ -0,0 +1,588 @@
+/* XMRig
+ * Copyright 2010      Jeff Garzik <jgarzik@pobox.com>
+ * Copyright 2012-2014 pooler      <pooler@litecoinpool.org>
+ * Copyright 2014      Lucas Jones <https://github.com/lucasjones>
+ * Copyright 2014-2016 Wolf9466    <https://github.com/OhGodAPet>
+ * Copyright 2016      Jay D Dee   <jayddee246@gmail.com>
+ * Copyright 2017-2018 XMR-Stak    <https://github.com/fireice-uk>, <https://github.com/psychocrypt>
+ * Copyright 2018      Lee Clagett <https://github.com/vtnerd>
+ * Copyright 2018-2019 SChernykh   <https://github.com/SChernykh>
+ * Copyright 2019      Spudz76     <https://github.com/Spudz76>
+ * Copyright 2016-2019 XMRig       <https://github.com/xmrig>, <support@xmrig.com>
+ *
+ *   This program is free software: you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation, either version 3 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <algorithm>
+#include <stdio.h>
+#include <stdint.h>
+#include <string.h>
+#include <cuda.h>
+#include <cuda_runtime.h>
+
+typedef unsigned char BitSequence;
+typedef unsigned long long DataLength;
+
+#include "cryptonight.h"
+#include "cuda_extra.h"
+#include "cuda_keccak.hpp"
+#include "cuda_blake.hpp"
+#include "cuda_groestl.hpp"
+#include "cuda_jh.hpp"
+#include "cuda_skein.hpp"
+#include "cuda_device.hpp"
+#include "cuda_aes.hpp"
+#include "crypto/cn/CnAlgo.h"
+
+__constant__ uint8_t d_sub_byte[16][16] ={
+    {0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76 },
+    {0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0 },
+    {0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15 },
+    {0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75 },
+    {0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84 },
+    {0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf },
+    {0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8 },
+    {0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2 },
+    {0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73 },
+    {0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb },
+    {0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79 },
+    {0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08 },
+    {0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a },
+    {0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e },
+    {0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf },
+    {0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 }
+};
+
+__device__ __forceinline__ void cryptonight_aes_set_key( uint32_t * __restrict__ key, const uint32_t * __restrict__ data )
+{
+    int i, j;
+    uint8_t temp[4];
+    const uint32_t aes_gf[] = { 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36 };
+
+    MEMSET4( key, 0, 40 );
+    MEMCPY4( key, data, 8 );
+
+#pragma unroll
+    for ( i = 8; i < 40; i++ )
+    {
+        *(uint32_t *) temp = key[i - 1];
+        if ( i % 8 == 0 )
+        {
+            *(uint32_t *) temp = ROTR32( *(uint32_t *) temp, 8 );
+            for ( j = 0; j < 4; j++ )
+                temp[j] = d_sub_byte[( temp[j] >> 4 ) & 0x0f][temp[j] & 0x0f];
+            *(uint32_t *) temp ^= aes_gf[i / 8 - 1];
+        }
+        else
+        {
+            if ( i % 8 == 4 )
+            {
+#pragma unroll
+                for ( j = 0; j < 4; j++ )
+                    temp[j] = d_sub_byte[( temp[j] >> 4 ) & 0x0f][temp[j] & 0x0f];
+            }
+        }
+
+        key[i] = key[( i - 8 )] ^ *(uint32_t *) temp;
+    }
+}
+
+__device__ __forceinline__ void mix_and_propagate( uint32_t* state )
+{
+    uint32_t tmp0[4];
+    for(size_t x = 0; x < 4; ++x)
+        tmp0[x] = (state)[x];
+
+    // set destination [0,6]
+    for(size_t t = 0; t < 7; ++t)
+        for(size_t x = 0; x < 4; ++x)
+            (state + 4 * t)[x] = (state + 4 * t)[x] ^ (state + 4 * (t + 1))[x];
+
+    // set destination 7
+    for(size_t x = 0; x < 4; ++x)
+        (state + 4 * 7)[x] = (state + 4 * 7)[x] ^ tmp0[x];
+}
+
+
+__global__ void cryptonight_extra_gpu_prepare(
+        int threads,
+        uint32_t *__restrict__ d_input,
+        uint32_t len,
+        uint32_t startNonce,
+        uint32_t *__restrict__ d_ctx_state,
+        uint32_t *__restrict__ d_ctx_state2,
+        uint32_t *__restrict__ d_ctx_a,
+        uint32_t *__restrict__ d_ctx_b,
+        uint32_t *__restrict__ d_ctx_key1,
+        uint32_t *__restrict__ d_ctx_key2
+        )
+{
+    using namespace xmrig;
+
+    int thread = (blockDim.x * blockIdx.x + threadIdx.x);
+
+    if (thread >= threads) {
+        return;
+    }
+
+    uint32_t ctx_state[50];
+    uint32_t ctx_a[4];
+    uint32_t ctx_b[4];
+    uint32_t ctx_key1[40];
+    uint32_t ctx_key2[40];
+    uint32_t input[32];
+
+    memcpy(input, d_input, len);
+    uint32_t nonce = startNonce + thread;
+    for (int i = 0; i < sizeof (uint32_t ); ++i) {
+        (((char *)input) + 39)[i] = ((char*) (&nonce))[i]; //take care of pointer alignment
+    }
+
+    cn_keccak((uint8_t *) input, len, (uint8_t *) ctx_state);
+    cryptonight_aes_set_key(ctx_key1, ctx_state);
+    cryptonight_aes_set_key(ctx_key2, ctx_state + 8);
+
+    XOR_BLOCKS_DST(ctx_state, ctx_state + 8, ctx_a);
+    XOR_BLOCKS_DST(ctx_state + 4, ctx_state + 12, ctx_b);
+    memcpy(d_ctx_a + thread * 4, ctx_a, 4 * 4);
+
+    memcpy(d_ctx_b + thread * 16, ctx_b, 4 * 4);
+    // bx1
+    XOR_BLOCKS_DST(ctx_state + 16, ctx_state + 20, ctx_b);
+    memcpy(d_ctx_b + thread * 16 + 4, ctx_b, 4 * 4);
+    // division_result
+    memcpy(d_ctx_b + thread * 16 + 2 * 4, ctx_state + 24, 4 * 2);
+    // sqrt_result
+    memcpy(d_ctx_b + thread * 16 + 2 * 4 + 2, ctx_state + 26, 4 * 2);
+
+    memcpy(d_ctx_key1 + thread * 40, ctx_key1, 40 * 4);
+    memcpy(d_ctx_key2 + thread * 40, ctx_key2, 40 * 4);
+    memcpy(d_ctx_state + thread * 50, ctx_state, 50 * 4);
+}
+
+
+__global__ void cryptonight_extra_gpu_final( int threads, uint64_t target, uint32_t* __restrict__ d_res_count, uint32_t * __restrict__ d_res_nonce, uint32_t * __restrict__ d_ctx_state,uint32_t * __restrict__ d_ctx_key2 )
+{
+    using namespace xmrig;
+
+    const int thread = blockDim.x * blockIdx.x + threadIdx.x;
+
+    if ( thread >= threads )
+        return;
+
+    int i;
+    uint32_t * __restrict__ ctx_state = d_ctx_state + thread * 50;
+    uint64_t hash[4];
+    uint32_t state[50];
+
+    #pragma unroll
+    for ( i = 0; i < 50; i++ )
+        state[i] = ctx_state[i];
+
+    cn_keccakf2( (uint64_t *) state );
+
+    switch ( ( (uint8_t *) state )[0] & 0x03 )
+    {
+    case 0:
+        cn_blake( (const uint8_t *) state, 200, (uint8_t *) hash );
+        break;
+    case 1:
+        cn_groestl( (const BitSequence *) state, 200, (BitSequence *) hash );
+        break;
+    case 2:
+        cn_jh( (const BitSequence *) state, 200, (BitSequence *) hash );
+        break;
+    case 3:
+        cn_skein( (const BitSequence *) state, 200, (BitSequence *) hash );
+        break;
+    default:
+        break;
+    }
+
+    // Note that comparison is equivalent to subtraction - we can't just compare 8 32-bit values
+    // and expect an accurate result for target > 32-bit without implementing carries
+    if (hash[3] < target) {
+        uint32_t idx = atomicInc(d_res_count, 0xFFFFFFFF);
+
+        if (idx < 10) {
+            d_res_nonce[idx] = thread;
+        }
+    }
+}
+
+__global__ void cryptonight_gpu_extra_gpu_final( int threads, uint64_t target, uint32_t* __restrict__ d_res_count, uint32_t * __restrict__ d_res_nonce, uint32_t * __restrict__ d_ctx_state,uint32_t * __restrict__ d_ctx_key2 )
+{
+	const int thread = blockDim.x * blockIdx.x + threadIdx.x;
+
+	__shared__ uint32_t sharedMemory[1024];
+
+	cn_aes_gpu_init( sharedMemory );
+	__syncthreads( );
+
+	if ( thread >= threads )
+		return;
+
+	int i;
+	uint32_t * __restrict__ ctx_state = d_ctx_state + thread * 50;
+	uint32_t state[50];
+
+	#pragma unroll
+	for ( i = 0; i < 50; i++ )
+		state[i] = ctx_state[i];
+
+	uint32_t key[40];
+
+	// load keys
+	MEMCPY8( key, d_ctx_key2 + thread * 40, 20 );
+
+	for(int i=0; i < 16; i++)
+	{
+		for(size_t t = 4; t < 12; ++t)
+		{
+			cn_aes_pseudo_round_mut( sharedMemory, state + 4u * t, key );
+		}
+		// scipt first 4 * 128bit blocks = 4 * 4 uint32_t values
+		mix_and_propagate(state + 4 * 4);
+	}
+
+	cn_keccakf2( (uint64_t *) state );
+
+	if ( ((uint64_t*)state)[3] < target )
+	{
+		uint32_t idx = atomicInc( d_res_count, 0xFFFFFFFF );
+
+		if(idx < 10)
+			d_res_nonce[idx] = thread;
+	}
+}
+
+void cryptonight_extra_cpu_set_data(nvid_ctx *ctx, const void *data, size_t len)
+{
+    ctx->inputlen = static_cast<unsigned int>(len);
+    CUDA_CHECK(ctx->device_id, cudaMemcpy(ctx->d_input, data, len, cudaMemcpyHostToDevice));
+}
+
+
+int cryptonight_extra_cpu_init(nvid_ctx *ctx, size_t hashMemSize)
+{
+    using namespace xmrig;
+
+    CU_CHECK(ctx->device_id, cuDeviceGet(&ctx->cuDevice, ctx->device_id));
+    CU_CHECK(ctx->device_id, cuCtxCreate(&ctx->cuContext, 0, ctx->cuDevice));
+
+    cudaError_t err;
+    err = cudaSetDevice(ctx->device_id);
+    if (err != cudaSuccess) {
+        printf("GPU %d: %s", ctx->device_id, cudaGetErrorString(err));
+        return 0;
+    }
+
+    CUDA_CHECK(ctx->device_id, cudaDeviceReset());
+    const unsigned int device_flags = cudaDeviceMapHost;
+    switch (ctx->syncMode)
+    {
+    case 0:
+        CUDA_CHECK(ctx->device_id, cudaSetDeviceFlags(device_flags | cudaDeviceScheduleAuto));
+        break;
+    case 1:
+        CUDA_CHECK(ctx->device_id, cudaSetDeviceFlags(device_flags | cudaDeviceScheduleSpin));
+        break;
+    case 2:
+        CUDA_CHECK(ctx->device_id, cudaSetDeviceFlags(device_flags | cudaDeviceScheduleYield));
+        break;
+    default:
+        CUDA_CHECK(ctx->device_id, cudaSetDeviceFlags(device_flags | cudaDeviceScheduleBlockingSync));
+        break;
+    };
+
+    CUDA_CHECK(ctx->device_id, cudaDeviceSetCacheConfig(cudaFuncCachePreferShared));
+
+    size_t wsize = ctx->device_blocks * ctx->device_threads;
+    CUDA_CHECK(ctx->device_id, cudaMalloc(&ctx->d_ctx_state, 50 * sizeof(uint32_t) * wsize));
+    size_t ctx_b_size = 4 * sizeof(uint32_t) * wsize;
+
+    {
+        ctx_b_size *= 4;
+        ctx->d_ctx_state2 = ctx->d_ctx_state;
+    }
+
+    // POW block format http://monero.wikia.com/wiki/PoW_Block_Header_Format
+    CUDA_CHECK(ctx->device_id, cudaMalloc(&ctx->d_input,        32 * sizeof (uint32_t)));
+    CUDA_CHECK(ctx->device_id, cudaMalloc(&ctx->d_result_count, sizeof (uint32_t)));
+    CUDA_CHECK(ctx->device_id, cudaMalloc(&ctx->d_result_nonce, 10 * sizeof (uint32_t)));
+
+    // Allocate buffers for Cryptonight
+    if (hashMemSize) {
+        CUDA_CHECK(ctx->device_id, cudaMalloc(&ctx->d_ctx_key1, 40 * sizeof(uint32_t) * wsize));
+        CUDA_CHECK(ctx->device_id, cudaMalloc(&ctx->d_ctx_key2, 40 * sizeof(uint32_t) * wsize));
+        CUDA_CHECK(ctx->device_id, cudaMalloc(&ctx->d_ctx_text, 32 * sizeof(uint32_t) * wsize));
+        CUDA_CHECK(ctx->device_id, cudaMalloc(&ctx->d_ctx_a, 4 * sizeof(uint32_t) * wsize));
+        CUDA_CHECK(ctx->device_id, cudaMalloc(&ctx->d_ctx_b, ctx_b_size));
+        ctx->d_scratchpads_size = hashMemSize * wsize;
+        CUDA_CHECK(ctx->device_id, cudaMalloc(&ctx->d_long_state, ctx->d_scratchpads_size));
+    }
+
+    ctx->ready = true;
+    return 1;
+}
+
+
+void cryptonight_extra_cpu_prepare(nvid_ctx *ctx, uint32_t startNonce)
+{
+    using namespace xmrig;
+
+    int threadsperblock = 128;
+    uint32_t wsize = ctx->device_blocks * ctx->device_threads;
+
+    dim3 grid((wsize + threadsperblock - 1) / threadsperblock);
+    dim3 block(threadsperblock);
+
+    /* pass two times d_ctx_state because the second state is used later in phase1,
+     * the first is used than in phase3
+     */
+    CUDA_CHECK_KERNEL(ctx->device_id, cryptonight_extra_gpu_prepare<<<grid, block >>>(wsize, ctx->d_input, ctx->inputlen, startNonce,
+        ctx->d_ctx_state, ctx->d_ctx_state2, ctx->d_ctx_a, ctx->d_ctx_b, ctx->d_ctx_key1, ctx->d_ctx_key2));
+}
+
+void cryptonight_extra_cpu_final(nvid_ctx *ctx, uint32_t startNonce, uint64_t target, uint32_t *rescount, uint32_t *resnonce)
+{
+    using namespace xmrig;
+
+    int threadsperblock = 128;
+    uint32_t wsize = ctx->device_blocks * ctx->device_threads;
+
+    dim3 grid( ( wsize + threadsperblock - 1 ) / threadsperblock );
+    dim3 block( threadsperblock );
+
+    CUDA_CHECK(ctx->device_id, cudaMemset(ctx->d_result_nonce, 0xFF, 10 * sizeof(uint32_t)));
+    CUDA_CHECK(ctx->device_id, cudaMemset(ctx->d_result_count, 0, sizeof(uint32_t)));
+    CUDA_CHECK_KERNEL(ctx->device_id, cryptonight_extra_gpu_final<< <grid, block >> > (wsize, target, ctx->d_result_count, ctx->d_result_nonce, ctx->d_ctx_state, ctx->d_ctx_key2));
+
+    CUDA_CHECK(ctx->device_id, cudaMemcpy(rescount, ctx->d_result_count, sizeof(uint32_t), cudaMemcpyDeviceToHost));
+    CUDA_CHECK(ctx->device_id, cudaMemcpy(resnonce, ctx->d_result_nonce, 10 * sizeof(uint32_t), cudaMemcpyDeviceToHost));
+
+    /* There is only a 32bit limit for the counter on the device side
+    * therefore this value can be greater than 10, in that case limit rescount
+    * to 10 entries.
+    */
+    if (*rescount > 10) {
+        *rescount = 10;
+    }
+
+    for (uint32_t i = 0; i < *rescount; i++) {
+        resnonce[i] += startNonce;
+    }
+}
+
+int cuda_get_devicecount()
+{
+    int deviceCount = 0;
+    if (cudaGetDeviceCount(&deviceCount) == cudaSuccess) {
+        return deviceCount;
+    }
+
+    return 0;
+}
+
+int cuda_get_runtime_version()
+{
+    int version = 0;
+    if (cudaRuntimeGetVersion(&version) == cudaSuccess) {
+        return version;
+    }
+
+    return 0;
+}
+
+int cuda_get_driver_version()
+{
+    int version = 0;
+    if (cudaDriverGetVersion(&version) == cudaSuccess) {
+        return version;
+    }
+
+    return 0;
+}
+
+/** get device information
+ *
+ * @return 0 = all OK,
+ *         1 = something went wrong,
+ *         2 = gpu cannot be selected,
+ *         3 = context cannot be created
+ *         4 = not enough memory
+ *         5 = architecture not supported (not compiled for the gpu architecture)
+ */
+int cuda_get_deviceinfo(nvid_ctx *ctx)
+{
+    using namespace xmrig;
+
+    const int version = cuda_get_driver_version();
+    if (!version) {
+        return 1;
+    }
+
+    if (version < CUDART_VERSION) {
+        printf("Driver does not support CUDA %d.%d API! Update your nVidia driver!\n", CUDART_VERSION / 1000, (CUDART_VERSION % 1000) / 10);
+        return 1;
+    }
+
+    const int GPU_N = cuda_get_devicecount();
+    if (GPU_N == 0) {
+        return 1;
+    }
+
+    if (ctx->device_id >= GPU_N) {
+        printf("Invalid device ID!\n");
+        return 1;
+    }
+
+    // a device must be selected to get the right memory usage later on
+    if (cudaSetDevice(ctx->device_id) != cudaSuccess) {
+        printf("WARNING: NVIDIA GPU %d: cannot be selected.\n", ctx->device_id);
+        return 2;
+    }
+
+    // trigger that a context on the gpu will be allocated
+    int* tmp;
+    if (cudaMalloc(&tmp, 256) != cudaSuccess) {
+        printf("WARNING: NVIDIA GPU %d: context cannot be created.\n", ctx->device_id);
+        return 3;
+    }
+
+    size_t freeMemory  = 0;
+    size_t totalMemory = 0;
+
+    CUDA_CHECK(ctx->device_id, cudaMemGetInfo(&freeMemory, &totalMemory));
+    CUDA_CHECK(ctx->device_id, cudaFree(tmp));
+    CUDA_CHECK(ctx->device_id, cudaDeviceReset());
+    ctx->device_memoryFree = freeMemory;
+    ctx->device_memoryTotal = totalMemory;
+
+    cudaDeviceProp props;
+    cudaError_t err = cudaGetDeviceProperties(&props, ctx->device_id);
+    if (err != cudaSuccess) {
+        printf("\nGPU %d: %s\n%s line %d\n", ctx->device_id, cudaGetErrorString(err), __FUNCTION__, __LINE__);
+        return 1;
+    }
+
+    ctx->device_name            = strdup(props.name);
+    ctx->device_mpcount         = props.multiProcessorCount;
+    ctx->device_arch[0]         = props.major;
+    ctx->device_arch[1]         = props.minor;
+    ctx->device_clockRate       = props.clockRate;
+    ctx->device_memoryClockRate = props.memoryClockRate;
+    ctx->device_pciBusID        = props.pciBusID;
+    ctx->device_pciDeviceID     = props.pciDeviceID;
+    ctx->device_pciDomainID     = props.pciDomainID;
+
+    // set all device option those marked as auto (-1) to a valid value
+    if (ctx->device_blocks < 0) {
+        /* good values based of my experience
+         *   - 3 * SMX count >=sm_30
+         *   - 2 * SMX count for <sm_30
+         */
+        ctx->device_blocks = props.multiProcessorCount * (props.major < 3 ? 2 : 3);
+
+        // increase bfactor for low end devices to avoid that the miner is killed by the OS
+#       ifdef _WIN32
+        if (props.multiProcessorCount <= 6 && ctx->device_bfactor == 6) {
+            ctx->device_bfactor = 8;
+        }
+#       endif
+    }
+
+    if (ctx->device_threads < 0) {
+        /* sm_20 devices can only run 512 threads per cuda block
+        * `cryptonight_core_gpu_phase1` and `cryptonight_core_gpu_phase3` starts
+        * `8 * ctx->device_threads` threads per block
+        */
+        ctx->device_threads = 64;
+        constexpr size_t byteToMiB = 1024u * 1024u;
+
+        // no limit by default 1TiB
+        size_t maxMemUsage = byteToMiB * byteToMiB;
+        if (props.major == 6) {
+            if (props.multiProcessorCount < 15) {
+                // limit memory usage for GPUs for pascal < GTX1070
+                maxMemUsage = size_t(2048u) * byteToMiB;
+            }
+            else if (props.multiProcessorCount <= 20) {
+                // limit memory usage for GPUs for pascal GTX1070, GTX1080
+                maxMemUsage = size_t(4096u) * byteToMiB;
+            }
+        }
+
+        if (props.major < 6) {
+            // limit memory usage for GPUs before pascal
+            maxMemUsage = size_t(2048u) * byteToMiB;
+        }
+
+        if (props.major == 2) {
+            // limit memory usage for sm 20 GPUs
+            maxMemUsage = size_t(1024u) * byteToMiB;
+        }
+
+        const size_t hashMemSize = 0x100000;
+#       ifdef _WIN32
+        /* We use in windows bfactor (split slow kernel into smaller parts) to avoid
+        * that windows is killing long running kernel.
+        * In the case there is already memory used on the gpu than we
+        * assume that other application are running between the split kernel,
+        * this can result into TLB memory flushes and can strongly reduce the performance
+        * and the result can be that windows is killing the miner.
+        * Be reducing maxMemUsage we try to avoid this effect.
+        */
+        size_t usedMem = totalMemory - freeMemory;
+        if (usedMem >= maxMemUsage) {
+            printf("WARNING: NVIDIA GPU %d: already %zu MiB memory in use, skip GPU.\n", ctx->device_id, usedMem / byteToMiB);
+
+            return 4;
+        }
+        else {
+            maxMemUsage -= usedMem;
+        }
+#       endif
+
+        // keep 128MiB memory free (value is randomly chosen)
+        // 200byte are meta data memory (result nonce, ...)
+        const size_t availableMem  = freeMemory - (128u * byteToMiB) - 200u;
+        const size_t limitedMemory = std::min(availableMem, maxMemUsage);
+        // up to 16kibyte extra memory is used per thread for some kernel (lmem/local memory)
+        // 680bytes are extra meta data memory per hash
+        size_t perThread = hashMemSize + 16192u + 680u;
+
+        ctx->device_threads = ((limitedMemory / perThread) / ctx->device_blocks) & 0xFFFFFFFE;
+
+        // 4 based on my test maybe it must be adjusted later
+        size_t threads = 4;
+        // 8 is chosen by checking the occupancy calculator
+        size_t blockOptimal = 8 * ctx->device_mpcount;
+
+        if (blockOptimal * threads * hashMemSize < limitedMemory) {
+            ctx->device_threads = threads;
+            ctx->device_blocks = blockOptimal;
+        }
+
+        ctx->device_threads = std::min(ctx->device_threads, (props.major == 2 ? 64 : 128));
+    }
+
+    return 0;
+}
+
+
+int cryptonight_gpu_init(nvid_ctx *ctx)
+{
+    return cryptonight_extra_cpu_init(ctx, xmrig::CnAlgo::CN_MEMORY);
+}
diff --git a/xmrig-cuda/src/cuda_extra.h b/xmrig-cuda/src/cuda_extra.h
new file mode 100644
index 0000000..352c26c
--- /dev/null
+++ b/xmrig-cuda/src/cuda_extra.h
@@ -0,0 +1,102 @@
+#pragma once
+
+#ifdef __INTELLISENSE__
+#define __CUDA_ARCH__ 520
+/* avoid red underlining */
+
+struct uint3
+{
+	unsigned int x, y, z;
+};
+
+struct uint3  threadIdx;
+struct uint3  blockIdx;
+struct uint3  blockDim;
+#define __funnelshift_r(a,b,c) 1
+#define __syncthreads()
+#define asm(x)
+#define __shfl(a,b,c) 1
+#endif
+
+#define AES_BLOCK_SIZE  16
+#define AES_KEY_SIZE    32
+#define INIT_SIZE_BLK   8
+#define INIT_SIZE_BYTE (INIT_SIZE_BLK * AES_BLOCK_SIZE) // 128 B
+
+#define C32(x)    ((uint32_t)(x ## U))
+#define T32(x) ((x) & C32(0xFFFFFFFF))
+
+#if __CUDA_ARCH__ >= 350
+__forceinline__ __device__ uint64_t cuda_ROTL64(const uint64_t value, const int offset)
+{
+	uint2 result;
+	if(offset >= 32)
+	{
+		asm("shf.l.wrap.b32 %0, %1, %2, %3;" : "=r"(result.x) : "r"(__double2loint(__longlong_as_double(value))), "r"(__double2hiint(__longlong_as_double(value))), "r"(offset));
+		asm("shf.l.wrap.b32 %0, %1, %2, %3;" : "=r"(result.y) : "r"(__double2hiint(__longlong_as_double(value))), "r"(__double2loint(__longlong_as_double(value))), "r"(offset));
+	} 
+	else 
+	{
+		asm("shf.l.wrap.b32 %0, %1, %2, %3;" : "=r"(result.x) : "r"(__double2hiint(__longlong_as_double(value))), "r"(__double2loint(__longlong_as_double(value))), "r"(offset));
+		asm("shf.l.wrap.b32 %0, %1, %2, %3;" : "=r"(result.y) : "r"(__double2loint(__longlong_as_double(value))), "r"(__double2hiint(__longlong_as_double(value))), "r"(offset));
+	}
+	return  __double_as_longlong(__hiloint2double(result.y, result.x));
+}
+#define ROTL64(x, n) (cuda_ROTL64(x, n))
+#else
+#define ROTL64(x, n)        (((x) << (n)) | ((x) >> (64 - (n))))
+#endif
+
+#if __CUDA_ARCH__ < 350
+#define ROTL32(x, n) T32(((x) << (n)) | ((x) >> (32 - (n))))
+#define ROTR32(x, n) (((x) >> (n)) | ((x) << (32 - (n))))
+#else
+#define ROTL32(x, n) __funnelshift_l( (x), (x), (n) )
+#define ROTR32(x, n) __funnelshift_r( (x), (x), (n) )
+#endif
+
+#define MEMSET8(dst,what,cnt) { \
+	int i_memset8; \
+	uint64_t *out_memset8 = (uint64_t *)(dst); \
+	for( i_memset8 = 0; i_memset8 < cnt; i_memset8++ ) \
+		out_memset8[i_memset8] = (what); }
+
+#define MEMSET4(dst,what,cnt) { \
+	int i_memset4; \
+	uint32_t *out_memset4 = (uint32_t *)(dst); \
+	for( i_memset4 = 0; i_memset4 < cnt; i_memset4++ ) \
+		out_memset4[i_memset4] = (what); }
+
+#define MEMCPY8(dst,src,cnt) { \
+	int i_memcpy8; \
+	uint64_t *in_memcpy8 = (uint64_t *)(src); \
+	uint64_t *out_memcpy8 = (uint64_t *)(dst); \
+	for( i_memcpy8 = 0; i_memcpy8 < cnt; i_memcpy8++ ) \
+		out_memcpy8[i_memcpy8] = in_memcpy8[i_memcpy8]; }
+
+#define MEMCPY4(dst,src,cnt) { \
+	int i_memcpy4; \
+	uint32_t *in_memcpy4 = (uint32_t *)(src); \
+	uint32_t *out_memcpy4 = (uint32_t *)(dst); \
+	for( i_memcpy4 = 0; i_memcpy4 < cnt; i_memcpy4++ ) \
+		out_memcpy4[i_memcpy4] = in_memcpy4[i_memcpy4]; }
+
+#define XOR_BLOCKS(a,b) { \
+	((uint64_t *)a)[0] ^= ((uint64_t *)b)[0]; \
+	((uint64_t *)a)[1] ^= ((uint64_t *)b)[1]; }
+
+#define XOR_BLOCKS_DST(x,y,z) { \
+	((uint64_t *)z)[0] = ((uint64_t *)(x))[0] ^ ((uint64_t *)(y))[0]; \
+	((uint64_t *)z)[1] = ((uint64_t *)(x))[1] ^ ((uint64_t *)(y))[1]; }
+
+#define MUL_SUM_XOR_DST(a,c,dst) { \
+	const uint64_t dst0 = ((uint64_t *)dst)[0]; \
+	uint64_t hi, lo = cuda_mul128(((uint64_t *)a)[0], dst0, &hi) + ((uint64_t *)c)[1]; \
+	hi += ((uint64_t *)c)[0]; \
+	((uint64_t *)c)[0] = dst0 ^ hi; \
+	((uint64_t *)dst)[0] = hi; \
+	((uint64_t *)c)[1] = atomicExch(((unsigned long long int *)dst) + 1, (unsigned long long int)lo) ^ lo; \
+	}
+
+#define E2I(x) ((size_t)(((*((uint64_t*)(x)) >> 4) & 0x1ffff)))
+
diff --git a/xmrig-cuda/src/cuda_fast_div_heavy.hpp b/xmrig-cuda/src/cuda_fast_div_heavy.hpp
new file mode 100644
index 0000000..6b1730a
--- /dev/null
+++ b/xmrig-cuda/src/cuda_fast_div_heavy.hpp
@@ -0,0 +1,26 @@
+#pragma once
+
+#include <stdint.h>
+
+__device__ __forceinline__ uint64_t fast_div_heavy(int64_t _a, int32_t _b)
+{
+	int64_t a = abs(_a);
+	int32_t b = abs(_b);
+
+	float rcp;
+	asm("rcp.approx.f32 %0, %1;" : "=f"(rcp) : "f"(__int2float_rn(b)));
+	float rcp2 = __uint_as_float(__float_as_uint(rcp) + (32U << 23));
+
+	uint64_t q1 = __float2ull_rd(__int2float_rn(((int32_t*)&a)[1]) * rcp2);
+	a -= q1 * (uint32_t)(b);
+
+	rcp2 = __uint_as_float(__float_as_uint(rcp) + (12U << 23));
+	int64_t q2 = __float2ll_rn(__int2float_rn(a >> 12) * rcp2);
+	int32_t a2 = ((int32_t*)&a)[0] - ((int32_t*)&q2)[0] * b;
+
+	int32_t q3 = __float2int_rn(__int2float_rn(a2) * rcp);
+	q3 += (a2 - q3 * b) >> 31;
+
+	const int64_t q = q1 + q2 + q3;
+	return ((((int32_t*)&_a)[1] ^ _b) < 0) ? -q : q;
+}
diff --git a/xmrig-cuda/src/cuda_fast_int_math_v2.hpp b/xmrig-cuda/src/cuda_fast_int_math_v2.hpp
new file mode 100644
index 0000000..f357076
--- /dev/null
+++ b/xmrig-cuda/src/cuda_fast_int_math_v2.hpp
@@ -0,0 +1,61 @@
+#pragma once
+
+#include <stdint.h>
+
+__device__ __forceinline__ uint32_t get_reciprocal(uint32_t a)
+{
+	const float a_hi = __uint_as_float((a >> 8) + ((126U + 31U) << 23));
+	const float a_lo = __uint2float_rn(a & 0xFF);
+
+	float r;
+	asm("rcp.approx.f32 %0, %1;" : "=f"(r) : "f"(a_hi));
+	const float r_scaled = __uint_as_float(__float_as_uint(r) + (64U << 23));
+
+	const float h = __fmaf_rn(a_lo, r, __fmaf_rn(a_hi, r, -1.0f));
+	return (__float_as_uint(r) << 9) - __float2int_rn(h * r_scaled);
+}
+
+__device__ __forceinline__ uint64_t fast_div_v2(uint64_t a, uint32_t b)
+{
+	const uint32_t r = get_reciprocal(b);
+	const uint64_t k = __umulhi(((uint32_t*)&a)[0], r) + ((uint64_t)(r) * ((uint32_t*)&a)[1]) + a;
+
+	uint32_t q[2];
+	q[0] = ((uint32_t*)&k)[1];
+
+	int64_t tmp = a - (uint64_t)(q[0]) * b;
+	((int32_t*)(&tmp))[1] -= (k < a) ? b : 0;
+
+	const bool overshoot = ((int32_t*)(&tmp))[1] < 0;
+	const bool undershoot = tmp >= b;
+
+	q[0] += (undershoot ? 1U : 0U) - (overshoot ? 1U : 0U);
+	q[1] = ((uint32_t*)(&tmp))[0] + (overshoot ? b : 0U) - (undershoot ? b : 0U);
+
+	return *((uint64_t*)(q));
+}
+
+__device__ __forceinline__ uint32_t fast_sqrt_v2(const uint64_t n1)
+{
+	float x = __uint_as_float((((uint32_t*)&n1)[1] >> 9) + ((64U + 127U) << 23));
+	float x1;
+	asm("rsqrt.approx.f32 %0, %1;" : "=f"(x1) : "f"(x));
+	asm("sqrt.approx.f32 %0, %1;" : "=f"(x) : "f"(x));
+
+	// The following line does x1 *= 4294967296.0f;
+	x1 = __uint_as_float(__float_as_uint(x1) + (32U << 23));
+
+	const uint32_t x0 = __float_as_uint(x) - (158U << 23);
+	const int64_t delta0 = n1 - (((int64_t)(x0) * x0) << 18);
+	const float delta = __int2float_rn(((int32_t*)&delta0)[1]) * x1;
+
+	uint32_t result = (x0 << 10) + __float2int_rn(delta);
+	const uint32_t s = result >> 1;
+	const uint32_t b = result & 1;
+
+	const uint64_t x2 = (uint64_t)(s) * (s + b) + ((uint64_t)(result) << 32) - n1;
+	if ((int64_t)(x2 + b) > 0) --result;
+	if ((int64_t)(x2 + 0x100000000UL + s) < 0) ++result;
+
+	return result;
+}
diff --git a/xmrig-cuda/src/cuda_groestl.hpp b/xmrig-cuda/src/cuda_groestl.hpp
new file mode 100644
index 0000000..a37934c
--- /dev/null
+++ b/xmrig-cuda/src/cuda_groestl.hpp
@@ -0,0 +1,357 @@
+#pragma once
+
+#define GROESTL_ROWS 8
+#define GROESTL_LENGTHFIELDLEN GROESTL_ROWS
+#define GROESTL_COLS512 8
+
+#define GROESTL_SIZE512 (GROESTL_ROWS*GROESTL_COLS512)
+
+#define GROESTL_ROUNDS512 10
+#define GROESTL_HASH_BIT_LEN 256
+
+#define GROESTL_ROTL32(v, n) ROTL32(v, n)
+
+
+#define li_32(h) 0x##h##u
+#define GROESTL_EXT_BYTE(var,n) ((uint8_t)((uint32_t)(var) >> (8*n)))
+
+#define u32BIG(a)	\
+	((GROESTL_ROTL32(a,8) & li_32(00FF00FF)) | (GROESTL_ROTL32(a,24) & li_32(FF00FF00)))
+
+typedef struct {
+	uint32_t chaining[GROESTL_SIZE512/sizeof(uint32_t)];            /* actual state */
+	uint32_t block_counter1,
+	block_counter2;         /* message block counter(s) */
+	BitSequence buffer[GROESTL_SIZE512];      /* data buffer */
+	int buf_ptr;              /* data buffer pointer */
+	int bits_in_last_byte;    /* no. of message bits in last byte of data buffer */
+} groestlHashState;
+
+
+__constant__ uint32_t d_groestl_T[512] =
+{
+  0xa5f432c6, 0xc6a597f4, 0x84976ff8, 0xf884eb97, 0x99b05eee, 0xee99c7b0, 0x8d8c7af6, 0xf68df78c, 0xd17e8ff, 0xff0de517, 0xbddc0ad6, 0xd6bdb7dc, 0xb1c816de, 0xdeb1a7c8, 0x54fc6d91, 0x915439fc
+, 0x50f09060, 0x6050c0f0, 0x3050702, 0x2030405, 0xa9e02ece, 0xcea987e0, 0x7d87d156, 0x567dac87, 0x192bcce7, 0xe719d52b, 0x62a613b5, 0xb56271a6, 0xe6317c4d, 0x4de69a31, 0x9ab559ec, 0xec9ac3b5
+, 0x45cf408f, 0x8f4505cf, 0x9dbca31f, 0x1f9d3ebc, 0x40c04989, 0x894009c0, 0x879268fa, 0xfa87ef92, 0x153fd0ef, 0xef15c53f, 0xeb2694b2, 0xb2eb7f26, 0xc940ce8e, 0x8ec90740, 0xb1de6fb, 0xfb0bed1d
+, 0xec2f6e41, 0x41ec822f, 0x67a91ab3, 0xb3677da9, 0xfd1c435f, 0x5ffdbe1c, 0xea256045, 0x45ea8a25, 0xbfdaf923, 0x23bf46da, 0xf7025153, 0x53f7a602, 0x96a145e4, 0xe496d3a1, 0x5bed769b, 0x9b5b2ded
+, 0xc25d2875, 0x75c2ea5d, 0x1c24c5e1, 0xe11cd924, 0xaee9d43d, 0x3dae7ae9, 0x6abef24c, 0x4c6a98be, 0x5aee826c, 0x6c5ad8ee, 0x41c3bd7e, 0x7e41fcc3, 0x206f3f5, 0xf502f106, 0x4fd15283, 0x834f1dd1
+, 0x5ce48c68, 0x685cd0e4, 0xf4075651, 0x51f4a207, 0x345c8dd1, 0xd134b95c, 0x818e1f9, 0xf908e918, 0x93ae4ce2, 0xe293dfae, 0x73953eab, 0xab734d95, 0x53f59762, 0x6253c4f5, 0x3f416b2a, 0x2a3f5441
+, 0xc141c08, 0x80c1014, 0x52f66395, 0x955231f6, 0x65afe946, 0x46658caf, 0x5ee27f9d, 0x9d5e21e2, 0x28784830, 0x30286078, 0xa1f8cf37, 0x37a16ef8, 0xf111b0a, 0xa0f1411, 0xb5c4eb2f, 0x2fb55ec4
+, 0x91b150e, 0xe091c1b, 0x365a7e24, 0x2436485a, 0x9bb6ad1b, 0x1b9b36b6, 0x3d4798df, 0xdf3da547, 0x266aa7cd, 0xcd26816a, 0x69bbf54e, 0x4e699cbb, 0xcd4c337f, 0x7fcdfe4c, 0x9fba50ea, 0xea9fcfba
+, 0x1b2d3f12, 0x121b242d, 0x9eb9a41d, 0x1d9e3ab9, 0x749cc458, 0x5874b09c, 0x2e724634, 0x342e6872, 0x2d774136, 0x362d6c77, 0xb2cd11dc, 0xdcb2a3cd, 0xee299db4, 0xb4ee7329, 0xfb164d5b, 0x5bfbb616
+, 0xf601a5a4, 0xa4f65301, 0x4dd7a176, 0x764decd7, 0x61a314b7, 0xb76175a3, 0xce49347d, 0x7dcefa49, 0x7b8ddf52, 0x527ba48d, 0x3e429fdd, 0xdd3ea142, 0x7193cd5e, 0x5e71bc93, 0x97a2b113, 0x139726a2
+, 0xf504a2a6, 0xa6f55704, 0x68b801b9, 0xb96869b8, 0x0, 0x0, 0x2c74b5c1, 0xc12c9974, 0x60a0e040, 0x406080a0, 0x1f21c2e3, 0xe31fdd21, 0xc8433a79, 0x79c8f243, 0xed2c9ab6, 0xb6ed772c
+, 0xbed90dd4, 0xd4beb3d9, 0x46ca478d, 0x8d4601ca, 0xd9701767, 0x67d9ce70, 0x4bddaf72, 0x724be4dd, 0xde79ed94, 0x94de3379, 0xd467ff98, 0x98d42b67, 0xe82393b0, 0xb0e87b23, 0x4ade5b85, 0x854a11de
+, 0x6bbd06bb, 0xbb6b6dbd, 0x2a7ebbc5, 0xc52a917e, 0xe5347b4f, 0x4fe59e34, 0x163ad7ed, 0xed16c13a, 0xc554d286, 0x86c51754, 0xd762f89a, 0x9ad72f62, 0x55ff9966, 0x6655ccff, 0x94a7b611, 0x119422a7
+, 0xcf4ac08a, 0x8acf0f4a, 0x1030d9e9, 0xe910c930, 0x60a0e04, 0x406080a, 0x819866fe, 0xfe81e798, 0xf00baba0, 0xa0f05b0b, 0x44ccb478, 0x7844f0cc, 0xbad5f025, 0x25ba4ad5, 0xe33e754b, 0x4be3963e
+, 0xf30eaca2, 0xa2f35f0e, 0xfe19445d, 0x5dfeba19, 0xc05bdb80, 0x80c01b5b, 0x8a858005, 0x58a0a85, 0xadecd33f, 0x3fad7eec, 0xbcdffe21, 0x21bc42df, 0x48d8a870, 0x7048e0d8, 0x40cfdf1, 0xf104f90c
+, 0xdf7a1963, 0x63dfc67a, 0xc1582f77, 0x77c1ee58, 0x759f30af, 0xaf75459f, 0x63a5e742, 0x426384a5, 0x30507020, 0x20304050, 0x1a2ecbe5, 0xe51ad12e, 0xe12effd, 0xfd0ee112, 0x6db708bf, 0xbf6d65b7
+, 0x4cd45581, 0x814c19d4, 0x143c2418, 0x1814303c, 0x355f7926, 0x26354c5f, 0x2f71b2c3, 0xc32f9d71, 0xe13886be, 0xbee16738, 0xa2fdc835, 0x35a26afd, 0xcc4fc788, 0x88cc0b4f, 0x394b652e, 0x2e395c4b
+, 0x57f96a93, 0x93573df9, 0xf20d5855, 0x55f2aa0d, 0x829d61fc, 0xfc82e39d, 0x47c9b37a, 0x7a47f4c9, 0xacef27c8, 0xc8ac8bef, 0xe73288ba, 0xbae76f32, 0x2b7d4f32, 0x322b647d, 0x95a442e6, 0xe695d7a4
+, 0xa0fb3bc0, 0xc0a09bfb, 0x98b3aa19, 0x199832b3, 0xd168f69e, 0x9ed12768, 0x7f8122a3, 0xa37f5d81, 0x66aaee44, 0x446688aa, 0x7e82d654, 0x547ea882, 0xabe6dd3b, 0x3bab76e6, 0x839e950b, 0xb83169e
+, 0xca45c98c, 0x8cca0345, 0x297bbcc7, 0xc729957b, 0xd36e056b, 0x6bd3d66e, 0x3c446c28, 0x283c5044, 0x798b2ca7, 0xa779558b, 0xe23d81bc, 0xbce2633d, 0x1d273116, 0x161d2c27, 0x769a37ad, 0xad76419a
+, 0x3b4d96db, 0xdb3bad4d, 0x56fa9e64, 0x6456c8fa, 0x4ed2a674, 0x744ee8d2, 0x1e223614, 0x141e2822, 0xdb76e492, 0x92db3f76, 0xa1e120c, 0xc0a181e, 0x6cb4fc48, 0x486c90b4, 0xe4378fb8, 0xb8e46b37
+, 0x5de7789f, 0x9f5d25e7, 0x6eb20fbd, 0xbd6e61b2, 0xef2a6943, 0x43ef862a, 0xa6f135c4, 0xc4a693f1, 0xa8e3da39, 0x39a872e3, 0xa4f7c631, 0x31a462f7, 0x37598ad3, 0xd337bd59, 0x8b8674f2, 0xf28bff86
+, 0x325683d5, 0xd532b156, 0x43c54e8b, 0x8b430dc5, 0x59eb856e, 0x6e59dceb, 0xb7c218da, 0xdab7afc2, 0x8c8f8e01, 0x18c028f, 0x64ac1db1, 0xb16479ac, 0xd26df19c, 0x9cd2236d, 0xe03b7249, 0x49e0923b
+, 0xb4c71fd8, 0xd8b4abc7, 0xfa15b9ac, 0xacfa4315, 0x709faf3, 0xf307fd09, 0x256fa0cf, 0xcf25856f, 0xafea20ca, 0xcaaf8fea, 0x8e897df4, 0xf48ef389, 0xe9206747, 0x47e98e20, 0x18283810, 0x10182028
+, 0xd5640b6f, 0x6fd5de64, 0x888373f0, 0xf088fb83, 0x6fb1fb4a, 0x4a6f94b1, 0x7296ca5c, 0x5c72b896, 0x246c5438, 0x3824706c, 0xf1085f57, 0x57f1ae08, 0xc7522173, 0x73c7e652, 0x51f36497, 0x975135f3
+, 0x2365aecb, 0xcb238d65, 0x7c8425a1, 0xa17c5984, 0x9cbf57e8, 0xe89ccbbf, 0x21635d3e, 0x3e217c63, 0xdd7cea96, 0x96dd377c, 0xdc7f1e61, 0x61dcc27f, 0x86919c0d, 0xd861a91, 0x85949b0f, 0xf851e94
+, 0x90ab4be0, 0xe090dbab, 0x42c6ba7c, 0x7c42f8c6, 0xc4572671, 0x71c4e257, 0xaae529cc, 0xccaa83e5, 0xd873e390, 0x90d83b73, 0x50f0906, 0x6050c0f, 0x103f4f7, 0xf701f503, 0x12362a1c, 0x1c123836
+, 0xa3fe3cc2, 0xc2a39ffe, 0x5fe18b6a, 0x6a5fd4e1, 0xf910beae, 0xaef94710, 0xd06b0269, 0x69d0d26b, 0x91a8bf17, 0x17912ea8, 0x58e87199, 0x995829e8, 0x2769533a, 0x3a277469, 0xb9d0f727, 0x27b94ed0
+, 0x384891d9, 0xd938a948, 0x1335deeb, 0xeb13cd35, 0xb3cee52b, 0x2bb356ce, 0x33557722, 0x22334455, 0xbbd604d2, 0xd2bbbfd6, 0x709039a9, 0xa9704990, 0x89808707, 0x7890e80, 0xa7f2c133, 0x33a766f2
+, 0xb6c1ec2d, 0x2db65ac1, 0x22665a3c, 0x3c227866, 0x92adb815, 0x15922aad, 0x2060a9c9, 0xc9208960, 0x49db5c87, 0x874915db, 0xff1ab0aa, 0xaaff4f1a, 0x7888d850, 0x5078a088, 0x7a8e2ba5, 0xa57a518e
+, 0x8f8a8903, 0x38f068a, 0xf8134a59, 0x59f8b213, 0x809b9209, 0x980129b, 0x1739231a, 0x1a173439, 0xda751065, 0x65daca75, 0x315384d7, 0xd731b553, 0xc651d584, 0x84c61351, 0xb8d303d0, 0xd0b8bbd3
+, 0xc35edc82, 0x82c31f5e, 0xb0cbe229, 0x29b052cb, 0x7799c35a, 0x5a77b499, 0x11332d1e, 0x1e113c33, 0xcb463d7b, 0x7bcbf646, 0xfc1fb7a8, 0xa8fc4b1f, 0xd6610c6d, 0x6dd6da61, 0x3a4e622c, 0x2c3a584e
+};
+
+#define GROESTL_ROTATE_COLUMN_DOWN(v1, v2, amount_bytes, temp_var) \
+	{ temp_var = (v1<<(8*amount_bytes))|(v2>>(8*(4-amount_bytes))); \
+		v2 = (v2<<(8*amount_bytes))|(v1>>(8*(4-amount_bytes))); \
+		v1 = temp_var; }
+
+#define GROESTL_COLUMN(x,y,i,c0,c1,c2,c3,c4,c5,c6,c7,tv1,tv2,tu,tl,t) \
+	tu = d_groestl_T[2*(uint32_t)x[4*c0+0]];	\
+	tl = d_groestl_T[2*(uint32_t)x[4*c0+0]+1];	\
+	tv1 = d_groestl_T[2*(uint32_t)x[4*c1+1]];	\
+	tv2 = d_groestl_T[2*(uint32_t)x[4*c1+1]+1];	\
+	GROESTL_ROTATE_COLUMN_DOWN(tv1,tv2,1,t)		\
+	tu ^= tv1;									\
+	tl ^= tv2;									\
+	tv1 = d_groestl_T[2*(uint32_t)x[4*c2+2]];	\
+	tv2 = d_groestl_T[2*(uint32_t)x[4*c2+2]+1];	\
+	GROESTL_ROTATE_COLUMN_DOWN(tv1,tv2,2,t)		\
+	tu ^= tv1;									\
+	tl ^= tv2;   								\
+	tv1 = d_groestl_T[2*(uint32_t)x[4*c3+3]];	\
+	tv2 = d_groestl_T[2*(uint32_t)x[4*c3+3]+1];	\
+	GROESTL_ROTATE_COLUMN_DOWN(tv1,tv2,3,t)		\
+	tu ^= tv1;									\
+	tl ^= tv2;									\
+	tl ^= d_groestl_T[2*(uint32_t)x[4*c4+0]];	\
+	tu ^= d_groestl_T[2*(uint32_t)x[4*c4+0]+1];	\
+	tv1 = d_groestl_T[2*(uint32_t)x[4*c5+1]];	\
+	tv2 = d_groestl_T[2*(uint32_t)x[4*c5+1]+1];	\
+	GROESTL_ROTATE_COLUMN_DOWN(tv1,tv2,1,t)		\
+	tl ^= tv1;									\
+	tu ^= tv2;									\
+	tv1 = d_groestl_T[2*(uint32_t)x[4*c6+2]];	\
+	tv2 = d_groestl_T[2*(uint32_t)x[4*c6+2]+1];	\
+	GROESTL_ROTATE_COLUMN_DOWN(tv1,tv2,2,t)		\
+	tl ^= tv1;									\
+	tu ^= tv2;   								\
+	tv1 = d_groestl_T[2*(uint32_t)x[4*c7+3]];	\
+	tv2 = d_groestl_T[2*(uint32_t)x[4*c7+3]+1];	\
+	GROESTL_ROTATE_COLUMN_DOWN(tv1,tv2,3,t)		\
+	tl ^= tv1;									\
+	tu ^= tv2;									\
+	y[i] = tu;									\
+	y[i+1] = tl;
+
+__device__ void cn_groestl_RND512P(uint8_t * __restrict__ x, uint32_t * __restrict__ y, uint32_t r)
+{
+	uint32_t temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp;
+	uint32_t* x32 = (uint32_t*)x;
+	x32[ 0] ^= 0x00000000^r;
+	x32[ 2] ^= 0x00000010^r;
+	x32[ 4] ^= 0x00000020^r;
+	x32[ 6] ^= 0x00000030^r;
+	x32[ 8] ^= 0x00000040^r;
+	x32[10] ^= 0x00000050^r;
+	x32[12] ^= 0x00000060^r;
+	x32[14] ^= 0x00000070^r;
+	GROESTL_COLUMN(x,y, 0,  0,  2,  4,  6,  9, 11, 13, 15, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
+	GROESTL_COLUMN(x,y, 2,  2,  4,  6,  8, 11, 13, 15,  1, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
+	GROESTL_COLUMN(x,y, 4,  4,  6,  8, 10, 13, 15,  1,  3, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
+	GROESTL_COLUMN(x,y, 6,  6,  8, 10, 12, 15,  1,  3,  5, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
+	GROESTL_COLUMN(x,y, 8,  8, 10, 12, 14,  1,  3,  5,  7, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
+	GROESTL_COLUMN(x,y,10, 10, 12, 14,  0,  3,  5,  7,  9, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
+	GROESTL_COLUMN(x,y,12, 12, 14,  0,  2,  5,  7,  9, 11, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
+	GROESTL_COLUMN(x,y,14, 14,  0,  2,  4,  7,  9, 11, 13, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
+}
+
+__device__ void cn_groestl_RND512Q(uint8_t * __restrict__ x, uint32_t * __restrict__ y, uint32_t r)
+{
+	uint32_t temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp;
+	uint32_t* x32 = (uint32_t*)x;
+	x32[ 0] = ~x32[ 0];
+	x32[ 1] ^= 0xffffffff^r;
+	x32[ 2] = ~x32[ 2];
+	x32[ 3] ^= 0xefffffff^r;
+	x32[ 4] = ~x32[ 4];
+	x32[ 5] ^= 0xdfffffff^r;
+	x32[ 6] = ~x32[ 6];
+	x32[ 7] ^= 0xcfffffff^r;
+	x32[ 8] = ~x32[ 8];
+	x32[ 9] ^= 0xbfffffff^r;
+	x32[10] = ~x32[10];
+	x32[11] ^= 0xafffffff^r;
+	x32[12] = ~x32[12];
+	x32[13] ^= 0x9fffffff^r;
+	x32[14] = ~x32[14];
+	x32[15] ^= 0x8fffffff^r;
+	GROESTL_COLUMN(x,y, 0,  2,  6, 10, 14,  1,  5,  9, 13, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
+	GROESTL_COLUMN(x,y, 2,  4,  8, 12,  0,  3,  7, 11, 15, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
+	GROESTL_COLUMN(x,y, 4,  6, 10, 14,  2,  5,  9, 13,  1, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
+	GROESTL_COLUMN(x,y, 6,  8, 12,  0,  4,  7, 11, 15,  3, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
+	GROESTL_COLUMN(x,y, 8, 10, 14,  2,  6,  9, 13,  1,  5, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
+	GROESTL_COLUMN(x,y,10, 12,  0,  4,  8, 11, 15,  3,  7, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
+	GROESTL_COLUMN(x,y,12, 14,  2,  6, 10, 13,  1,  5,  9, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
+	GROESTL_COLUMN(x,y,14,  0,  4,  8, 12, 15,  3,  7, 11, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
+}
+
+__device__ void cn_groestl_F512(uint32_t * __restrict__ h, const uint32_t * __restrict__ m)
+{
+	int i;
+	uint32_t Ptmp[2*GROESTL_COLS512];
+	uint32_t Qtmp[2*GROESTL_COLS512];
+	uint32_t y[2*GROESTL_COLS512];
+	uint32_t z[2*GROESTL_COLS512];
+
+	for (i = 0; i < 2*GROESTL_COLS512; i++) 
+	{
+		z[i] = m[i];
+		Ptmp[i] = h[i]^m[i];
+	}
+
+	cn_groestl_RND512Q((uint8_t*)z, y, 0x00000000);
+	cn_groestl_RND512Q((uint8_t*)y, z, 0x01000000);
+	cn_groestl_RND512Q((uint8_t*)z, y, 0x02000000);
+	cn_groestl_RND512Q((uint8_t*)y, z, 0x03000000);
+	cn_groestl_RND512Q((uint8_t*)z, y, 0x04000000);
+	cn_groestl_RND512Q((uint8_t*)y, z, 0x05000000);
+	cn_groestl_RND512Q((uint8_t*)z, y, 0x06000000);
+	cn_groestl_RND512Q((uint8_t*)y, z, 0x07000000);
+	cn_groestl_RND512Q((uint8_t*)z, y, 0x08000000);
+	cn_groestl_RND512Q((uint8_t*)y, Qtmp, 0x09000000);
+
+	cn_groestl_RND512P((uint8_t*)Ptmp, y, 0x00000000);
+	cn_groestl_RND512P((uint8_t*)y, z, 0x00000001);
+	cn_groestl_RND512P((uint8_t*)z, y, 0x00000002);
+	cn_groestl_RND512P((uint8_t*)y, z, 0x00000003);
+	cn_groestl_RND512P((uint8_t*)z, y, 0x00000004);
+	cn_groestl_RND512P((uint8_t*)y, z, 0x00000005);
+	cn_groestl_RND512P((uint8_t*)z, y, 0x00000006);
+	cn_groestl_RND512P((uint8_t*)y, z, 0x00000007);
+	cn_groestl_RND512P((uint8_t*)z, y, 0x00000008);
+	cn_groestl_RND512P((uint8_t*)y, Ptmp, 0x00000009);
+
+	for (i = 0; i < 2*GROESTL_COLS512; i++)
+		h[i] ^= Ptmp[i]^Qtmp[i];
+}
+
+__device__ void cn_groestl_outputtransformation(groestlHashState *ctx)
+{
+	int j;
+	uint32_t temp[2*GROESTL_COLS512];
+	uint32_t y[2*GROESTL_COLS512];
+	uint32_t z[2*GROESTL_COLS512];
+
+	for (j = 0; j < 2*GROESTL_COLS512; j++)
+		temp[j] = ctx->chaining[j];
+
+	cn_groestl_RND512P((uint8_t*)temp, y, 0x00000000);
+	cn_groestl_RND512P((uint8_t*)y, z, 0x00000001);
+	cn_groestl_RND512P((uint8_t*)z, y, 0x00000002);
+	cn_groestl_RND512P((uint8_t*)y, z, 0x00000003);
+	cn_groestl_RND512P((uint8_t*)z, y, 0x00000004);
+	cn_groestl_RND512P((uint8_t*)y, z, 0x00000005);
+	cn_groestl_RND512P((uint8_t*)z, y, 0x00000006);
+	cn_groestl_RND512P((uint8_t*)y, z, 0x00000007);
+	cn_groestl_RND512P((uint8_t*)z, y, 0x00000008);
+	cn_groestl_RND512P((uint8_t*)y, temp, 0x00000009);
+
+	for (j = 0; j < 2*GROESTL_COLS512; j++)
+		ctx->chaining[j] ^= temp[j];
+}
+
+__device__ void cn_groestl_transform(groestlHashState * __restrict__ ctx,
+	const uint8_t * __restrict__ input, int msglen)
+{
+	for (; msglen >= GROESTL_SIZE512; msglen -= GROESTL_SIZE512, input += GROESTL_SIZE512) 
+	{
+		cn_groestl_F512(ctx->chaining,(uint32_t*)input);
+		ctx->block_counter1++;
+
+		if (ctx->block_counter1 == 0) 
+			ctx->block_counter2++;
+	}
+}
+
+__device__ void cn_groestl_final(groestlHashState*  __restrict__ ctx, 
+	BitSequence* __restrict__  output)
+{
+	int i, j = 0, hashbytelen = GROESTL_HASH_BIT_LEN/8;
+	uint8_t *s = (BitSequence*)ctx->chaining;
+
+	if (ctx->bits_in_last_byte) 
+	{
+		ctx->buffer[(int)ctx->buf_ptr-1] &= ((1<<ctx->bits_in_last_byte)-1)<<(8-ctx->bits_in_last_byte);
+		ctx->buffer[(int)ctx->buf_ptr-1] ^= 0x1<<(7-ctx->bits_in_last_byte);
+		ctx->bits_in_last_byte = 0;
+	}
+	else
+	{
+		ctx->buffer[(int)ctx->buf_ptr++] = 0x80;
+	}
+
+	if (ctx->buf_ptr > GROESTL_SIZE512-GROESTL_LENGTHFIELDLEN) 
+	{
+		while (ctx->buf_ptr < GROESTL_SIZE512) 
+			ctx->buffer[(int)ctx->buf_ptr++] = 0;
+
+		cn_groestl_transform(ctx, ctx->buffer, GROESTL_SIZE512);
+		ctx->buf_ptr = 0;
+	}
+
+	while (ctx->buf_ptr < GROESTL_SIZE512-GROESTL_LENGTHFIELDLEN)
+		ctx->buffer[(int)ctx->buf_ptr++] = 0;
+
+	ctx->block_counter1++;
+	if (ctx->block_counter1 == 0)
+		ctx->block_counter2++;
+	ctx->buf_ptr = GROESTL_SIZE512;
+
+	while (ctx->buf_ptr > GROESTL_SIZE512-(int)sizeof(uint32_t))
+	{
+		ctx->buffer[(int)--ctx->buf_ptr] = (uint8_t)ctx->block_counter1;
+		ctx->block_counter1 >>= 8;
+	}
+	while (ctx->buf_ptr > GROESTL_SIZE512-GROESTL_LENGTHFIELDLEN)
+	{
+		ctx->buffer[(int)--ctx->buf_ptr] = (uint8_t)ctx->block_counter2;
+		ctx->block_counter2 >>= 8;
+	}
+	cn_groestl_transform(ctx, ctx->buffer, GROESTL_SIZE512);
+	cn_groestl_outputtransformation(ctx);
+
+	for (i = GROESTL_SIZE512-hashbytelen; i < GROESTL_SIZE512; i++,j++)
+		output[j] = s[i];
+
+	for (i = 0; i < GROESTL_COLS512; i++)
+		ctx->chaining[i] = 0;
+	for (i = 0; i < GROESTL_SIZE512; i++)
+		ctx->buffer[i] = 0;
+}
+
+__device__ void cn_groestl_update(groestlHashState* __restrict__ ctx,
+	const BitSequence* __restrict__ input, DataLength databitlen)
+{
+	int index = 0;
+	int msglen = (int)(databitlen/8);
+	int rem = (int)(databitlen%8);
+
+	if (ctx->buf_ptr) 
+	{
+		while (ctx->buf_ptr < GROESTL_SIZE512 && index < msglen)
+			ctx->buffer[(int)ctx->buf_ptr++] = input[index++];
+
+		if (ctx->buf_ptr < GROESTL_SIZE512) 
+		{
+			if (rem) 
+			{
+				ctx->bits_in_last_byte = rem;
+				ctx->buffer[(int)ctx->buf_ptr++] = input[index];
+			}
+			return;
+		}
+
+		ctx->buf_ptr = 0;
+		cn_groestl_transform(ctx, ctx->buffer, GROESTL_SIZE512);
+	}
+
+	cn_groestl_transform(ctx, input+index, msglen-index);
+	index += ((msglen-index)/GROESTL_SIZE512)*GROESTL_SIZE512;
+
+	while (index < msglen)
+		ctx->buffer[(int)ctx->buf_ptr++] = input[index++];
+
+	if (rem)
+	{
+		ctx->bits_in_last_byte = rem;
+		ctx->buffer[(int)ctx->buf_ptr++] = input[index];
+	}
+}
+
+__device__ void cn_groestl_init(groestlHashState* ctx)
+{
+	int i = 0;
+
+	for(;i<(GROESTL_SIZE512/sizeof(uint32_t));i++)
+		ctx->chaining[i] = 0;
+
+	ctx->chaining[2*GROESTL_COLS512-1] = u32BIG((uint32_t)GROESTL_HASH_BIT_LEN);
+	ctx->buf_ptr = 0;
+	ctx->block_counter1 = 0;
+	ctx->block_counter2 = 0;
+	ctx->bits_in_last_byte = 0;
+}
+
+__device__ void cn_groestl(const BitSequence * __restrict__ data, DataLength len, BitSequence * __restrict__ hashval)
+{
+	DataLength databitlen = len << 3;
+	groestlHashState context;
+
+	cn_groestl_init(&context);
+	cn_groestl_update(&context, data, databitlen);
+	cn_groestl_final(&context, hashval);
+}
diff --git a/xmrig-cuda/src/cuda_jh.hpp b/xmrig-cuda/src/cuda_jh.hpp
new file mode 100644
index 0000000..679046e
--- /dev/null
+++ b/xmrig-cuda/src/cuda_jh.hpp
@@ -0,0 +1,301 @@
+#include <stdint.h>
+
+typedef struct {
+	int hashbitlen;
+	unsigned long long databitlen;
+	unsigned long long datasize_in_buffer;
+	uint64_t x[8][2];
+	unsigned char buffer[64];
+} jhHashState;
+
+__constant__ unsigned char d_JH256_H0[512] =
+{
+	0xeb, 0x98, 0xa3, 0x41, 0x2c, 0x20, 0xd3, 0xeb, 0x92, 0xcd, 0xbe, 0x7b, 0x9c, 0xb2, 0x45, 0xc1,
+	0x1c, 0x93, 0x51, 0x91, 0x60, 0xd4, 0xc7, 0xfa, 0x26, 0x0, 0x82, 0xd6, 0x7e, 0x50, 0x8a, 0x3,
+	0xa4, 0x23, 0x9e, 0x26, 0x77, 0x26, 0xb9, 0x45, 0xe0, 0xfb, 0x1a, 0x48, 0xd4, 0x1a, 0x94, 0x77,
+	0xcd, 0xb5, 0xab, 0x26, 0x2, 0x6b, 0x17, 0x7a, 0x56, 0xf0, 0x24, 0x42, 0xf, 0xff, 0x2f, 0xa8,
+	0x71, 0xa3, 0x96, 0x89, 0x7f, 0x2e, 0x4d, 0x75, 0x1d, 0x14, 0x49, 0x8, 0xf7, 0x7d, 0xe2, 0x62,
+	0x27, 0x76, 0x95, 0xf7, 0x76, 0x24, 0x8f, 0x94, 0x87, 0xd5, 0xb6, 0x57, 0x47, 0x80, 0x29, 0x6c,
+	0x5c, 0x5e, 0x27, 0x2d, 0xac, 0x8e, 0xd, 0x6c, 0x51, 0x84, 0x50, 0xc6, 0x57, 0x5, 0x7a, 0xf,
+	0x7b, 0xe4, 0xd3, 0x67, 0x70, 0x24, 0x12, 0xea, 0x89, 0xe3, 0xab, 0x13, 0xd3, 0x1c, 0xd7, 0x69
+};
+
+__constant__ unsigned char d_E8_rc[42][32] =
+{
+	{0x72, 0xd5, 0xde, 0xa2, 0xdf, 0x15, 0xf8, 0x67, 0x7b, 0x84, 0x15, 0xa, 0xb7, 0x23, 0x15, 0x57, 0x81, 0xab, 0xd6, 0x90, 0x4d, 0x5a, 0x87, 0xf6, 0x4e, 0x9f, 0x4f, 0xc5, 0xc3, 0xd1, 0x2b, 0x40},
+	{0xea, 0x98, 0x3a, 0xe0, 0x5c, 0x45, 0xfa, 0x9c, 0x3, 0xc5, 0xd2, 0x99, 0x66, 0xb2, 0x99, 0x9a, 0x66, 0x2, 0x96, 0xb4, 0xf2, 0xbb, 0x53, 0x8a, 0xb5, 0x56, 0x14, 0x1a, 0x88, 0xdb, 0xa2, 0x31},
+	{0x3, 0xa3, 0x5a, 0x5c, 0x9a, 0x19, 0xe, 0xdb, 0x40, 0x3f, 0xb2, 0xa, 0x87, 0xc1, 0x44, 0x10, 0x1c, 0x5, 0x19, 0x80, 0x84, 0x9e, 0x95, 0x1d, 0x6f, 0x33, 0xeb, 0xad, 0x5e, 0xe7, 0xcd, 0xdc},
+	{0x10, 0xba, 0x13, 0x92, 0x2, 0xbf, 0x6b, 0x41, 0xdc, 0x78, 0x65, 0x15, 0xf7, 0xbb, 0x27, 0xd0, 0xa, 0x2c, 0x81, 0x39, 0x37, 0xaa, 0x78, 0x50, 0x3f, 0x1a, 0xbf, 0xd2, 0x41, 0x0, 0x91, 0xd3},
+	{0x42, 0x2d, 0x5a, 0xd, 0xf6, 0xcc, 0x7e, 0x90, 0xdd, 0x62, 0x9f, 0x9c, 0x92, 0xc0, 0x97, 0xce, 0x18, 0x5c, 0xa7, 0xb, 0xc7, 0x2b, 0x44, 0xac, 0xd1, 0xdf, 0x65, 0xd6, 0x63, 0xc6, 0xfc, 0x23},
+	{0x97, 0x6e, 0x6c, 0x3, 0x9e, 0xe0, 0xb8, 0x1a, 0x21, 0x5, 0x45, 0x7e, 0x44, 0x6c, 0xec, 0xa8, 0xee, 0xf1, 0x3, 0xbb, 0x5d, 0x8e, 0x61, 0xfa, 0xfd, 0x96, 0x97, 0xb2, 0x94, 0x83, 0x81, 0x97},
+	{0x4a, 0x8e, 0x85, 0x37, 0xdb, 0x3, 0x30, 0x2f, 0x2a, 0x67, 0x8d, 0x2d, 0xfb, 0x9f, 0x6a, 0x95, 0x8a, 0xfe, 0x73, 0x81, 0xf8, 0xb8, 0x69, 0x6c, 0x8a, 0xc7, 0x72, 0x46, 0xc0, 0x7f, 0x42, 0x14},
+	{0xc5, 0xf4, 0x15, 0x8f, 0xbd, 0xc7, 0x5e, 0xc4, 0x75, 0x44, 0x6f, 0xa7, 0x8f, 0x11, 0xbb, 0x80, 0x52, 0xde, 0x75, 0xb7, 0xae, 0xe4, 0x88, 0xbc, 0x82, 0xb8, 0x0, 0x1e, 0x98, 0xa6, 0xa3, 0xf4},
+	{0x8e, 0xf4, 0x8f, 0x33, 0xa9, 0xa3, 0x63, 0x15, 0xaa, 0x5f, 0x56, 0x24, 0xd5, 0xb7, 0xf9, 0x89, 0xb6, 0xf1, 0xed, 0x20, 0x7c, 0x5a, 0xe0, 0xfd, 0x36, 0xca, 0xe9, 0x5a, 0x6, 0x42, 0x2c, 0x36},
+	{0xce, 0x29, 0x35, 0x43, 0x4e, 0xfe, 0x98, 0x3d, 0x53, 0x3a, 0xf9, 0x74, 0x73, 0x9a, 0x4b, 0xa7, 0xd0, 0xf5, 0x1f, 0x59, 0x6f, 0x4e, 0x81, 0x86, 0xe, 0x9d, 0xad, 0x81, 0xaf, 0xd8, 0x5a, 0x9f},
+	{0xa7, 0x5, 0x6, 0x67, 0xee, 0x34, 0x62, 0x6a, 0x8b, 0xb, 0x28, 0xbe, 0x6e, 0xb9, 0x17, 0x27, 0x47, 0x74, 0x7, 0x26, 0xc6, 0x80, 0x10, 0x3f, 0xe0, 0xa0, 0x7e, 0x6f, 0xc6, 0x7e, 0x48, 0x7b},
+	{0xd, 0x55, 0xa, 0xa5, 0x4a, 0xf8, 0xa4, 0xc0, 0x91, 0xe3, 0xe7, 0x9f, 0x97, 0x8e, 0xf1, 0x9e, 0x86, 0x76, 0x72, 0x81, 0x50, 0x60, 0x8d, 0xd4, 0x7e, 0x9e, 0x5a, 0x41, 0xf3, 0xe5, 0xb0, 0x62},
+	{0xfc, 0x9f, 0x1f, 0xec, 0x40, 0x54, 0x20, 0x7a, 0xe3, 0xe4, 0x1a, 0x0, 0xce, 0xf4, 0xc9, 0x84, 0x4f, 0xd7, 0x94, 0xf5, 0x9d, 0xfa, 0x95, 0xd8, 0x55, 0x2e, 0x7e, 0x11, 0x24, 0xc3, 0x54, 0xa5},
+	{0x5b, 0xdf, 0x72, 0x28, 0xbd, 0xfe, 0x6e, 0x28, 0x78, 0xf5, 0x7f, 0xe2, 0xf, 0xa5, 0xc4, 0xb2, 0x5, 0x89, 0x7c, 0xef, 0xee, 0x49, 0xd3, 0x2e, 0x44, 0x7e, 0x93, 0x85, 0xeb, 0x28, 0x59, 0x7f},
+	{0x70, 0x5f, 0x69, 0x37, 0xb3, 0x24, 0x31, 0x4a, 0x5e, 0x86, 0x28, 0xf1, 0x1d, 0xd6, 0xe4, 0x65, 0xc7, 0x1b, 0x77, 0x4, 0x51, 0xb9, 0x20, 0xe7, 0x74, 0xfe, 0x43, 0xe8, 0x23, 0xd4, 0x87, 0x8a},
+	{0x7d, 0x29, 0xe8, 0xa3, 0x92, 0x76, 0x94, 0xf2, 0xdd, 0xcb, 0x7a, 0x9, 0x9b, 0x30, 0xd9, 0xc1, 0x1d, 0x1b, 0x30, 0xfb, 0x5b, 0xdc, 0x1b, 0xe0, 0xda, 0x24, 0x49, 0x4f, 0xf2, 0x9c, 0x82, 0xbf},
+	{0xa4, 0xe7, 0xba, 0x31, 0xb4, 0x70, 0xbf, 0xff, 0xd, 0x32, 0x44, 0x5, 0xde, 0xf8, 0xbc, 0x48, 0x3b, 0xae, 0xfc, 0x32, 0x53, 0xbb, 0xd3, 0x39, 0x45, 0x9f, 0xc3, 0xc1, 0xe0, 0x29, 0x8b, 0xa0},
+	{0xe5, 0xc9, 0x5, 0xfd, 0xf7, 0xae, 0x9, 0xf, 0x94, 0x70, 0x34, 0x12, 0x42, 0x90, 0xf1, 0x34, 0xa2, 0x71, 0xb7, 0x1, 0xe3, 0x44, 0xed, 0x95, 0xe9, 0x3b, 0x8e, 0x36, 0x4f, 0x2f, 0x98, 0x4a},
+	{0x88, 0x40, 0x1d, 0x63, 0xa0, 0x6c, 0xf6, 0x15, 0x47, 0xc1, 0x44, 0x4b, 0x87, 0x52, 0xaf, 0xff, 0x7e, 0xbb, 0x4a, 0xf1, 0xe2, 0xa, 0xc6, 0x30, 0x46, 0x70, 0xb6, 0xc5, 0xcc, 0x6e, 0x8c, 0xe6},
+	{0xa4, 0xd5, 0xa4, 0x56, 0xbd, 0x4f, 0xca, 0x0, 0xda, 0x9d, 0x84, 0x4b, 0xc8, 0x3e, 0x18, 0xae, 0x73, 0x57, 0xce, 0x45, 0x30, 0x64, 0xd1, 0xad, 0xe8, 0xa6, 0xce, 0x68, 0x14, 0x5c, 0x25, 0x67},
+	{0xa3, 0xda, 0x8c, 0xf2, 0xcb, 0xe, 0xe1, 0x16, 0x33, 0xe9, 0x6, 0x58, 0x9a, 0x94, 0x99, 0x9a, 0x1f, 0x60, 0xb2, 0x20, 0xc2, 0x6f, 0x84, 0x7b, 0xd1, 0xce, 0xac, 0x7f, 0xa0, 0xd1, 0x85, 0x18},
+	{0x32, 0x59, 0x5b, 0xa1, 0x8d, 0xdd, 0x19, 0xd3, 0x50, 0x9a, 0x1c, 0xc0, 0xaa, 0xa5, 0xb4, 0x46, 0x9f, 0x3d, 0x63, 0x67, 0xe4, 0x4, 0x6b, 0xba, 0xf6, 0xca, 0x19, 0xab, 0xb, 0x56, 0xee, 0x7e},
+	{0x1f, 0xb1, 0x79, 0xea, 0xa9, 0x28, 0x21, 0x74, 0xe9, 0xbd, 0xf7, 0x35, 0x3b, 0x36, 0x51, 0xee, 0x1d, 0x57, 0xac, 0x5a, 0x75, 0x50, 0xd3, 0x76, 0x3a, 0x46, 0xc2, 0xfe, 0xa3, 0x7d, 0x70, 0x1},
+	{0xf7, 0x35, 0xc1, 0xaf, 0x98, 0xa4, 0xd8, 0x42, 0x78, 0xed, 0xec, 0x20, 0x9e, 0x6b, 0x67, 0x79, 0x41, 0x83, 0x63, 0x15, 0xea, 0x3a, 0xdb, 0xa8, 0xfa, 0xc3, 0x3b, 0x4d, 0x32, 0x83, 0x2c, 0x83},
+	{0xa7, 0x40, 0x3b, 0x1f, 0x1c, 0x27, 0x47, 0xf3, 0x59, 0x40, 0xf0, 0x34, 0xb7, 0x2d, 0x76, 0x9a, 0xe7, 0x3e, 0x4e, 0x6c, 0xd2, 0x21, 0x4f, 0xfd, 0xb8, 0xfd, 0x8d, 0x39, 0xdc, 0x57, 0x59, 0xef},
+	{0x8d, 0x9b, 0xc, 0x49, 0x2b, 0x49, 0xeb, 0xda, 0x5b, 0xa2, 0xd7, 0x49, 0x68, 0xf3, 0x70, 0xd, 0x7d, 0x3b, 0xae, 0xd0, 0x7a, 0x8d, 0x55, 0x84, 0xf5, 0xa5, 0xe9, 0xf0, 0xe4, 0xf8, 0x8e, 0x65},
+	{0xa0, 0xb8, 0xa2, 0xf4, 0x36, 0x10, 0x3b, 0x53, 0xc, 0xa8, 0x7, 0x9e, 0x75, 0x3e, 0xec, 0x5a, 0x91, 0x68, 0x94, 0x92, 0x56, 0xe8, 0x88, 0x4f, 0x5b, 0xb0, 0x5c, 0x55, 0xf8, 0xba, 0xbc, 0x4c},
+	{0xe3, 0xbb, 0x3b, 0x99, 0xf3, 0x87, 0x94, 0x7b, 0x75, 0xda, 0xf4, 0xd6, 0x72, 0x6b, 0x1c, 0x5d, 0x64, 0xae, 0xac, 0x28, 0xdc, 0x34, 0xb3, 0x6d, 0x6c, 0x34, 0xa5, 0x50, 0xb8, 0x28, 0xdb, 0x71},
+	{0xf8, 0x61, 0xe2, 0xf2, 0x10, 0x8d, 0x51, 0x2a, 0xe3, 0xdb, 0x64, 0x33, 0x59, 0xdd, 0x75, 0xfc, 0x1c, 0xac, 0xbc, 0xf1, 0x43, 0xce, 0x3f, 0xa2, 0x67, 0xbb, 0xd1, 0x3c, 0x2, 0xe8, 0x43, 0xb0},
+	{0x33, 0xa, 0x5b, 0xca, 0x88, 0x29, 0xa1, 0x75, 0x7f, 0x34, 0x19, 0x4d, 0xb4, 0x16, 0x53, 0x5c, 0x92, 0x3b, 0x94, 0xc3, 0xe, 0x79, 0x4d, 0x1e, 0x79, 0x74, 0x75, 0xd7, 0xb6, 0xee, 0xaf, 0x3f},
+	{0xea, 0xa8, 0xd4, 0xf7, 0xbe, 0x1a, 0x39, 0x21, 0x5c, 0xf4, 0x7e, 0x9, 0x4c, 0x23, 0x27, 0x51, 0x26, 0xa3, 0x24, 0x53, 0xba, 0x32, 0x3c, 0xd2, 0x44, 0xa3, 0x17, 0x4a, 0x6d, 0xa6, 0xd5, 0xad},
+	{0xb5, 0x1d, 0x3e, 0xa6, 0xaf, 0xf2, 0xc9, 0x8, 0x83, 0x59, 0x3d, 0x98, 0x91, 0x6b, 0x3c, 0x56, 0x4c, 0xf8, 0x7c, 0xa1, 0x72, 0x86, 0x60, 0x4d, 0x46, 0xe2, 0x3e, 0xcc, 0x8, 0x6e, 0xc7, 0xf6},
+	{0x2f, 0x98, 0x33, 0xb3, 0xb1, 0xbc, 0x76, 0x5e, 0x2b, 0xd6, 0x66, 0xa5, 0xef, 0xc4, 0xe6, 0x2a, 0x6, 0xf4, 0xb6, 0xe8, 0xbe, 0xc1, 0xd4, 0x36, 0x74, 0xee, 0x82, 0x15, 0xbc, 0xef, 0x21, 0x63},
+	{0xfd, 0xc1, 0x4e, 0xd, 0xf4, 0x53, 0xc9, 0x69, 0xa7, 0x7d, 0x5a, 0xc4, 0x6, 0x58, 0x58, 0x26, 0x7e, 0xc1, 0x14, 0x16, 0x6, 0xe0, 0xfa, 0x16, 0x7e, 0x90, 0xaf, 0x3d, 0x28, 0x63, 0x9d, 0x3f},
+	{0xd2, 0xc9, 0xf2, 0xe3, 0x0, 0x9b, 0xd2, 0xc, 0x5f, 0xaa, 0xce, 0x30, 0xb7, 0xd4, 0xc, 0x30, 0x74, 0x2a, 0x51, 0x16, 0xf2, 0xe0, 0x32, 0x98, 0xd, 0xeb, 0x30, 0xd8, 0xe3, 0xce, 0xf8, 0x9a},
+	{0x4b, 0xc5, 0x9e, 0x7b, 0xb5, 0xf1, 0x79, 0x92, 0xff, 0x51, 0xe6, 0x6e, 0x4, 0x86, 0x68, 0xd3, 0x9b, 0x23, 0x4d, 0x57, 0xe6, 0x96, 0x67, 0x31, 0xcc, 0xe6, 0xa6, 0xf3, 0x17, 0xa, 0x75, 0x5},
+	{0xb1, 0x76, 0x81, 0xd9, 0x13, 0x32, 0x6c, 0xce, 0x3c, 0x17, 0x52, 0x84, 0xf8, 0x5, 0xa2, 0x62, 0xf4, 0x2b, 0xcb, 0xb3, 0x78, 0x47, 0x15, 0x47, 0xff, 0x46, 0x54, 0x82, 0x23, 0x93, 0x6a, 0x48},
+	{0x38, 0xdf, 0x58, 0x7, 0x4e, 0x5e, 0x65, 0x65, 0xf2, 0xfc, 0x7c, 0x89, 0xfc, 0x86, 0x50, 0x8e, 0x31, 0x70, 0x2e, 0x44, 0xd0, 0xb, 0xca, 0x86, 0xf0, 0x40, 0x9, 0xa2, 0x30, 0x78, 0x47, 0x4e},
+	{0x65, 0xa0, 0xee, 0x39, 0xd1, 0xf7, 0x38, 0x83, 0xf7, 0x5e, 0xe9, 0x37, 0xe4, 0x2c, 0x3a, 0xbd, 0x21, 0x97, 0xb2, 0x26, 0x1, 0x13, 0xf8, 0x6f, 0xa3, 0x44, 0xed, 0xd1, 0xef, 0x9f, 0xde, 0xe7},
+	{0x8b, 0xa0, 0xdf, 0x15, 0x76, 0x25, 0x92, 0xd9, 0x3c, 0x85, 0xf7, 0xf6, 0x12, 0xdc, 0x42, 0xbe, 0xd8, 0xa7, 0xec, 0x7c, 0xab, 0x27, 0xb0, 0x7e, 0x53, 0x8d, 0x7d, 0xda, 0xaa, 0x3e, 0xa8, 0xde},
+	{0xaa, 0x25, 0xce, 0x93, 0xbd, 0x2, 0x69, 0xd8, 0x5a, 0xf6, 0x43, 0xfd, 0x1a, 0x73, 0x8, 0xf9, 0xc0, 0x5f, 0xef, 0xda, 0x17, 0x4a, 0x19, 0xa5, 0x97, 0x4d, 0x66, 0x33, 0x4c, 0xfd, 0x21, 0x6a},
+	{0x35, 0xb4, 0x98, 0x31, 0xdb, 0x41, 0x15, 0x70, 0xea, 0x1e, 0xf, 0xbb, 0xed, 0xcd, 0x54, 0x9b, 0x9a, 0xd0, 0x63, 0xa1, 0x51, 0x97, 0x40, 0x72, 0xf6, 0x75, 0x9d, 0xbf, 0x91, 0x47, 0x6f, 0xe2}
+};
+
+#define JH_SWAP1(x)   (x) = ((((x) & 0x5555555555555555ULL) << 1) | (((x) & 0xaaaaaaaaaaaaaaaaULL) >> 1));
+#define JH_SWAP2(x)   (x) = ((((x) & 0x3333333333333333ULL) << 2) | (((x) & 0xccccccccccccccccULL) >> 2));
+#define JH_SWAP4(x)   (x) = ((((x) & 0x0f0f0f0f0f0f0f0fULL) << 4) | (((x) & 0xf0f0f0f0f0f0f0f0ULL) >> 4));
+#define JH_SWAP8(x)   (x) = ((((x) & 0x00ff00ff00ff00ffULL) << 8) | (((x) & 0xff00ff00ff00ff00ULL) >> 8));
+#define JH_SWAP16(x)  (x) = ((((x) & 0x0000ffff0000ffffULL) << 16) | (((x) & 0xffff0000ffff0000ULL) >> 16));
+#define JH_SWAP32(x)  (x) = (((x) << 32) | ((x) >> 32));
+
+#define JH_L(m0,m1,m2,m3,m4,m5,m6,m7) \
+	(m4) ^= (m1);                \
+	(m5) ^= (m2);                \
+	(m6) ^= (m0) ^ (m3);         \
+	(m7) ^= (m0);                \
+	(m0) ^= (m5);                \
+	(m1) ^= (m6);                \
+	(m2) ^= (m4) ^ (m7);         \
+	(m3) ^= (m4);
+
+#define JH_SS(m0,m1,m2,m3,m4,m5,m6,m7,cc0,cc1)   \
+	m3  = ~(m3);                  \
+	m7  = ~(m7);                  \
+	m0 ^= ((~(m2)) & (cc0));      \
+	m4 ^= ((~(m6)) & (cc1));      \
+	temp0 = (cc0) ^ ((m0) & (m1));\
+	temp1 = (cc1) ^ ((m4) & (m5));\
+	m0 ^= ((m2) & (m3));          \
+	m4 ^= ((m6) & (m7));          \
+	m3 ^= ((~(m1)) & (m2));       \
+	m7 ^= ((~(m5)) & (m6));       \
+	m1 ^= ((m0) & (m2));          \
+	m5 ^= ((m4) & (m6));          \
+	m2 ^= ((m0) & (~(m3)));       \
+	m6 ^= ((m4) & (~(m7)));       \
+	m0 ^= ((m1) | (m3));          \
+	m4 ^= ((m5) | (m7));          \
+	m3 ^= ((m1) & (m2));          \
+	m7 ^= ((m5) & (m6));          \
+	m1 ^= (temp0 & (m0));         \
+	m5 ^= (temp1 & (m4));         \
+	m2 ^= temp0;                  \
+	m6 ^= temp1;
+
+__device__ void cn_jh_E8(jhHashState *state)
+{
+	uint64_t i,roundnumber,temp0,temp1;
+
+	for (roundnumber = 0; roundnumber < 42; roundnumber = roundnumber+7) 
+	{
+		for (i = 0; i < 2; i++)
+		{
+			JH_SS(state->x[0][i],state->x[2][i],state->x[4][i],state->x[6][i],state->x[1][i],state->x[3][i],state->x[5][i],state->x[7][i],((uint64_t *)d_E8_rc[roundnumber+0])[i],((uint64_t *)d_E8_rc[roundnumber+0])[i+2] );
+			JH_L(state->x[0][i],state->x[2][i],state->x[4][i],state->x[6][i],state->x[1][i],state->x[3][i],state->x[5][i],state->x[7][i]);
+			JH_SWAP1(state->x[1][i]); JH_SWAP1(state->x[3][i]); JH_SWAP1(state->x[5][i]); JH_SWAP1(state->x[7][i]);
+		}
+
+		for (i = 0; i < 2; i++)
+		{
+			JH_SS(state->x[0][i],state->x[2][i],state->x[4][i],state->x[6][i],state->x[1][i],state->x[3][i],state->x[5][i],state->x[7][i],((uint64_t *)d_E8_rc[roundnumber+1])[i],((uint64_t *)d_E8_rc[roundnumber+1])[i+2] );
+			JH_L(state->x[0][i],state->x[2][i],state->x[4][i],state->x[6][i],state->x[1][i],state->x[3][i],state->x[5][i],state->x[7][i]);
+			JH_SWAP2(state->x[1][i]); JH_SWAP2(state->x[3][i]); JH_SWAP2(state->x[5][i]); JH_SWAP2(state->x[7][i]);
+		}
+
+		for (i = 0; i < 2; i++)
+		{
+			JH_SS(state->x[0][i],state->x[2][i],state->x[4][i],state->x[6][i],state->x[1][i],state->x[3][i],state->x[5][i],state->x[7][i],((uint64_t *)d_E8_rc[roundnumber+2])[i],((uint64_t *)d_E8_rc[roundnumber+2])[i+2] );
+			JH_L(state->x[0][i],state->x[2][i],state->x[4][i],state->x[6][i],state->x[1][i],state->x[3][i],state->x[5][i],state->x[7][i]);
+			JH_SWAP4(state->x[1][i]); JH_SWAP4(state->x[3][i]); JH_SWAP4(state->x[5][i]); JH_SWAP4(state->x[7][i]);
+		}
+
+		for (i = 0; i < 2; i++)
+		{
+			JH_SS(state->x[0][i],state->x[2][i],state->x[4][i],state->x[6][i],state->x[1][i],state->x[3][i],state->x[5][i],state->x[7][i],((uint64_t *)d_E8_rc[roundnumber+3])[i],((uint64_t *)d_E8_rc[roundnumber+3])[i+2] );
+			JH_L(state->x[0][i],state->x[2][i],state->x[4][i],state->x[6][i],state->x[1][i],state->x[3][i],state->x[5][i],state->x[7][i]);
+			JH_SWAP8(state->x[1][i]); JH_SWAP8(state->x[3][i]); JH_SWAP8(state->x[5][i]); JH_SWAP8(state->x[7][i]);
+		}
+
+		for (i = 0; i < 2; i++)
+		{
+			JH_SS(state->x[0][i],state->x[2][i],state->x[4][i],state->x[6][i],state->x[1][i],state->x[3][i],state->x[5][i],state->x[7][i],((uint64_t *)d_E8_rc[roundnumber+4])[i],((uint64_t *)d_E8_rc[roundnumber+4])[i+2] );
+			JH_L(state->x[0][i],state->x[2][i],state->x[4][i],state->x[6][i],state->x[1][i],state->x[3][i],state->x[5][i],state->x[7][i]);
+			JH_SWAP16(state->x[1][i]); JH_SWAP16(state->x[3][i]); JH_SWAP16(state->x[5][i]); JH_SWAP16(state->x[7][i]);
+		}
+
+		for (i = 0; i < 2; i++)
+		{
+			JH_SS(state->x[0][i],state->x[2][i],state->x[4][i],state->x[6][i],state->x[1][i],state->x[3][i],state->x[5][i],state->x[7][i],((uint64_t *)d_E8_rc[roundnumber+5])[i],((uint64_t *)d_E8_rc[roundnumber+5])[i+2] );
+			JH_L(state->x[0][i],state->x[2][i],state->x[4][i],state->x[6][i],state->x[1][i],state->x[3][i],state->x[5][i],state->x[7][i]);
+			JH_SWAP32(state->x[1][i]); JH_SWAP32(state->x[3][i]); JH_SWAP32(state->x[5][i]); JH_SWAP32(state->x[7][i]);
+		}
+
+		for (i = 0; i < 2; i++) 
+		{
+			JH_SS(state->x[0][i],state->x[2][i],state->x[4][i],state->x[6][i],state->x[1][i],state->x[3][i],state->x[5][i],state->x[7][i],((uint64_t *)d_E8_rc[roundnumber+6])[i],((uint64_t *)d_E8_rc[roundnumber+6])[i+2] );
+			JH_L(state->x[0][i],state->x[2][i],state->x[4][i],state->x[6][i],state->x[1][i],state->x[3][i],state->x[5][i],state->x[7][i]);
+		}
+
+		for (i = 1; i < 8; i = i+2) 
+		{
+			temp0 = state->x[i][0];
+			state->x[i][0] = state->x[i][1];
+			state->x[i][1] = temp0;
+		}
+	}
+}
+
+__device__ void cn_jh_F8(jhHashState *state)
+{
+	uint64_t i;
+
+	for (i = 0; i < 8; i++)
+		state->x[i >> 1][i & 1] ^= ((uint64_t *)state->buffer)[i];
+
+	cn_jh_E8(state);
+
+	for (i = 0; i < 8; i++)
+		state->x[(8+i) >> 1][(8+i) & 1] ^= ((uint64_t *)state->buffer)[i];
+}
+
+__device__ void cn_jh_update(jhHashState * __restrict__ state, const BitSequence * __restrict__ data, DataLength databitlen)
+{
+	DataLength index;
+
+	state->databitlen += databitlen;
+	index = 0;
+
+	if ( (state->datasize_in_buffer > 0 ) && (( state->datasize_in_buffer + databitlen) < 512)  ) 
+	{
+		if ( (databitlen & 7) == 0 )
+			memcpy(state->buffer + (state->datasize_in_buffer >> 3), data, 64-(state->datasize_in_buffer >> 3));
+		else
+			memcpy(state->buffer + (state->datasize_in_buffer >> 3), data, 64-(state->datasize_in_buffer >> 3)+1);
+		state->datasize_in_buffer += databitlen;
+		databitlen = 0;
+	}
+
+	if ( (state->datasize_in_buffer > 0 ) && (( state->datasize_in_buffer + databitlen) >= 512)  )
+	{
+		memcpy( state->buffer + (state->datasize_in_buffer >> 3), data, 64-(state->datasize_in_buffer >> 3) );
+		index = 64-(state->datasize_in_buffer >> 3);
+		databitlen = databitlen - (512 - state->datasize_in_buffer);
+		cn_jh_F8(state);
+		state->datasize_in_buffer = 0;
+	}
+
+	for ( ; databitlen >= 512; index = index+64, databitlen = databitlen - 512)
+	{
+		memcpy(state->buffer, data+index, 64);
+		cn_jh_F8(state);
+	}
+
+	if ( databitlen > 0) 
+	{
+		if ((databitlen & 7) == 0)
+			memcpy(state->buffer, data+index, (databitlen & 0x1ff) >> 3);
+		else
+			memcpy(state->buffer, data+index, ((databitlen & 0x1ff) >> 3)+1);
+		state->datasize_in_buffer = databitlen;
+	}
+}
+
+/*pad the message, process the padded block(s), truncate the hash value H to obtain the message digest*/
+__device__ void cn_jh_final(jhHashState * __restrict__ state, BitSequence * __restrict__ hashval)
+{
+	unsigned int i;
+	//uint32_t *bufptr = (uint32_t *)state->buffer;
+
+	if ( (state->databitlen & 0x1ff) == 0 )
+	{
+		/*pad the message when databitlen is multiple of 512 bits, then process the padded block*/
+		memset(state->buffer, 0, 64);
+		//for( i = 0; i < 16; i++ ) *(bufptr+i) = 0x00000000;
+		state->buffer[0]  = 0x80;
+		state->buffer[63] = state->databitlen & 0xff;
+		state->buffer[62] = (state->databitlen >> 8)  & 0xff;
+		state->buffer[61] = (state->databitlen >> 16) & 0xff;
+		state->buffer[60] = (state->databitlen >> 24) & 0xff;
+		state->buffer[59] = (state->databitlen >> 32) & 0xff;
+		state->buffer[58] = (state->databitlen >> 40) & 0xff;
+		state->buffer[57] = (state->databitlen >> 48) & 0xff;
+		state->buffer[56] = (state->databitlen >> 56) & 0xff;
+		cn_jh_F8(state);
+	}
+	else 
+	{
+		/*set the rest of the bytes in the buffer to 0*/
+		if ( (state->datasize_in_buffer & 7) == 0)
+		{
+			for (i = (state->databitlen & 0x1ff) >> 3; i < 64; i++)
+				state->buffer[i] = 0;
+		}
+		else
+		{
+			for (i = ((state->databitlen & 0x1ff) >> 3)+1; i < 64; i++)
+				state->buffer[i] = 0;
+		}
+
+		/*pad and process the partial block when databitlen is not multiple of 512 bits, then hash the padded blocks*/
+		state->buffer[((state->databitlen & 0x1ff) >> 3)] |= 1 << (7- (state->databitlen & 7));
+
+		cn_jh_F8(state);
+		memset(state->buffer, 0, 64);
+		//for( i = 0; i < 16; i++ ) *(bufptr+i) = 0x00000000;
+		state->buffer[63] = state->databitlen & 0xff;
+		state->buffer[62] = (state->databitlen >> 8) & 0xff;
+		state->buffer[61] = (state->databitlen >> 16) & 0xff;
+		state->buffer[60] = (state->databitlen >> 24) & 0xff;
+		state->buffer[59] = (state->databitlen >> 32) & 0xff;
+		state->buffer[58] = (state->databitlen >> 40) & 0xff;
+		state->buffer[57] = (state->databitlen >> 48) & 0xff;
+		state->buffer[56] = (state->databitlen >> 56) & 0xff;
+		cn_jh_F8(state);
+	}
+
+	memcpy(hashval,(unsigned char*)state->x+64+32,32);
+}
+
+__device__ void cn_jh_init(jhHashState *state, int hashbitlen)
+{
+	state->databitlen = 0;
+	state->datasize_in_buffer = 0;
+	state->hashbitlen = hashbitlen;
+	memcpy(state->x, d_JH256_H0, 128);
+}
+
+__device__ void cn_jh(const BitSequence * __restrict__ data, DataLength len, BitSequence * __restrict__ hashval)
+{
+	int hashbitlen = 256;
+	DataLength databitlen = len << 3;
+	jhHashState state;
+
+	cn_jh_init(&state, hashbitlen);
+	cn_jh_update(&state, data, databitlen);
+	cn_jh_final(&state, hashval);
+}
diff --git a/xmrig-cuda/src/cuda_keccak.hpp b/xmrig-cuda/src/cuda_keccak.hpp
new file mode 100644
index 0000000..d46c246
--- /dev/null
+++ b/xmrig-cuda/src/cuda_keccak.hpp
@@ -0,0 +1,166 @@
+#ifdef __CUDACC__
+__constant__
+#else
+const
+#endif
+uint64_t keccakf_rndc[24] ={
+    0x0000000000000001, 0x0000000000008082, 0x800000000000808a,
+    0x8000000080008000, 0x000000000000808b, 0x0000000080000001,
+    0x8000000080008081, 0x8000000000008009, 0x000000000000008a,
+    0x0000000000000088, 0x0000000080008009, 0x000000008000000a,
+    0x000000008000808b, 0x800000000000008b, 0x8000000000008089,
+    0x8000000000008003, 0x8000000000008002, 0x8000000000000080,
+    0x000000000000800a, 0x800000008000000a, 0x8000000080008081,
+    0x8000000000008080, 0x0000000080000001, 0x8000000080008008
+};
+
+#if __CUDA_ARCH__ >= 350
+	__forceinline__ __device__ uint64_t cuda_rotl64(const uint64_t value, const int offset)
+	{
+		uint2 result;
+		if(offset >= 32)
+		{
+			asm("shf.l.wrap.b32 %0, %1, %2, %3;" : "=r"(result.x) : "r"(__double2loint(__longlong_as_double(value))), "r"(__double2hiint(__longlong_as_double(value))), "r"(offset));
+			asm("shf.l.wrap.b32 %0, %1, %2, %3;" : "=r"(result.y) : "r"(__double2hiint(__longlong_as_double(value))), "r"(__double2loint(__longlong_as_double(value))), "r"(offset));
+		}
+		else
+		{
+			asm("shf.l.wrap.b32 %0, %1, %2, %3;" : "=r"(result.x) : "r"(__double2hiint(__longlong_as_double(value))), "r"(__double2loint(__longlong_as_double(value))), "r"(offset));
+			asm("shf.l.wrap.b32 %0, %1, %2, %3;" : "=r"(result.y) : "r"(__double2loint(__longlong_as_double(value))), "r"(__double2hiint(__longlong_as_double(value))), "r"(offset));
+		}
+		return  __double_as_longlong(__hiloint2double(result.y, result.x));
+	}
+	#define rotl64_1(x, y) (cuda_rotl64((x), (y)))
+#else
+	#define rotl64_1(x, y) ((x) << (y) | ((x) >> (64 - (y))))
+#endif
+
+#define rotl64_2(x, y) rotl64_1(((x) >> 32) | ((x) << 32), (y))
+#define bitselect(a, b, c) ((a) ^ ((c) & ((b) ^ (a))))
+
+__device__ __forceinline__ void cn_keccakf2(uint64_t *s)
+{
+	uint8_t i;
+
+	for(i = 0; i < 24; ++i)
+	{
+		uint64_t bc[5], tmpxor[5], tmp1, tmp2;
+
+		tmpxor[0] = s[0] ^ s[5] ^ s[10] ^ s[15] ^ s[20];
+		tmpxor[1] = s[1] ^ s[6] ^ s[11] ^ s[16] ^ s[21];
+		tmpxor[2] = s[2] ^ s[7] ^ s[12] ^ s[17] ^ s[22];
+		tmpxor[3] = s[3] ^ s[8] ^ s[13] ^ s[18] ^ s[23];
+		tmpxor[4] = s[4] ^ s[9] ^ s[14] ^ s[19] ^ s[24];
+
+		bc[0] = tmpxor[0] ^ rotl64_1(tmpxor[2], 1);
+		bc[1] = tmpxor[1] ^ rotl64_1(tmpxor[3], 1);
+		bc[2] = tmpxor[2] ^ rotl64_1(tmpxor[4], 1);
+		bc[3] = tmpxor[3] ^ rotl64_1(tmpxor[0], 1);
+		bc[4] = tmpxor[4] ^ rotl64_1(tmpxor[1], 1);
+
+		tmp1 = s[1] ^ bc[0];
+
+		s[0] ^= bc[4];
+		s[1] = rotl64_2(s[6] ^ bc[0], 12);
+		s[6] = rotl64_1(s[9] ^ bc[3], 20);
+		s[9] = rotl64_2(s[22] ^ bc[1], 29);
+		s[22] = rotl64_2(s[14] ^ bc[3], 7);
+		s[14] = rotl64_1(s[20] ^ bc[4], 18);
+		s[20] = rotl64_2(s[2] ^ bc[1], 30);
+		s[2] = rotl64_2(s[12] ^ bc[1], 11);
+		s[12] = rotl64_1(s[13] ^ bc[2], 25);
+		s[13] = rotl64_1(s[19] ^ bc[3], 8);
+		s[19] = rotl64_2(s[23] ^ bc[2], 24);
+		s[23] = rotl64_2(s[15] ^ bc[4], 9);
+		s[15] = rotl64_1(s[4] ^ bc[3], 27);
+		s[4] = rotl64_1(s[24] ^ bc[3], 14);
+		s[24] = rotl64_1(s[21] ^ bc[0], 2);
+		s[21] = rotl64_2(s[8] ^ bc[2], 23);
+		s[8] = rotl64_2(s[16] ^ bc[0], 13);
+		s[16] = rotl64_2(s[5] ^ bc[4], 4);
+		s[5] = rotl64_1(s[3] ^ bc[2], 28);
+		s[3] = rotl64_1(s[18] ^ bc[2], 21);
+		s[18] = rotl64_1(s[17] ^ bc[1], 15);
+		s[17] = rotl64_1(s[11] ^ bc[0], 10);
+		s[11] = rotl64_1(s[7] ^ bc[1], 6);
+		s[7] = rotl64_1(s[10] ^ bc[4], 3);
+		s[10] = rotl64_1(tmp1, 1);
+
+		tmp1 = s[0]; tmp2 = s[1]; s[0] = bitselect(s[0] ^ s[2], s[0], s[1]); s[1] = bitselect(s[1] ^ s[3], s[1], s[2]); s[2] = bitselect(s[2] ^ s[4], s[2], s[3]); s[3] = bitselect(s[3] ^ tmp1, s[3], s[4]); s[4] = bitselect(s[4] ^ tmp2, s[4], tmp1);
+		tmp1 = s[5]; tmp2 = s[6]; s[5] = bitselect(s[5] ^ s[7], s[5], s[6]); s[6] = bitselect(s[6] ^ s[8], s[6], s[7]); s[7] = bitselect(s[7] ^ s[9], s[7], s[8]); s[8] = bitselect(s[8] ^ tmp1, s[8], s[9]); s[9] = bitselect(s[9] ^ tmp2, s[9], tmp1);
+		tmp1 = s[10]; tmp2 = s[11]; s[10] = bitselect(s[10] ^ s[12], s[10], s[11]); s[11] = bitselect(s[11] ^ s[13], s[11], s[12]); s[12] = bitselect(s[12] ^ s[14], s[12], s[13]); s[13] = bitselect(s[13] ^ tmp1, s[13], s[14]); s[14] = bitselect(s[14] ^ tmp2, s[14], tmp1);
+		tmp1 = s[15]; tmp2 = s[16]; s[15] = bitselect(s[15] ^ s[17], s[15], s[16]); s[16] = bitselect(s[16] ^ s[18], s[16], s[17]); s[17] = bitselect(s[17] ^ s[19], s[17], s[18]); s[18] = bitselect(s[18] ^ tmp1, s[18], s[19]); s[19] = bitselect(s[19] ^ tmp2, s[19], tmp1);
+		tmp1 = s[20]; tmp2 = s[21]; s[20] = bitselect(s[20] ^ s[22], s[20], s[21]); s[21] = bitselect(s[21] ^ s[23], s[21], s[22]); s[22] = bitselect(s[22] ^ s[24], s[22], s[23]); s[23] = bitselect(s[23] ^ tmp1, s[23], s[24]); s[24] = bitselect(s[24] ^ tmp2, s[24], tmp1);
+		s[0] ^= keccakf_rndc[i];
+	}
+}
+
+__device__ __forceinline__ void cn_keccakf(uint64_t *s)
+{
+	uint64_t bc[5], tmpxor[5], tmp1, tmp2;
+
+	for(int i = 0; i < 24; ++i)
+	{
+		tmpxor[0] = s[0] ^ s[5] ^ s[10] ^ s[15] ^ s[20];
+		tmpxor[1] = s[1] ^ s[6] ^ s[11] ^ s[16] ^ s[21];
+		tmpxor[2] = s[2] ^ s[7] ^ s[12] ^ s[17] ^ s[22];
+		tmpxor[3] = s[3] ^ s[8] ^ s[13] ^ s[18] ^ s[23];
+		tmpxor[4] = s[4] ^ s[9] ^ s[14] ^ s[19] ^ s[24];
+
+		bc[0] = tmpxor[0] ^ rotl64_1(tmpxor[2], 1);
+		bc[1] = tmpxor[1] ^ rotl64_1(tmpxor[3], 1);
+		bc[2] = tmpxor[2] ^ rotl64_1(tmpxor[4], 1);
+		bc[3] = tmpxor[3] ^ rotl64_1(tmpxor[0], 1);
+		bc[4] = tmpxor[4] ^ rotl64_1(tmpxor[1], 1);
+
+		tmp1 = s[1] ^ bc[0];
+
+		s[0] ^= bc[4];
+		s[1] = rotl64_2(s[6] ^ bc[0], 12);
+		s[6] = rotl64_1(s[9] ^ bc[3], 20);
+		s[9] = rotl64_2(s[22] ^ bc[1], 29);
+		s[22] = rotl64_2(s[14] ^ bc[3], 7);
+		s[14] = rotl64_1(s[20] ^ bc[4], 18);
+		s[20] = rotl64_2(s[2] ^ bc[1], 30);
+		s[2] = rotl64_2(s[12] ^ bc[1], 11);
+		s[12] = rotl64_1(s[13] ^ bc[2], 25);
+		s[13] = rotl64_1(s[19] ^ bc[3], 8);
+		s[19] = rotl64_2(s[23] ^ bc[2], 24);
+		s[23] = rotl64_2(s[15] ^ bc[4], 9);
+		s[15] = rotl64_1(s[4] ^ bc[3], 27);
+		s[4] = rotl64_1(s[24] ^ bc[3], 14);
+		s[24] = rotl64_1(s[21] ^ bc[0], 2);
+		s[21] = rotl64_2(s[8] ^ bc[2], 23);
+		s[8] = rotl64_2(s[16] ^ bc[0], 13);
+		s[16] = rotl64_2(s[5] ^ bc[4], 4);
+		s[5] = rotl64_1(s[3] ^ bc[2], 28);
+		s[3] = rotl64_1(s[18] ^ bc[2], 21);
+		s[18] = rotl64_1(s[17] ^ bc[1], 15);
+		s[17] = rotl64_1(s[11] ^ bc[0], 10);
+		s[11] = rotl64_1(s[7] ^ bc[1], 6);
+		s[7] = rotl64_1(s[10] ^ bc[4], 3);
+		s[10] = rotl64_1(tmp1, 1);
+
+		tmp1 = s[0]; tmp2 = s[1]; s[0] = bitselect(s[0] ^ s[2], s[0], s[1]); s[1] = bitselect(s[1] ^ s[3], s[1], s[2]); s[2] = bitselect(s[2] ^ s[4], s[2], s[3]); s[3] = bitselect(s[3] ^ tmp1, s[3], s[4]); s[4] = bitselect(s[4] ^ tmp2, s[4], tmp1);
+		tmp1 = s[5]; tmp2 = s[6]; s[5] = bitselect(s[5] ^ s[7], s[5], s[6]); s[6] = bitselect(s[6] ^ s[8], s[6], s[7]); s[7] = bitselect(s[7] ^ s[9], s[7], s[8]); s[8] = bitselect(s[8] ^ tmp1, s[8], s[9]); s[9] = bitselect(s[9] ^ tmp2, s[9], tmp1);
+		tmp1 = s[10]; tmp2 = s[11]; s[10] = bitselect(s[10] ^ s[12], s[10], s[11]); s[11] = bitselect(s[11] ^ s[13], s[11], s[12]); s[12] = bitselect(s[12] ^ s[14], s[12], s[13]); s[13] = bitselect(s[13] ^ tmp1, s[13], s[14]); s[14] = bitselect(s[14] ^ tmp2, s[14], tmp1);
+		tmp1 = s[15]; tmp2 = s[16]; s[15] = bitselect(s[15] ^ s[17], s[15], s[16]); s[16] = bitselect(s[16] ^ s[18], s[16], s[17]); s[17] = bitselect(s[17] ^ s[19], s[17], s[18]); s[18] = bitselect(s[18] ^ tmp1, s[18], s[19]); s[19] = bitselect(s[19] ^ tmp2, s[19], tmp1);
+		tmp1 = s[20]; tmp2 = s[21]; s[20] = bitselect(s[20] ^ s[22], s[20], s[21]); s[21] = bitselect(s[21] ^ s[23], s[21], s[22]); s[22] = bitselect(s[22] ^ s[24], s[22], s[23]); s[23] = bitselect(s[23] ^ tmp1, s[23], s[24]); s[24] = bitselect(s[24] ^ tmp2, s[24], tmp1);
+		s[0] ^= keccakf_rndc[i];
+	}
+}
+
+__device__ __forceinline__ void cn_keccak(const uint8_t * __restrict__ in, uint32_t len, uint8_t * __restrict__ md)
+{
+	uint64_t st[25];
+
+	MEMSET8(st + 8, 0x00, 25 - 8);
+	memcpy(st, in, len);
+	((uint8_t*)st)[len] = 0x01;
+	st[16] = 0x8000000000000000ULL;
+
+	cn_keccakf(st);
+
+	MEMCPY8(md, st, 25);
+	return;
+}
diff --git a/xmrig-cuda/src/cuda_skein.hpp b/xmrig-cuda/src/cuda_skein.hpp
new file mode 100644
index 0000000..041a593
--- /dev/null
+++ b/xmrig-cuda/src/cuda_skein.hpp
@@ -0,0 +1,347 @@
+#pragma once
+
+typedef unsigned int    uint_t;             /* native unsigned integer */
+
+#define SKEIN_MODIFIER_WORDS  ( 2)          /* number of modifier (tweak) words */
+
+#define SKEIN_256_STATE_WORDS ( 4)
+#define SKEIN_512_STATE_WORDS ( 8)
+#define SKEIN1024_STATE_WORDS (16)
+
+#define SKEIN_256_STATE_BYTES ( 8*SKEIN_256_STATE_WORDS)
+#define SKEIN_512_STATE_BYTES ( 8*SKEIN_512_STATE_WORDS)
+#define SKEIN1024_STATE_BYTES ( 8*SKEIN1024_STATE_WORDS)
+
+#define SKEIN_256_STATE_BITS  (64*SKEIN_256_STATE_WORDS)
+#define SKEIN_512_STATE_BITS  (64*SKEIN_512_STATE_WORDS)
+#define SKEIN1024_STATE_BITS  (64*SKEIN1024_STATE_WORDS)
+
+#define SKEIN_256_BLOCK_BYTES ( 8*SKEIN_256_STATE_WORDS)
+#define SKEIN_512_BLOCK_BYTES ( 8*SKEIN_512_STATE_WORDS)
+#define SKEIN1024_BLOCK_BYTES ( 8*SKEIN1024_STATE_WORDS)
+
+#define SKEIN_MK_64(hi32,lo32)  ((lo32) + (((uint64_t) (hi32)) << 32))
+#define SKEIN_KS_PARITY         SKEIN_MK_64(0x1BD11BDA,0xA9FC1A22)
+
+#define SKEIN_T1_BIT(BIT)       ((BIT) - 64)            /* offset 64 because it's the second word  */
+
+#define SKEIN_T1_POS_FIRST      SKEIN_T1_BIT(126)       /* bits 126     : first block flag         */
+#define SKEIN_T1_POS_BIT_PAD    SKEIN_T1_BIT(119)       /* bit  119     : partial final input byte */
+#define SKEIN_T1_POS_FINAL      SKEIN_T1_BIT(127)       /* bit  127     : final block flag         */
+#define SKEIN_T1_POS_BLK_TYPE   SKEIN_T1_BIT(120)       /* bits 120..125: type field               */
+
+#define SKEIN_T1_FLAG_FIRST     (((uint64_t)  1 ) << SKEIN_T1_POS_FIRST)
+#define SKEIN_T1_FLAG_BIT_PAD   (((uint64_t)  1 ) << SKEIN_T1_POS_BIT_PAD)
+#define SKEIN_T1_FLAG_FINAL     (((uint64_t)  1 ) << SKEIN_T1_POS_FINAL)
+
+#define SKEIN_BLK_TYPE_MSG      (48)                    /* message processing */
+#define SKEIN_BLK_TYPE_OUT      (63)                    /* output stage */
+
+#define SKEIN_T1_BLK_TYPE(T)   (((uint64_t) (SKEIN_BLK_TYPE_##T)) << SKEIN_T1_POS_BLK_TYPE)
+
+#define SKEIN_T1_BLK_TYPE_MSG   SKEIN_T1_BLK_TYPE(MSG)  /* message processing */
+#define SKEIN_T1_BLK_TYPE_OUT   SKEIN_T1_BLK_TYPE(OUT)  /* output stage */
+
+#define SKEIN_T1_BLK_TYPE_OUT_FINAL       (SKEIN_T1_BLK_TYPE_OUT | SKEIN_T1_FLAG_FINAL)
+
+#define Skein_Set_Tweak(ctxPtr,TWK_NUM,tVal)    {(ctxPtr)->h.T[TWK_NUM] = (tVal);}
+
+#define Skein_Set_T0(ctxPtr,T0) Skein_Set_Tweak(ctxPtr,0,T0)
+#define Skein_Set_T1(ctxPtr,T1) Skein_Set_Tweak(ctxPtr,1,T1)
+
+#define Skein_Set_T0_T1(ctxPtr,T0,T1) { \
+  Skein_Set_T0(ctxPtr,(T0)); \
+  Skein_Set_T1(ctxPtr,(T1)); }
+
+#define Skein_Start_New_Type(ctxPtr,BLK_TYPE)   \
+{ Skein_Set_T0_T1(ctxPtr,0,SKEIN_T1_FLAG_FIRST | SKEIN_T1_BLK_TYPE_##BLK_TYPE); (ctxPtr)->h.bCnt=0; }
+
+#define Skein_Set_Bit_Pad_Flag(hdr)      { (hdr).T[1] |=  SKEIN_T1_FLAG_BIT_PAD;     }
+
+#define KW_TWK_BASE     (0)
+#define KW_KEY_BASE     (3)
+#define ks              (kw + KW_KEY_BASE)
+#define ts              (kw + KW_TWK_BASE)
+
+#define R512(p0,p1,p2,p3,p4,p5,p6,p7,R512ROT,rNum) \
+	X##p0 += X##p1; X##p1 = ROTL64(X##p1,R512ROT##_0); X##p1 ^= X##p0; \
+	X##p2 += X##p3; X##p3 = ROTL64(X##p3,R512ROT##_1); X##p3 ^= X##p2; \
+	X##p4 += X##p5; X##p5 = ROTL64(X##p5,R512ROT##_2); X##p5 ^= X##p4; \
+	X##p6 += X##p7; X##p7 = ROTL64(X##p7,R512ROT##_3); X##p7 ^= X##p6;
+
+#define I512(R) \
+	X0   += ks[((R)+1) % 9]; \
+	X1   += ks[((R)+2) % 9]; \
+	X2   += ks[((R)+3) % 9]; \
+	X3   += ks[((R)+4) % 9]; \
+	X4   += ks[((R)+5) % 9]; \
+	X5   += ks[((R)+6) % 9] + ts[((R)+1) % 3]; \
+	X6   += ks[((R)+7) % 9] + ts[((R)+2) % 3]; \
+	X7   += ks[((R)+8) % 9] + (R)+1;
+
+
+#define R512_8_rounds(R) \
+	R512(0,1,2,3,4,5,6,7,R_512_0,8*(R)+ 1); \
+	R512(2,1,4,7,6,5,0,3,R_512_1,8*(R)+ 2); \
+	R512(4,1,6,3,0,5,2,7,R_512_2,8*(R)+ 3); \
+	R512(6,1,0,7,2,5,4,3,R_512_3,8*(R)+ 4); \
+	I512(2*(R)); \
+	R512(0,1,2,3,4,5,6,7,R_512_4,8*(R)+ 5); \
+	R512(2,1,4,7,6,5,0,3,R_512_5,8*(R)+ 6); \
+	R512(4,1,6,3,0,5,2,7,R_512_6,8*(R)+ 7); \
+	R512(6,1,0,7,2,5,4,3,R_512_7,8*(R)+ 8); \
+	I512(2*(R)+1);
+
+typedef struct
+{
+	size_t  hashBitLen;
+	size_t  bCnt;
+	uint64_t  T[SKEIN_MODIFIER_WORDS];
+} Skein_Ctxt_Hdr_t;
+
+typedef struct {
+	Skein_Ctxt_Hdr_t h;
+	uint64_t  X[SKEIN_256_STATE_WORDS];
+	uint8_t  b[SKEIN_256_BLOCK_BYTES];
+} Skein_256_Ctxt_t;
+
+typedef struct {
+	Skein_Ctxt_Hdr_t h;
+	uint64_t  X[SKEIN_512_STATE_WORDS];
+	uint8_t  b[SKEIN_512_BLOCK_BYTES];
+} Skein_512_Ctxt_t;
+
+typedef struct {
+	Skein_Ctxt_Hdr_t h;
+	uint64_t  X[SKEIN1024_STATE_WORDS];
+	uint8_t  b[SKEIN1024_BLOCK_BYTES];
+} Skein1024_Ctxt_t;
+
+typedef struct {
+	uint_t  statebits;
+	union {
+		Skein_Ctxt_Hdr_t h;
+		Skein_256_Ctxt_t ctx_256;
+		Skein_512_Ctxt_t ctx_512;
+		Skein1024_Ctxt_t ctx1024;
+	} u;
+} skeinHashState;
+
+__device__ void cn_skein_init(skeinHashState *state, size_t hashBitLen)
+{
+	const uint64_t SKEIN_512_IV_256[] =
+	{
+		SKEIN_MK_64(0xCCD044A1,0x2FDB3E13),
+		SKEIN_MK_64(0xE8359030,0x1A79A9EB),
+		SKEIN_MK_64(0x55AEA061,0x4F816E6F),
+		SKEIN_MK_64(0x2A2767A4,0xAE9B94DB),
+		SKEIN_MK_64(0xEC06025E,0x74DD7683),
+		SKEIN_MK_64(0xE7A436CD,0xC4746251),
+		SKEIN_MK_64(0xC36FBAF9,0x393AD185),
+		SKEIN_MK_64(0x3EEDBA18,0x33EDFC13)
+	};
+
+	Skein_512_Ctxt_t *ctx = &state->u.ctx_512;
+
+	ctx->h.hashBitLen = hashBitLen;
+
+	memcpy(ctx->X, SKEIN_512_IV_256, sizeof(ctx->X));
+
+	Skein_Start_New_Type(ctx, MSG);
+}
+
+__device__ void cn_skein512_processblock(Skein_512_Ctxt_t * __restrict__ ctx, const uint8_t * __restrict__ blkPtr, size_t blkCnt, size_t byteCntAdd)
+{
+	enum {
+		R_512_0_0=46, R_512_0_1=36, R_512_0_2=19, R_512_0_3=37,
+		R_512_1_0=33, R_512_1_1=27, R_512_1_2=14, R_512_1_3=42,
+		R_512_2_0=17, R_512_2_1=49, R_512_2_2=36, R_512_2_3=39,
+		R_512_3_0=44, R_512_3_1= 9, R_512_3_2=54, R_512_3_3=56,
+		R_512_4_0=39, R_512_4_1=30, R_512_4_2=34, R_512_4_3=24,
+		R_512_5_0=13, R_512_5_1=50, R_512_5_2=10, R_512_5_3=17,
+		R_512_6_0=25, R_512_6_1=29, R_512_6_2=39, R_512_6_3=43,
+		R_512_7_0= 8, R_512_7_1=35, R_512_7_2=56, R_512_7_3=22
+	};
+
+	uint64_t X0,X1,X2,X3,X4,X5,X6,X7;
+	uint64_t w[SKEIN_512_STATE_WORDS];
+	uint64_t kw[SKEIN_512_STATE_WORDS+4];
+
+	ts[0] = ctx->h.T[0];
+	ts[1] = ctx->h.T[1];
+
+	do
+	{
+
+		ts[0] += byteCntAdd;
+
+		ks[0] = ctx->X[0];
+		ks[1] = ctx->X[1];
+		ks[2] = ctx->X[2];
+		ks[3] = ctx->X[3];
+		ks[4] = ctx->X[4];
+		ks[5] = ctx->X[5];
+		ks[6] = ctx->X[6];
+		ks[7] = ctx->X[7];
+		ks[8] = ks[0] ^ ks[1] ^ ks[2] ^ ks[3] ^
+		ks[4] ^ ks[5] ^ ks[6] ^ ks[7] ^ SKEIN_KS_PARITY;
+
+		ts[2] = ts[0] ^ ts[1];
+
+		memcpy(w, blkPtr, SKEIN_512_STATE_WORDS << 3);
+
+		X0 = w[0] + ks[0];
+		X1 = w[1] + ks[1];
+		X2 = w[2] + ks[2];
+		X3 = w[3] + ks[3];
+		X4 = w[4] + ks[4];
+		X5 = w[5] + ks[5] + ts[0];
+		X6 = w[6] + ks[6] + ts[1];
+		X7 = w[7] + ks[7];
+
+		blkPtr += SKEIN_512_BLOCK_BYTES;
+
+		R512_8_rounds( 0);
+		R512_8_rounds( 1);
+		R512_8_rounds( 2);
+		R512_8_rounds( 3);
+		R512_8_rounds( 4);
+		R512_8_rounds( 5);
+		R512_8_rounds( 6);
+		R512_8_rounds( 7);
+		R512_8_rounds( 8);
+
+		ctx->X[0] = X0 ^ w[0];
+		ctx->X[1] = X1 ^ w[1];
+		ctx->X[2] = X2 ^ w[2];
+		ctx->X[3] = X3 ^ w[3];
+		ctx->X[4] = X4 ^ w[4];
+		ctx->X[5] = X5 ^ w[5];
+		ctx->X[6] = X6 ^ w[6];
+		ctx->X[7] = X7 ^ w[7];
+
+		ts[1] &= ~SKEIN_T1_FLAG_FIRST;
+	} 
+	while (--blkCnt);
+
+	ctx->h.T[0] = ts[0];
+	ctx->h.T[1] = ts[1];
+}
+
+__device__ void cn_skein_final(skeinHashState * __restrict__ state, uint8_t * __restrict__ hashVal)
+{
+	size_t i,n,byteCnt;
+	uint64_t X[SKEIN_512_STATE_WORDS];
+	Skein_512_Ctxt_t *ctx = (Skein_512_Ctxt_t *)&state->u.ctx_512;
+	//size_t tmp;
+	//uint8_t *p8;
+	//uint64_t *p64;
+
+	ctx->h.T[1] |= SKEIN_T1_FLAG_FINAL;
+
+	if (ctx->h.bCnt < SKEIN_512_BLOCK_BYTES) 
+	{
+		memset(&ctx->b[ctx->h.bCnt],0,SKEIN_512_BLOCK_BYTES - ctx->h.bCnt);
+		//p8 = &ctx->b[ctx->h.bCnt];
+		//tmp = SKEIN_512_BLOCK_BYTES - ctx->h.bCnt;
+		//for( i = 0; i < tmp; i++ ) *(p8+i) = 0;
+	}
+
+	cn_skein512_processblock(ctx,ctx->b,1,ctx->h.bCnt);
+
+	byteCnt = (ctx->h.hashBitLen + 7) >> 3;
+
+	//uint8_t  b[SKEIN_512_BLOCK_BYTES] == 64
+	memset(ctx->b,0,sizeof(ctx->b));
+	//p64 = (uint64_t *)ctx->b;
+	//for( i = 0; i < 8; i++ ) *(p64+i) = 0;
+
+	memcpy(X,ctx->X,sizeof(X));
+
+	for (i=0;i*SKEIN_512_BLOCK_BYTES < byteCnt;i++) 
+	{
+		((uint64_t *)ctx->b)[0]= (uint64_t)i;
+		Skein_Start_New_Type(ctx,OUT_FINAL);
+		cn_skein512_processblock(ctx,ctx->b,1,sizeof(uint64_t));
+		n = byteCnt - i*SKEIN_512_BLOCK_BYTES;
+		if (n >= SKEIN_512_BLOCK_BYTES)
+		n  = SKEIN_512_BLOCK_BYTES;
+		memcpy(hashVal+i*SKEIN_512_BLOCK_BYTES,ctx->X,n);
+		memcpy(ctx->X,X,sizeof(X));   /* restore the counter mode key for next time */
+	}
+}
+
+__device__ void cn_skein512_update(Skein_512_Ctxt_t * __restrict__ ctx, const uint8_t * __restrict__ msg, size_t msgByteCnt)
+{
+	size_t n;
+
+	if (msgByteCnt + ctx->h.bCnt > SKEIN_512_BLOCK_BYTES) 
+	{
+
+		if (ctx->h.bCnt) 
+		{
+
+			n = SKEIN_512_BLOCK_BYTES - ctx->h.bCnt;
+
+			if (n) 
+			{
+				memcpy(&ctx->b[ctx->h.bCnt],msg,n);
+				msgByteCnt  -= n;
+				msg         += n;
+				ctx->h.bCnt += n;
+			}
+
+			cn_skein512_processblock(ctx,ctx->b,1,SKEIN_512_BLOCK_BYTES);
+			ctx->h.bCnt = 0;
+		}
+
+		if (msgByteCnt > SKEIN_512_BLOCK_BYTES) 
+		{
+			n = (msgByteCnt-1) / SKEIN_512_BLOCK_BYTES;
+			cn_skein512_processblock(ctx,msg,n,SKEIN_512_BLOCK_BYTES);
+			msgByteCnt -= n * SKEIN_512_BLOCK_BYTES;
+			msg        += n * SKEIN_512_BLOCK_BYTES;
+		}
+	}
+
+	if (msgByteCnt) 
+	{
+		memcpy(&ctx->b[ctx->h.bCnt],msg,msgByteCnt);
+		ctx->h.bCnt += msgByteCnt;
+	}
+}
+
+__device__ void cn_skein_update(skeinHashState * __restrict__ state, const BitSequence * __restrict__ data, DataLength databitlen)
+{
+	if ((databitlen & 7) == 0) 
+	{
+		cn_skein512_update(&state->u.ctx_512,data,databitlen >> 3);
+	}
+	else 
+	{
+
+		size_t bCnt = (databitlen >> 3) + 1;
+		uint8_t b,mask;
+
+		mask = (uint8_t) (1u << (7 - (databitlen & 7)));
+		b    = (uint8_t) ((data[bCnt-1] & (0-mask)) | mask);
+
+		cn_skein512_update(&state->u.ctx_512,data,bCnt-1);
+		cn_skein512_update(&state->u.ctx_512,&b  ,  1   );
+
+		Skein_Set_Bit_Pad_Flag(state->u.h);
+	}
+}
+
+__device__ void cn_skein(const BitSequence * __restrict__ data, DataLength len, BitSequence * __restrict__ hashval)
+{
+	int hashbitlen = 256;
+	DataLength databitlen = len << 3;
+	skeinHashState state;
+
+	state.statebits = 64*SKEIN_512_STATE_WORDS;
+
+	cn_skein_init(&state, hashbitlen);
+	cn_skein_update(&state, data, databitlen);
+	cn_skein_final(&state, hashval);
+}
diff --git a/xmrig-cuda/src/version.h b/xmrig-cuda/src/version.h
new file mode 100644
index 0000000..bfc3cd7
--- /dev/null
+++ b/xmrig-cuda/src/version.h
@@ -0,0 +1,40 @@
+/* XMRig
+ * Copyright 2010      Jeff Garzik <jgarzik@pobox.com>
+ * Copyright 2012-2014 pooler      <pooler@litecoinpool.org>
+ * Copyright 2014      Lucas Jones <https://github.com/lucasjones>
+ * Copyright 2014-2016 Wolf9466    <https://github.com/OhGodAPet>
+ * Copyright 2016      Jay D Dee   <jayddee246@gmail.com>
+ * Copyright 2017-2018 XMR-Stak    <https://github.com/fireice-uk>, <https://github.com/psychocrypt>
+ * Copyright 2018-2019 SChernykh   <https://github.com/SChernykh>
+ * Copyright 2016-2019 XMRig       <https://github.com/xmrig>, <support@xmrig.com>
+ *
+ *   This program is free software: you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation, either version 3 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef XMRIG_VERSION_H
+#define XMRIG_VERSION_H
+
+#define APP_ID        "xmrig-cuda"
+#define APP_NAME      "XMRig"
+#define APP_DESC      "XMRig CUDA plugin"
+#define APP_VERSION   "2.0.1-beta"
+#define APP_DOMAIN    "xmrig.com"
+#define APP_SITE      "www.xmrig.com"
+#define APP_COPYRIGHT "Copyright (C) 2016-2019 xmrig.com"
+
+#define APP_VER_MAJOR  2
+#define APP_VER_MINOR  0
+#define APP_VER_PATCH  1
+
+#endif /* XMRIG_VERSION_H */
diff --git a/xmrig-cuda/src/xmrig-cuda.cpp b/xmrig-cuda/src/xmrig-cuda.cpp
new file mode 100644
index 0000000..b40bf7f
--- /dev/null
+++ b/xmrig-cuda/src/xmrig-cuda.cpp
@@ -0,0 +1,339 @@
+/* XMRig
+ * Copyright 2010      Jeff Garzik <jgarzik@pobox.com>
+ * Copyright 2012-2014 pooler      <pooler@litecoinpool.org>
+ * Copyright 2014      Lucas Jones <https://github.com/lucasjones>
+ * Copyright 2014-2016 Wolf9466    <https://github.com/OhGodAPet>
+ * Copyright 2016      Jay D Dee   <jayddee246@gmail.com>
+ * Copyright 2017-2018 XMR-Stak    <https://github.com/fireice-uk>, <https://github.com/psychocrypt>
+ * Copyright 2018-2019 SChernykh   <https://github.com/SChernykh>
+ * Copyright 2016-2019 XMRig       <https://github.com/xmrig>, <support@xmrig.com>
+ *
+ *   This program is free software: you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation, either version 3 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+
+#include "cryptonight.h"
+#include "cuda_device.hpp"
+#include "version.h"
+#include "xmrig-cuda.h"
+
+
+#include <map>
+#include <mutex>
+#include <string>
+#include <cuda_runtime_api.h>
+
+
+static std::mutex mutex;
+
+
+class DatasetHost
+{
+public:
+    inline const void *reg(const void *dataset, size_t size)
+    {
+        std::lock_guard<std::mutex> lock(mutex);
+
+        if (!m_ptr) {
+            m_ptr = const_cast<void *>(dataset);
+            CUDA_CHECK(0, cudaHostRegister(m_ptr, size, cudaHostRegisterPortable | cudaHostRegisterMapped));
+        }
+
+        ++m_refs;
+
+        return m_ptr;
+    }
+
+
+    inline void release()
+    {
+        std::lock_guard<std::mutex> lock(mutex);
+
+        --m_refs;
+
+        if (m_refs == 0) {
+            cudaHostUnregister(m_ptr);
+        }
+    }
+
+    int32_t m_refs  = 0;
+    void *m_ptr     = nullptr;
+};
+
+
+static std::map<int, std::string> errors;
+
+
+static inline void saveError(int id, std::exception &ex)
+{
+    std::lock_guard<std::mutex> lock(mutex);
+    errors[id] = ex.what();
+}
+
+
+static inline void resetError(int id)
+{
+    std::lock_guard<std::mutex> lock(mutex);
+    errors.erase(id);
+}
+
+
+extern "C" {
+
+
+bool cnHash(nvid_ctx *ctx, uint32_t startNonce, uint64_t height, uint64_t target, uint32_t *rescount, uint32_t *resnonce)
+{
+    resetError(ctx->device_id);
+
+    try {
+        cryptonight_extra_cpu_prepare(ctx, startNonce);
+        cryptonight_gpu_hash(ctx, height, startNonce);
+        cryptonight_extra_cpu_final(ctx, startNonce, target, rescount, resnonce);
+    }
+    catch (std::exception &ex) {
+        saveError(ctx->device_id, ex);
+
+        return false;
+    }
+
+    return true;
+}
+
+
+bool deviceInit(nvid_ctx *ctx)
+{
+    resetError(ctx->device_id);
+
+    if (ctx == nullptr) {
+        return false;
+    }
+
+    int rc = 0;
+
+    try {
+        rc = cryptonight_gpu_init(ctx);
+    }
+    catch (std::exception &ex) {
+        saveError(ctx->device_id, ex);
+
+        return false;
+    }
+
+    return rc;
+}
+
+bool setJob(nvid_ctx *ctx, const void *data, size_t size, uint64_t extra_iters)
+{
+    resetError(ctx->device_id);
+
+    if (ctx == nullptr) {
+        return false;
+    }
+
+    ctx->extra_iters = extra_iters;
+
+    try {
+        cryptonight_extra_cpu_set_data(ctx, data, size);
+    }
+    catch (std::exception &ex) {
+        saveError(ctx->device_id, ex);
+
+        return false;
+    }
+
+    return true;
+}
+
+
+const char *deviceName(nvid_ctx *ctx)
+{
+    return ctx->device_name;
+}
+
+
+const char *lastError(nvid_ctx *ctx)
+{
+    std::lock_guard<std::mutex> lock(mutex);
+
+    return errors.count(ctx->device_id) ? errors[ctx->device_id].c_str() : nullptr;
+}
+
+
+const char *pluginVersion()
+{
+    return APP_VERSION;
+}
+
+
+int32_t deviceInfo(nvid_ctx *ctx, int32_t blocks, int32_t threads)
+{
+    ctx->device_blocks   = blocks;
+    ctx->device_threads  = threads;
+
+    return cuda_get_deviceinfo(ctx);
+}
+
+
+int32_t deviceInt(nvid_ctx *ctx, DeviceProperty property)
+{
+    if (ctx == nullptr) {
+        return 0;
+    }
+
+    switch (property) {
+    case DeviceId:
+        return ctx->device_id;
+
+    case DeviceArchMajor:
+        return ctx->device_arch[0];
+
+    case DeviceArchMinor:
+        return ctx->device_arch[1];
+
+    case DeviceSmx:
+        return ctx->device_mpcount;
+
+    case DeviceBlocks:
+        return ctx->device_blocks;
+
+    case DeviceThreads:
+        return ctx->device_threads;
+
+    case DeviceBFactor:
+        return ctx->device_bfactor;
+
+    case DeviceBSleep:
+        return ctx->device_bsleep;
+
+    case DeviceClockRate:
+        return ctx->device_clockRate;
+
+    case DeviceMemoryClockRate:
+        return ctx->device_memoryClockRate;
+
+    case DevicePciBusID:
+        return ctx->device_pciBusID;
+
+    case DevicePciDeviceID:
+        return ctx->device_pciDeviceID;
+
+    case DevicePciDomainID:
+        return ctx->device_pciDomainID;
+
+    default:
+        break;
+    };
+
+    return 0;
+}
+
+
+nvid_ctx *alloc(uint32_t id, int32_t bfactor, int32_t bsleep)
+{
+    auto ctx = new nvid_ctx();
+
+    ctx->device_id      = static_cast<int>(id);
+    ctx->device_bfactor = bfactor;
+    ctx->device_bsleep  = bsleep;
+
+    return ctx;
+}
+
+
+uint32_t deviceCount()
+{
+    return static_cast<uint32_t>(cuda_get_devicecount());
+}
+
+
+uint32_t deviceUint(nvid_ctx *ctx, DeviceProperty property)
+{
+    return static_cast<uint32_t>(deviceInt(ctx, property));
+}
+
+
+uint32_t version(Version version)
+{
+    switch (version) {
+    case ApiVersion:
+        return APP_VER_MAJOR;
+
+    case DriverVersion:
+        return static_cast<uint32_t>(cuda_get_driver_version());
+
+    case RuntimeVersion:
+        return static_cast<uint32_t>(cuda_get_runtime_version());
+    }
+
+    return 0;
+}
+
+
+uint64_t deviceUlong(nvid_ctx *ctx, DeviceProperty property)
+{
+    if (ctx == nullptr) {
+        return 0;
+    }
+
+    switch (property) {
+    case DeviceMemoryTotal:
+        return ctx->device_memoryTotal;
+
+    case DeviceMemoryFree:
+        return ctx->device_memoryFree;
+
+    default:
+        break;
+    }
+
+    return 0;
+}
+
+
+void init()
+{
+    cuInit(0);
+}
+
+
+void release(nvid_ctx *ctx)
+{
+    if (ctx == nullptr) {
+        return;
+    }
+
+    delete[] ctx->device_name;
+
+    // cudaFree, cuModuleUnload, cuCtxDestroy check for nullptr internally
+
+    cudaFree(ctx->d_input);
+    cudaFree(ctx->d_result_count);
+    cudaFree(ctx->d_result_nonce);
+    cudaFree(ctx->d_long_state);
+    cudaFree(ctx->d_ctx_state);
+    cudaFree(ctx->d_ctx_state2);
+    cudaFree(ctx->d_ctx_a);
+    cudaFree(ctx->d_ctx_b);
+    cudaFree(ctx->d_ctx_key1);
+    cudaFree(ctx->d_ctx_key2);
+    cudaFree(ctx->d_ctx_text);
+
+    cuModuleUnload(ctx->module);
+
+    cuCtxDestroy(ctx->cuContext);
+
+    delete ctx;
+}
+
+}
diff --git a/xmrig-cuda/src/xmrig-cuda.h b/xmrig-cuda/src/xmrig-cuda.h
new file mode 100644
index 0000000..0ab4964
--- /dev/null
+++ b/xmrig-cuda/src/xmrig-cuda.h
@@ -0,0 +1,100 @@
+/* XMRig
+ * Copyright 2010      Jeff Garzik <jgarzik@pobox.com>
+ * Copyright 2012-2014 pooler      <pooler@litecoinpool.org>
+ * Copyright 2014      Lucas Jones <https://github.com/lucasjones>
+ * Copyright 2014-2016 Wolf9466    <https://github.com/OhGodAPet>
+ * Copyright 2016      Jay D Dee   <jayddee246@gmail.com>
+ * Copyright 2017-2018 XMR-Stak    <https://github.com/fireice-uk>, <https://github.com/psychocrypt>
+ * Copyright 2018-2019 SChernykh   <https://github.com/SChernykh>
+ * Copyright 2016-2019 XMRig       <https://github.com/xmrig>, <support@xmrig.com>
+ *
+ *   This program is free software: you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation, either version 3 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef XMRIG_CUDA_H
+#define XMRIG_CUDA_H
+
+
+#include <cstdint>
+#include <cstddef>
+
+
+#if defined _WIN32 || defined __CYGWIN__
+#   define XMRIG_EXPORT __declspec(dllexport)
+#   define XMRIG_HIDDEN
+#else
+#   define XMRIG_EXPORT __attribute__ ((visibility ("default")))
+#   define XMRIG_HIDDEN  __attribute__ ((visibility ("hidden")))
+#endif
+
+
+using nvid_ctx = struct nvid_ctx;
+
+
+enum Version : uint32_t
+{
+    ApiVersion,
+    DriverVersion,
+    RuntimeVersion
+};
+
+
+enum DeviceProperty : uint32_t
+{
+    DeviceId,
+    DeviceArchMajor,
+    DeviceArchMinor,
+    DeviceSmx,
+    DeviceBlocks,
+    DeviceThreads,
+    DeviceBFactor,
+    DeviceBSleep,
+    DeviceClockRate,
+    DeviceMemoryClockRate,
+    DeviceMemoryTotal,
+    DeviceMemoryFree,
+    DevicePciBusID,
+    DevicePciDeviceID,
+    DevicePciDomainID
+};
+
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+
+XMRIG_EXPORT bool cnHash(nvid_ctx *ctx, uint32_t startNonce, uint64_t height, uint64_t target, uint32_t *rescount, uint32_t *resnonce);
+XMRIG_EXPORT bool deviceInit(nvid_ctx *ctx);
+XMRIG_EXPORT bool setJob(nvid_ctx *ctx, const void *data, size_t size, uint64_t extra_iters);
+XMRIG_EXPORT const char *deviceName(nvid_ctx *ctx);
+XMRIG_EXPORT const char *lastError(nvid_ctx *ctx);
+XMRIG_EXPORT const char *pluginVersion();
+XMRIG_EXPORT int32_t deviceInfo(nvid_ctx *ctx, int32_t blocks, int32_t threads);
+XMRIG_EXPORT int32_t deviceInt(nvid_ctx *ctx, DeviceProperty property);
+XMRIG_EXPORT nvid_ctx *alloc(uint32_t id, int32_t bfactor, int32_t bsleep);
+XMRIG_EXPORT uint32_t deviceCount();
+XMRIG_EXPORT uint32_t deviceUint(nvid_ctx *ctx, DeviceProperty property);
+XMRIG_EXPORT uint32_t version(Version version);
+XMRIG_EXPORT uint64_t deviceUlong(nvid_ctx *ctx, DeviceProperty property);
+XMRIG_EXPORT void init();
+XMRIG_EXPORT void release(nvid_ctx *ctx);
+
+
+#if defined(__cplusplus)
+}
+#endif
+
+
+#endif /* XMRIG_CUDA_H */
